#! <?xml version="1.0" encoding="utf-8" ?>
#! <WORKSPACE
#    
#    
#    Command-line to run this workspace:
#    
#    
#    C:\apps\FME\fme.exe C:\Marcos_Batista\FME\CORRIGIR_NOMEABREV_EDICAO.fmw
#          --SourceDataset_MDB_ADO "C:\Marcos_Batista\FME\mdb\b_sirgas_utm.mdb"
#          --SourceDataset_MDB_ADO_3 "C:\Marcos_Batista\FME\mdb\b_sirgas_utm.mdb"
#          --FEATURE_TYPES "Veg_Cultivada_SHAPE_Index Veg_Cultivada Trilha_Picada_SHAPE_Index Trilha_Picada Trecho_Rodoviario_SHAPE_Index Trecho_Rodoviario Trecho_Massa_Dagua_SHAPE_Index Trecho_Massa_Dagua Trecho_Energia_SHAPE_Index Trecho_Energia Trecho_Duto_SHAPE_Index Trecho_Duto Trecho_Drenagem_SHAPE_Index Trecho_Drenagem Travessia_point_SHAPE_Index Travessia_point Torre_Comunic_SHAPE_Index Torre_Comunic Terreno_Suj_Inundacao_SHAPE_Index Terreno_Suj_Inundacao Terreno_Exposto_SHAPE_Index Terreno_Exposto T_1_PolyErrors_Shape_Index T_1_PolyErrors T_1_PointErrors_Shape_Index T_1_PointErrors T_1_LineErrors_Shape_Index T_1_LineErrors T_1_DirtyAreas_DirtyArea_Index T_1_DirtyAreas Sumidouro_Vertedouro_SHAPE_Index Sumidouro_Vertedouro Selections SelectedObjects Rocha_polygon_SHAPE_Index Rocha_polygon Pto_Est_Med_Fenomenos_SHAPE_Index Pto_Est_Med_Fenomenos Posto_Combustivel_point_SHAPE_Index Posto_Combustivel_point Ponto_Trecho_Energia_SHAPE_Index Ponto_Trecho_Energia Ponto_Rodoviario_Ferrov_SHAPE_Index Ponto_Rodoviario_Ferrov Ponto_Inicio_Drenagem_SHAPE_Index Ponto_Inicio_Drenagem Ponto_Duto_SHAPE_Index Ponto_Duto Ponto_Drenagem_SHAPE_Index Ponto_Drenagem Ponto_Cotado_Altimetrico_SHAPE_Index Ponto_Cotado_Altimetrico Ponte_point_SHAPE_Index Ponte_point Pista_Ponto_Pouso_polygon_SHAPE_Index Pista_Ponto_Pouso_polygon Pista_Competicao_line_SHAPE_Index Pista_Competicao_line Patio_polygon_SHAPE_Index Patio_polygon Nome_Local_SHAPE_Index Nome_Local Massa_Dagua_SHAPE_Index Massa_Dagua Limite_Massa_Dagua_SHAPE_Index Limite_Massa_Dagua Ilha_polygon_SHAPE_Index Ilha_polygon Identific_Trecho_Rod_SHAPE_Index Identific_Trecho_Rod Gruta_Caverna_point_SHAPE_Index Gruta_Caverna_point Grupo_Transform_Energ_point_SHAPE_Index Grupo_Transform_Energ_point GDB_SpatialRefs GDB_ReplicaLog GDB_ItemTypes GDB_Items_Shape_Index GDB_Items GDB_ItemRelationshipTypes GDB_ItemRelationships GDB_GeomColumns GDB_DatabaseLocks GDB_ColumnInfo Galeria_Bueiro_point_SHAPE_Index Galeria_Bueiro_point Fonte_Dagua_SHAPE_Index Fonte_Dagua Est_Gerad_Energia_Eletr_polygon_SHAPE_Index Est_Gerad_Energia_Eletr_polygon Entroncamento_SHAPE_Index Entroncamento Elemento_Fisiog_Natural_point_SHAPE_Index Elemento_Fisiog_Natural_point Elemento_Fisiog_Natural_line_SHAPE_Index Elemento_Fisiog_Natural_line Edif_Servico_Social_polygon_SHAPE_Index Edif_Servico_Social_polygon Edif_Servico_Social_point_SHAPE_Index Edif_Servico_Social_point Edif_Saude_polygon_SHAPE_Index Edif_Saude_polygon Edif_Saude_point_SHAPE_Index Edif_Saude_point Edif_Saneamento_point_SHAPE_Index Edif_Saneamento_point Edif_Rodoviaria_polygon_SHAPE_Index Edif_Rodoviaria_polygon Edif_Rodoviaria_point_SHAPE_Index Edif_Rodoviaria_point Edif_Religiosa_polygon_SHAPE_Index Edif_Religiosa_polygon Edif_Religiosa_point_SHAPE_Index Edif_Religiosa_point Edif_Pub_Militar_polygon_SHAPE_Index Edif_Pub_Militar_polygon Edif_Pub_Militar_point_SHAPE_Index Edif_Pub_Militar_point Edif_Pub_Civil_polygon_SHAPE_Index Edif_Pub_Civil_polygon Edif_Pub_Civil_point_SHAPE_Index Edif_Pub_Civil_point Edif_Industrial_polygon_SHAPE_Index Edif_Industrial_polygon Edif_Industrial_point_SHAPE_Index Edif_Industrial_point Edif_Habitacional_point_SHAPE_Index Edif_Habitacional_point Edif_Ext_Mineral_polygon_SHAPE_Index Edif_Ext_Mineral_polygon Edif_Ext_Mineral_point_SHAPE_Index Edif_Ext_Mineral_point Edif_Ensino_polygon_SHAPE_Index Edif_Ensino_polygon Edif_Ensino_point_SHAPE_Index Edif_Ensino_point Edif_Constr_Est_Med_point_SHAPE_Index Edif_Constr_Est_Med_point Edif_Const_Turistica_point_SHAPE_Index Edif_Const_Turistica_point Edif_Const_Lazer_polygon_SHAPE_Index Edif_Const_Lazer_polygon Edif_Const_Lazer_point_SHAPE_Index Edif_Const_Lazer_point Edif_Const_Aeroportuaria_point_SHAPE_Index Edif_Const_Aeroportuaria_point Edif_Comunic_point_SHAPE_Index Edif_Comunic_point Edif_Comerc_Serv_polygon_SHAPE_Index Edif_Comerc_Serv_polygon Edif_Comerc_Serv_point_SHAPE_Index Edif_Comerc_Serv_point Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index Edif_Agrop_Ext_Veg_Pesca_point Edif_Abast_Agua_point_SHAPE_Index Edif_Abast_Agua_point Deposito_Geral_polygon_SHAPE_Index Deposito_Geral_polygon Deposito_Geral_point_SHAPE_Index Deposito_Geral_point Dep_Saneamento_polygon_SHAPE_Index Dep_Saneamento_polygon Dep_Saneamento_point_SHAPE_Index Dep_Saneamento_point Dep_Abast_Agua_point_SHAPE_Index Dep_Abast_Agua_point Delimitacao_Fisica_SHAPE_Index Delimitacao_Fisica Curva_Nivel_SHAPE_Index Curva_Nivel Confluencia_SHAPE_Index Confluencia Comporta_line_SHAPE_Index Comporta_line Cidade_SHAPE_Index Cidade Cerrado_Cerradao_SHAPE_Index Cerrado_Cerradao Cemiterio_polygon_SHAPE_Index Cemiterio_polygon Cemiterio_point_SHAPE_Index Cemiterio_point Campo_SHAPE_Index Campo_Quadra_polygon_SHAPE_Index Campo_Quadra_polygon Campo_Quadra_point_SHAPE_Index Campo_Quadra_point Campo Caatinga_SHAPE_Index Caatinga Barragem_line_SHAPE_Index Barragem_line Banco_Areia_polygon_SHAPE_Index Banco_Areia_polygon Atracadouro_polygon_SHAPE_Index Atracadouro_polygon Atracadouro_point_SHAPE_Index Atracadouro_point Arruamento_SHAPE_Index Arruamento Arquibancada_point_SHAPE_Index Arquibancada_point Area_Uso_Comunitario_point_SHAPE_Index Area_Uso_Comunitario_point Area_Lazer_SHAPE_Index Area_Lazer Area_Industrial_SHAPE_Index Area_Industrial Area_Ext_Mineral_SHAPE_Index Area_Ext_Mineral Area_Energia_Eletrica_SHAPE_Index Area_Energia_Eletrica Area_Edificada_SHAPE_Index Area_Edificada Antena_Comunic_SHAPE_Index Antena_Comunic Alter_Fisiog_Antropica_line_SHAPE_Index Alter_Fisiog_Antropica_line Aglomerado_Rural_SHAPE_Index Aglomerado_Rural"
#          --DestDataset_MDB_ADO "C:\Marcos_Batista\FME\mdb\b_sirgas_utm_nomeAbrev.mdb"
#          --DestDataset_MDB_ADO_2 "C:\Marcos_Batista\FME\mdb\b_sirgas_utm_nomeAbrev.mdb"
#          --SourceDataset_MDB_ADO_4 "C:\Marcos_Batista\FME\mdb\b_sirgas_utm_NOMEABREV.mdb"
#    
#    
#! DOC_EXTENTS="6721.09 30752.6"
#! VIEW_POSITION="-1881.1 454.059"
#! LOG_MAX_PRECISION="Yes"
#! WORKSPACE_VERSION="1"
#! REQUIREMENTS=""
#! FME_GEOMETRY_HANDLING="Enhanced"
#! FME_IMPLICIT_CSMAP_REPROJECTION_MODE="Auto"
#! BEGIN_TCL=""
#! IGNORE_READER_FAILURE="No"
#! MULTI_WRITER_DATASET_ORDER="BY_ID"
#! FME_DOCUMENT_PRIORGUID="014d7512-bc70-42e5-9a2e-b69766ca7c87,d59ec897-1d22-46c7-80ad-4146a9815357,14e7be72-a664-4c21-a2ee-a153f59fdbf0,430f0d17-8552-4936-87c8-71d35c114e91"
#! ATTR_TYPE_ENCODING="SDF"
#! PASSWORD=""
#! WARN_INVALID_XFORM_PARAM="Yes"
#! REQUIREMENTS_KEYWORD=""
#! MAX_LOG_FEATURES="200"
#! SOURCE="NONE"
#! CATEGORY=""
#! LAST_SAVE_BUILD="FME(R) 2015.1.2.1 (20150924 - Build 15539 - WIN32)"
#! HISTORY=""
#! BEGIN_PYTHON=""
#! TITLE=""
#! REDIRECT_TERMINATORS="NONE"
#! DESTINATION="VISUALIZER"
#! LOG_MAX_RECORDED_FEATURES="200"
#! SHOW_INFO_NODES="true"
#! LAST_SAVE_DATE="2020-01-29T08:25:25"
#! DESTINATION_ROUTING_FILE=""
#! DESCRIPTION=""
#! FME_DOCUMENT_GUID="dfbdf08c-1648-4479-a283-8d7f49ce5267"
#! END_TCL=""
#! DOC_TOP_LEFT="-0.367184 -30380.6"
#! LEGAL_TERMS_CONDITIONS=""
#! FME_STROKE_MAX_DEVIATION="0"
#! FME_SERVER_SERVICES=""
#! END_PYTHON=""
#! LOG_FILE=""
#! FME_REPROJECTION_ENGINE="FME"
#! FME_BUILD_NUM="15539"
#! ZOOM_SCALE="37"
#! SOURCE_ROUTING_FILE=""
#! USAGE=""
#! SHOW_ANNOTATIONS="true"
#! >
#! <DATASETS>
#! <DATASET
#! IS_SOURCE="true"
#! ROLE="READER"
#! FORMAT="MDB_ADO"
#! DATASET="$(SourceDataset_MDB_ADO)"
#! KEYWORD="MDB_ADO_1"
#! MULTI_GEOM_ALLOWED="false"
#! ATTR_MAX_LENGTH="60"
#! ATTR_CASE="ANY"
#! ALLOWED_FEAT_TYPES=""
#! WRITE_DEFS="true"
#! DEFLINE_TEMPLATE="mdb_sql_statement &quot;&quot; mdb_where_clause &quot;&quot;"
#! DEFLINE_ATTRS="true"
#! EXPOSABLE_ATTRS="fme_basename text(50) db_type text(254) fme_geometry fme_char(50) fme_type text(50) fme_color text(50) fme_sweep_angle double fme_secondary_axis double fme_fill_color text(50) multi_reader_type text(50) multi_reader_keyword text(50) fme_text_size double fme_primary_axis double fme_text_string text(50) fme_rotation double fme_dataset text(50) multi_reader_id long multi_reader_full_id long fme_start_angle double fme_feature_type text(50)"
#! DEFLINE_PARMS="&quot;GUI OPTIONAL TEXT mdb_where_clause  WHERE Clause&quot; &quot;&quot; &quot;GUI OPTIONAL TEXT mdb_sql_statement     SELECT Statement&quot; &quot;&quot; "
#! ATTR_INDEX_TYPES="indexed unique"
#! ATTR_NAME_INVALID_CHARS=""
#! SUPPORTS_FEATURE_TYPE_FANOUT="true"
#! ENABLED="true"
#! DYNAMIC_FEATURE_TYPES_LIST_ON_MERGE="true"
#! DATASET_TYPE="FILE"
#! GENERATE_FME_BUILD_NUM="15539"
#! MAX_FEATURES=""
#! MAX_FEATURES_PER_FEATURE_TYPE=""
#! FEATURE_TYPES=""
#! COORDSYS=""
#! START_FEATURE=""
#! MIN_FEATURES=""
#! >
#! <METAFILE_PARAMETER
#! NAME="MIME_TYPE"
#! VALUE="application/x-msaccess ADD_DISPOSITION"
#! />
#! <METAFILE_PARAMETER
#! NAME="READER_DATASET_HINT"
#! VALUE="Select the MDB_ADO file(s)"
#! />
#! <METAFILE_PARAMETER
#! NAME="FEATURE_TYPE_NAME"
#! VALUE="Table"
#! />
#! <METAFILE_PARAMETER
#! NAME="WRITER_DATASET_HINT"
#! VALUE="Specify the MDB_ADO file"
#! />
#! <METAFILE_PARAMETER
#! NAME="DATASET_NAME"
#! VALUE="Database"
#! />
#! <METAFILE_PARAMETER
#! NAME="FEATURE_TYPE_DEFAULT_NAME"
#! VALUE="Table1"
#! />
#! </DATASET>
#! <DATASET
#! IS_SOURCE="true"
#! ROLE="READER"
#! FORMAT="MDB_ADO"
#! DATASET="$(SourceDataset_MDB_ADO_3)"
#! KEYWORD="MDB_ADO_2"
#! MULTI_GEOM_ALLOWED="false"
#! ATTR_MAX_LENGTH="60"
#! ATTR_CASE="ANY"
#! ALLOWED_FEAT_TYPES=""
#! WRITE_DEFS="true"
#! DEFLINE_TEMPLATE="mdb_sql_statement &quot;&quot; mdb_where_clause &quot;&quot;"
#! DEFLINE_ATTRS="true"
#! EXPOSABLE_ATTRS="fme_basename text(50) db_type text(254) fme_geometry fme_char(50) fme_type text(50) fme_color text(50) fme_sweep_angle double fme_secondary_axis double fme_fill_color text(50) multi_reader_type text(50) multi_reader_keyword text(50) fme_text_size double fme_primary_axis double fme_text_string text(50) fme_rotation double fme_dataset text(50) multi_reader_id long multi_reader_full_id long fme_start_angle double fme_feature_type text(50)"
#! DEFLINE_PARMS="&quot;GUI OPTIONAL TEXT mdb_where_clause  WHERE Clause&quot; &quot;&quot; &quot;GUI OPTIONAL TEXT mdb_sql_statement     SELECT Statement&quot; &quot;&quot; "
#! ATTR_INDEX_TYPES="indexed unique"
#! ATTR_NAME_INVALID_CHARS="./*;:!#&amp;&quot;&apos;"
#! SUPPORTS_FEATURE_TYPE_FANOUT="true"
#! ENABLED="true"
#! DYNAMIC_FEATURE_TYPES_LIST_ON_MERGE="true"
#! DATASET_TYPE="FILE"
#! GENERATE_FME_BUILD_NUM="15539"
#! MAX_FEATURES=""
#! MAX_FEATURES_PER_FEATURE_TYPE=""
#! FEATURE_TYPES="$(FEATURE_TYPES)"
#! COORDSYS=""
#! START_FEATURE=""
#! MIN_FEATURES=""
#! >
#! <METAFILE_PARAMETER
#! NAME="MIME_TYPE"
#! VALUE="application/x-msaccess ADD_DISPOSITION"
#! />
#! <METAFILE_PARAMETER
#! NAME="READER_DATASET_HINT"
#! VALUE="Select the MDB_ADO file(s)"
#! />
#! <METAFILE_PARAMETER
#! NAME="FEATURE_TYPE_NAME"
#! VALUE="Table"
#! />
#! <METAFILE_PARAMETER
#! NAME="WRITER_DATASET_HINT"
#! VALUE="Specify the MDB_ADO file"
#! />
#! <METAFILE_PARAMETER
#! NAME="DATASET_NAME"
#! VALUE="Database"
#! />
#! <METAFILE_PARAMETER
#! NAME="FEATURE_TYPE_DEFAULT_NAME"
#! VALUE="Table1"
#! />
#! </DATASET>
#! <DATASET
#! IS_SOURCE="true"
#! ROLE="READER"
#! FORMAT="MDB_ADO"
#! DATASET="$(SourceDataset_MDB_ADO_4)"
#! KEYWORD="MDB_ADO_5"
#! MULTI_GEOM_ALLOWED="false"
#! ATTR_MAX_LENGTH="60"
#! ATTR_CASE="ANY"
#! ALLOWED_FEAT_TYPES=""
#! WRITE_DEFS="true"
#! DEFLINE_TEMPLATE="mdb_sql_statement &quot;&quot; mdb_where_clause &quot;&quot;"
#! DEFLINE_ATTRS="true"
#! EXPOSABLE_ATTRS="fme_basename text(50) db_type text(254) fme_geometry fme_char(50) fme_type text(50) fme_sweep_angle double fme_color text(50) fme_secondary_axis double fme_fill_color text(50) multi_reader_keyword text(50) multi_reader_type text(50) fme_text_size double fme_primary_axis double fme_text_string text(50) fme_rotation double fme_dataset text(50) multi_reader_id long multi_reader_full_id long fme_start_angle double fme_feature_type text(50)"
#! DEFLINE_PARMS="&quot;GUI OPTIONAL TEXT mdb_where_clause  WHERE Clause&quot; &quot;&quot; &quot;GUI OPTIONAL TEXT mdb_sql_statement     SELECT Statement&quot; &quot;&quot; "
#! ATTR_INDEX_TYPES="indexed unique"
#! ATTR_NAME_INVALID_CHARS=""
#! SUPPORTS_FEATURE_TYPE_FANOUT="true"
#! ENABLED="true"
#! DYNAMIC_FEATURE_TYPES_LIST_ON_MERGE="true"
#! DATASET_TYPE="FILE"
#! GENERATE_FME_BUILD_NUM="15539"
#! MAX_FEATURES=""
#! MAX_FEATURES_PER_FEATURE_TYPE=""
#! FEATURE_TYPES=""
#! COORDSYS=""
#! START_FEATURE=""
#! MIN_FEATURES=""
#! >
#! <METAFILE_PARAMETER
#! NAME="MIME_TYPE"
#! VALUE="application/x-msaccess ADD_DISPOSITION"
#! />
#! <METAFILE_PARAMETER
#! NAME="READER_DATASET_HINT"
#! VALUE="Select the MDB_ADO file(s)"
#! />
#! <METAFILE_PARAMETER
#! NAME="FEATURE_TYPE_NAME"
#! VALUE="Table"
#! />
#! <METAFILE_PARAMETER
#! NAME="WRITER_DATASET_HINT"
#! VALUE="Specify the MDB_ADO file"
#! />
#! <METAFILE_PARAMETER
#! NAME="DATASET_NAME"
#! VALUE="Database"
#! />
#! <METAFILE_PARAMETER
#! NAME="FEATURE_TYPE_DEFAULT_NAME"
#! VALUE="Table1"
#! />
#! </DATASET>
#! <DATASET
#! IS_SOURCE="false"
#! ROLE="WRITER"
#! FORMAT="MDB_ADO"
#! DATASET="$(DestDataset_MDB_ADO)"
#! KEYWORD="MDB_ADO_3"
#! MULTI_GEOM_ALLOWED="true"
#! ATTR_MAX_LENGTH="64"
#! ATTR_CASE="ANY"
#! ALLOWED_FEAT_TYPES=""
#! WRITE_DEFS="true"
#! DEFLINE_TEMPLATE="mdb_update_key_columns &quot;&quot; mdb_drop_table NO mdb_truncate_table NO mdb_table_writer_mode INHERIT_FROM_WRITER"
#! DEFLINE_ATTRS="true"
#! EXPOSABLE_ATTRS="fme_where text(254) fme_basename text(50) db_type text(254) fme_geometry fme_char(50) fme_type text(50) fme_sweep_angle double fme_color text(50) fme_secondary_axis double fme_fill_color text(50) fme_text_size double fme_primary_axis double fme_db_operation text(8) fme_text_string text(50) fme_db_transaction text(16) fme_rotation double fme_dataset text(50) fme_start_angle double fme_feature_type text(50)"
#! DEFLINE_PARMS="&quot;GUI CHOICE mdb_drop_table NO%YES Drop Table First&quot; NO &quot;GUI CHOICE mdb_truncate_table NO%YES Truncate Table First&quot; NO &quot;GUI CHOICE mdb_table_writer_mode INHERIT_FROM_WRITER%INSERT%UPDATE%DELETE Writer Mode&quot; INHERIT_FROM_WRITER &quot;GUI OPTIONAL ATTRLIST_COMMAS mdb_update_key_columns SQL Key Columns&quot; &quot;&quot; "
#! ATTR_INDEX_TYPES="indexed unique"
#! ATTR_NAME_INVALID_CHARS="./*;:!#&amp;&quot;&apos;"
#! SUPPORTS_FEATURE_TYPE_FANOUT="true"
#! ENABLED="true"
#! DYNAMIC_FEATURE_TYPES_LIST_ON_MERGE="true"
#! DATASET_TYPE="FILE"
#! GENERATE_FME_BUILD_NUM="15539"
#! FANOUT_ID_ATTR=""
#! FANOUT="No"
#! COORDSYS=""
#! FANOUT_SUFFIX=""
#! FANOUT_DIRECTORY=""
#! FANOUT_PREFIX=""
#! >
#! <METAFILE_PARAMETER
#! NAME="MIME_TYPE"
#! VALUE="application/x-msaccess ADD_DISPOSITION"
#! />
#! <METAFILE_PARAMETER
#! NAME="READER_DATASET_HINT"
#! VALUE="Select the MDB_ADO file(s)"
#! />
#! <METAFILE_PARAMETER
#! NAME="FEATURE_TYPE_NAME"
#! VALUE="Table"
#! />
#! <METAFILE_PARAMETER
#! NAME="WRITER_DATASET_HINT"
#! VALUE="Specify the MDB_ADO file"
#! />
#! <METAFILE_PARAMETER
#! NAME="DATASET_NAME"
#! VALUE="Database"
#! />
#! <METAFILE_PARAMETER
#! NAME="FEATURE_TYPE_DEFAULT_NAME"
#! VALUE="Table1"
#! />
#! </DATASET>
#! <DATASET
#! IS_SOURCE="false"
#! ROLE="WRITER"
#! FORMAT="MDB_ADO"
#! DATASET="$(DestDataset_MDB_ADO_2)"
#! KEYWORD="MDB_ADO_4"
#! MULTI_GEOM_ALLOWED="true"
#! ATTR_MAX_LENGTH="64"
#! ATTR_CASE="ANY"
#! ALLOWED_FEAT_TYPES=""
#! WRITE_DEFS="true"
#! DEFLINE_TEMPLATE="mdb_update_key_columns &quot;&quot; mdb_drop_table NO mdb_truncate_table NO mdb_table_writer_mode INHERIT_FROM_WRITER"
#! DEFLINE_ATTRS="true"
#! EXPOSABLE_ATTRS="fme_where text(254) fme_basename text(50) db_type text(254) fme_geometry fme_char(50) fme_type text(50) fme_sweep_angle double fme_color text(50) fme_secondary_axis double fme_fill_color text(50) fme_text_size double fme_primary_axis double fme_db_operation text(8) fme_text_string text(50) fme_db_transaction text(16) fme_rotation double fme_dataset text(50) fme_start_angle double fme_feature_type text(50)"
#! DEFLINE_PARMS="&quot;GUI CHOICE mdb_drop_table NO%YES Drop Table First&quot; NO &quot;GUI CHOICE mdb_truncate_table NO%YES Truncate Table First&quot; NO &quot;GUI CHOICE mdb_table_writer_mode INHERIT_FROM_WRITER%INSERT%UPDATE%DELETE Writer Mode&quot; INHERIT_FROM_WRITER &quot;GUI OPTIONAL ATTRLIST_COMMAS mdb_update_key_columns SQL Key Columns&quot; &quot;&quot; "
#! ATTR_INDEX_TYPES="indexed unique"
#! ATTR_NAME_INVALID_CHARS="./*;:!#&amp;&quot;&apos;"
#! SUPPORTS_FEATURE_TYPE_FANOUT="true"
#! ENABLED="true"
#! DYNAMIC_FEATURE_TYPES_LIST_ON_MERGE="true"
#! DATASET_TYPE="FILE"
#! GENERATE_FME_BUILD_NUM="15539"
#! FANOUT_ID_ATTR=""
#! FANOUT="No"
#! COORDSYS=""
#! FANOUT_SUFFIX=""
#! FANOUT_DIRECTORY=""
#! FANOUT_PREFIX=""
#! >
#! <METAFILE_PARAMETER
#! NAME="MIME_TYPE"
#! VALUE="application/x-msaccess ADD_DISPOSITION"
#! />
#! <METAFILE_PARAMETER
#! NAME="READER_DATASET_HINT"
#! VALUE="Select the MDB_ADO file(s)"
#! />
#! <METAFILE_PARAMETER
#! NAME="FEATURE_TYPE_NAME"
#! VALUE="Table"
#! />
#! <METAFILE_PARAMETER
#! NAME="WRITER_DATASET_HINT"
#! VALUE="Specify the MDB_ADO file"
#! />
#! <METAFILE_PARAMETER
#! NAME="DATASET_NAME"
#! VALUE="Database"
#! />
#! <METAFILE_PARAMETER
#! NAME="FEATURE_TYPE_DEFAULT_NAME"
#! VALUE="Table1"
#! />
#! </DATASET>
#! </DATASETS>
#! <DATA_TYPES>
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="yesno"
#! FME_TYPE="fme_boolean"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="memo"
#! FME_TYPE="fme_buffer"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="hyperlink"
#! FME_TYPE="fme_buffer"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="replicationid"
#! FME_TYPE="fme_buffer"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="oleobject"
#! FME_TYPE="fme_buffer"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="integer"
#! FME_TYPE="fme_int16"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="integer"
#! FME_TYPE="fme_uint8"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="byte"
#! FME_TYPE="fme_int16"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="long"
#! FME_TYPE="fme_int32"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="long"
#! FME_TYPE="fme_uint16"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="autonumber"
#! FME_TYPE="fme_int32"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="datetime"
#! FME_TYPE="fme_datetime"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="datetime"
#! FME_TYPE="fme_date"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="datetime"
#! FME_TYPE="fme_time"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="decimal(width,decimal)"
#! FME_TYPE="fme_decimal(width,decimal)"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="single"
#! FME_TYPE="fme_real32"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="double"
#! FME_TYPE="fme_real64"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="decimal(10,0)"
#! FME_TYPE="fme_uint32"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="decimal(19,0)"
#! FME_TYPE="fme_int64"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="decimal(20,0)"
#! FME_TYPE="fme_uint64"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="currency"
#! FME_TYPE="fme_real64"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="text(width)"
#! FME_TYPE="fme_varchar(width)"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="text(width)"
#! FME_TYPE="fme_char(width)"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="text(1)"
#! FME_TYPE="fme_char(width)"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="yesno"
#! FME_TYPE="fme_boolean"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="memo"
#! FME_TYPE="fme_buffer"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="hyperlink"
#! FME_TYPE="fme_buffer"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="replicationid"
#! FME_TYPE="fme_buffer"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="oleobject"
#! FME_TYPE="fme_buffer"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="integer"
#! FME_TYPE="fme_int16"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="integer"
#! FME_TYPE="fme_uint8"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="byte"
#! FME_TYPE="fme_int16"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="long"
#! FME_TYPE="fme_int32"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="long"
#! FME_TYPE="fme_uint16"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="autonumber"
#! FME_TYPE="fme_int32"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="datetime"
#! FME_TYPE="fme_datetime"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="datetime"
#! FME_TYPE="fme_date"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="datetime"
#! FME_TYPE="fme_time"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="decimal(width,decimal)"
#! FME_TYPE="fme_decimal(width,decimal)"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="single"
#! FME_TYPE="fme_real32"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="double"
#! FME_TYPE="fme_real64"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="decimal(10,0)"
#! FME_TYPE="fme_uint32"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="decimal(19,0)"
#! FME_TYPE="fme_int64"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="decimal(20,0)"
#! FME_TYPE="fme_uint64"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="currency"
#! FME_TYPE="fme_real64"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="text(width)"
#! FME_TYPE="fme_varchar(width)"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="text(width)"
#! FME_TYPE="fme_char(width)"
#! FORMAT="MDB_ADO"
#! />
#! <DATA_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="text(1)"
#! FME_TYPE="fme_char(width)"
#! FORMAT="MDB_ADO"
#! />
#! </DATA_TYPES>
#! <GEOM_TYPES>
#! <GEOM_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_no_geom"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_point"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_line"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_area"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_text"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_ellipse"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_arc"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_rectangle"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_rounded_rectangle"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_collection"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_raster"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_surface"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_solid"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="true"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_point_cloud"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_no_geom"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_point"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_line"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_area"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_text"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_ellipse"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_arc"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_rectangle"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_rounded_rectangle"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_collection"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_raster"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_surface"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_solid"
#! FORMAT="MDB_ADO"
#! />
#! <GEOM_TYPE
#! IS_SOURCE="false"
#! FORMAT_TYPE="db_none"
#! FME_TYPE="fme_point_cloud"
#! FORMAT="MDB_ADO"
#! />
#! </GEOM_TYPES>
#! <FEATURE_TYPES>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Veg_Cultivada_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="361"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -7699.91"
#! BOUNDING_RECT="91.6328 -7699.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Veg_Cultivada"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="362"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -7837.91"
#! BOUNDING_RECT="91.6328 -7837.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoLavoura" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="denso" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="espessuraDAP" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="classificacaoPorte" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="cultivoPredominante" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="alturaMediaIndividuos" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="terreno" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="espacamentoIndividuos" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="finalidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Trilha_Picada_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="363"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -4525.91"
#! BOUNDING_RECT="91.6328 -4525.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Trilha_Picada"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="364"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -13219.9"
#! BOUNDING_RECT="91.6328 -13219.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Trecho_Rodoviario_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="365"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -27157.9"
#! BOUNDING_RECT="91.6328 -27157.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Trecho_Rodoviario"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="366"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -1903.91"
#! BOUNDING_RECT="91.6328 -1903.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="revestimento" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nrPistas" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="trafego" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSet" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="sigla" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="administracao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="velocidadeMedia" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nrFaixas" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="codTrechoRodov" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="concessionaria" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="canteiroDivisorio" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplRodovia" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoTrechoRod" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="pesoMaxSuportTon" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="jurisdicao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Trecho_Massa_Dagua_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="367"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -2317.91"
#! BOUNDING_RECT="91.6328 -2317.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Trecho_Massa_Dagua"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="368"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -10045.9"
#! BOUNDING_RECT="91.6328 -10045.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="salinidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="regime" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplTrCurDagua" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoMassaDagua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Trecho_Energia_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="369"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 166.098"
#! BOUNDING_RECT="91.6328 166.098 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Trecho_Energia"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="370"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -3421.91"
#! BOUNDING_RECT="91.6328 -3421.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="especie" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="posicaoRelativa" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tensaoEletrica" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="numCircuitos" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="emDuto" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Trecho_Duto_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="371"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -9217.91"
#! BOUNDING_RECT="91.6328 -9217.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Trecho_Duto"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="372"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -20119.9"
#! BOUNDING_RECT="91.6328 -20119.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoTrechoDuto" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="setor" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="posicaoRelativa" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoEspacial" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplDuto" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nrDutos" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matTransp" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Trecho_Drenagem_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="373"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -26467.9"
#! BOUNDING_RECT="91.6328 -26467.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Trecho_Drenagem"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="374"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 28.098"
#! BOUNDING_RECT="91.6328 28.098 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="dentroDePoligono" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="caladoMax" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="navegabilidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplTrCurDagua" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="compartilhado" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="larguraMedia" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="velocidadeMedCorrente" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="regime" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="profundidadeMedia" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="coincideComDentroDe" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="eixoPrincipal" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Travessia_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="375"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -247.902"
#! BOUNDING_RECT="91.6328 -247.902 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Travessia_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="376"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -28399.9"
#! BOUNDING_RECT="91.6328 -28399.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoTravessia" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Torre_Comunic_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="377"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -13909.9"
#! BOUNDING_RECT="91.6328 -13909.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Torre_Comunic"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="378"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -25639.9"
#! BOUNDING_RECT="91.6328 -25639.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="alturaEstimada" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ovgd" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplComunic" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="posicaoRelEdific" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Terreno_Suj_Inundacao_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="379"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -26329.9"
#! BOUNDING_RECT="91.6328 -26329.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Terreno_Suj_Inundacao"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="380"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -22051.9"
#! BOUNDING_RECT="91.6328 -22051.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="periodicidadeInunda" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Terreno_Exposto_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="381"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -25915.9"
#! BOUNDING_RECT="91.6328 -25915.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Terreno_Exposto"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="382"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -27709.9"
#! BOUNDING_RECT="91.6328 -27709.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoTerrExp" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="causaExposicao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="T_1_PolyErrors_Shape_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="383"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -9355.91"
#! BOUNDING_RECT="91.6328 -9355.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="T_1_PolyErrors"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="384"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -2731.91"
#! BOUNDING_RECT="91.6328 -2731.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="ObjectID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OriginClassID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OriginID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DestClassID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DestID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TopoRuleType" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TopoRuleID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Shape" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IsException" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Shape_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Shape_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="T_1_PointErrors_Shape_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="385"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -29089.9"
#! BOUNDING_RECT="91.6328 -29089.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="T_1_PointErrors"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="386"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -29779.9"
#! BOUNDING_RECT="91.6328 -29779.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="ObjectID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OriginClassID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OriginID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DestClassID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DestID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TopoRuleType" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TopoRuleID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Shape" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IsException" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="T_1_LineErrors_Shape_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="387"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -30055.9"
#! BOUNDING_RECT="91.6328 -30055.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="T_1_LineErrors"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="388"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -15703.9"
#! BOUNDING_RECT="91.6328 -15703.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="ObjectID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OriginClassID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OriginID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DestClassID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DestID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TopoRuleType" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TopoRuleID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Shape" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IsException" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Shape_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="T_1_DirtyAreas_DirtyArea_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="389"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -10321.9"
#! BOUNDING_RECT="91.6328 -10321.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="T_1_DirtyAreas"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="390"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -5353.91"
#! BOUNDING_RECT="91.6328 -5353.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="ObjectID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IsRetired" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DirtyArea" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DirtyArea_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DirtyArea_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Sumidouro_Vertedouro_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="391"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -6319.91"
#! BOUNDING_RECT="91.6328 -6319.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Sumidouro_Vertedouro"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="392"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -14323.9"
#! BOUNDING_RECT="91.6328 -14323.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoSumVert" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="causa" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Selections"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="393"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -11701.9"
#! BOUNDING_RECT="91.6328 -11701.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="SelectionID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TargetName" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="SelectedObjects"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="394"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -21775.9"
#! BOUNDING_RECT="91.6328 -21775.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="SelectionID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ObjectID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Rocha_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="395"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -109.902"
#! BOUNDING_RECT="91.6328 -109.902 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Rocha_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="396"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -937.907"
#! BOUNDING_RECT="91.6328 -937.907 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoElemNat" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Pto_Est_Med_Fenomenos_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="397"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -26053.9"
#! BOUNDING_RECT="91.6328 -26053.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Pto_Est_Med_Fenomenos"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="398"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -16117.9"
#! BOUNDING_RECT="91.6328 -16117.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="codEstacao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplEstMedFen" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orgaoEnteResp" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoPtoEstMed" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Posto_Combustivel_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="399"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -12667.9"
#! BOUNDING_RECT="91.6328 -12667.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Posto_Combustivel_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="400"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -17635.9"
#! BOUNDING_RECT="91.6328 -17635.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="administracao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplEstrApoio" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Ponto_Trecho_Energia_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="401"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -6043.91"
#! BOUNDING_RECT="91.6328 -6043.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Ponto_Trecho_Energia"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="402"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -10597.9"
#! BOUNDING_RECT="91.6328 -10597.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoPtoEnergia" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Ponto_Rodoviario_Ferrov_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="403"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -17359.9"
#! BOUNDING_RECT="91.6328 -17359.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Ponto_Rodoviario_Ferrov"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="404"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -24259.9"
#! BOUNDING_RECT="91.6328 -24259.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="relacionado" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="modalUso" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Ponto_Inicio_Drenagem_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="405"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -23155.9"
#! BOUNDING_RECT="91.6328 -23155.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Ponto_Inicio_Drenagem"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="406"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -523.902"
#! BOUNDING_RECT="91.6328 -523.902 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nascente" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Ponto_Duto_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="407"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -28123.9"
#! BOUNDING_RECT="91.6328 -28123.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Ponto_Duto"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="408"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -2179.91"
#! BOUNDING_RECT="91.6328 -2179.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="relacionado" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Ponto_Drenagem_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="409"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -23293.9"
#! BOUNDING_RECT="91.6328 -23293.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Ponto_Drenagem"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="410"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -25501.9"
#! BOUNDING_RECT="91.6328 -25501.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="relacionado" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Ponto_Cotado_Altimetrico_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="411"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -23569.9"
#! BOUNDING_RECT="91.6328 -23569.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Ponto_Cotado_Altimetrico"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="412"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -7147.91"
#! BOUNDING_RECT="91.6328 -7147.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="cota" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="cotaComprovada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="visivel" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Ponte_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="413"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -20257.9"
#! BOUNDING_RECT="91.6328 -20257.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Ponte_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="414"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -13081.9"
#! BOUNDING_RECT="91.6328 -13081.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="false"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="largura" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="extensao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="vaoVertical" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="vaoLivreHoriz" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nrFaixas" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoPonte" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nrPistas" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="necessidadeManutencao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="modalUso" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="pesoMaxSuportTon" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="posicaoPista" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Pista_Ponto_Pouso_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="415"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -24949.9"
#! BOUNDING_RECT="91.6328 -24949.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Pista_Ponto_Pouso_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="416"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -21223.9"
#! BOUNDING_RECT="91.6328 -21223.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="revestimento" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="homologacao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoPista" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplAeroport" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="largura" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="usoPista" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="extensao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Pista_Competicao_line_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="417"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -8527.91"
#! BOUNDING_RECT="91.6328 -8527.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Pista_Competicao_line"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="418"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -16393.9"
#! BOUNDING_RECT="91.6328 -16393.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoPista" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplLazer" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Patio_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="419"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -9079.91"
#! BOUNDING_RECT="91.6328 -9079.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Patio_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="420"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -11149.9"
#! BOUNDING_RECT="91.6328 -11149.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplAeroport" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplPortuario" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgRel" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplIndustria" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgEnsino" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="administracao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgComSv" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgExtMin" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="modalUso" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplLazer" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgAgrop" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplEstrApoio" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Nome_Local_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="421"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -11839.9"
#! BOUNDING_RECT="91.6328 -11839.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Nome_Local"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="422"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -16807.9"
#! BOUNDING_RECT="91.6328 -16807.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Massa_Dagua_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="423"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -20809.9"
#! BOUNDING_RECT="91.6328 -20809.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Massa_Dagua"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="424"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -9907.91"
#! BOUNDING_RECT="91.6328 -9907.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="salinidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="regime" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoMassaDagua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Limite_Massa_Dagua_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="425"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -17221.9"
#! BOUNDING_RECT="91.6328 -17221.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Limite_Massa_Dagua"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="426"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -14047.9"
#! BOUNDING_RECT="91.6328 -14047.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="materialPredominante" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoLimMassa" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="alturaMediaMargem" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Ilha_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="427"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -25363.9"
#! BOUNDING_RECT="91.6328 -25363.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Ilha_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="428"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -14599.9"
#! BOUNDING_RECT="91.6328 -14599.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoElemNat" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Identific_Trecho_Rod_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="429"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -8389.91"
#! BOUNDING_RECT="91.6328 -8389.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Identific_Trecho_Rod"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="430"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -4111.91"
#! BOUNDING_RECT="91.6328 -4111.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplRodovia" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizar" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSet" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="sigla" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="repTipoTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="codTrechoRodov" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Gruta_Caverna_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="431"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -16255.9"
#! BOUNDING_RECT="91.6328 -16255.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Gruta_Caverna_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="432"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -18187.9"
#! BOUNDING_RECT="91.6328 -18187.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoElemNat" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Grupo_Transform_Energ_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="433"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -29503.9"
#! BOUNDING_RECT="91.6328 -29503.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Grupo_Transform_Energ_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="434"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -29227.9"
#! BOUNDING_RECT="91.6328 -29227.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSubEnEletr" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="GDB_SpatialRefs"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="435"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -27433.9"
#! BOUNDING_RECT="91.6328 -27433.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="SRID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SRTEXT" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="FalseX" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="FalseY" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="XYUnits" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="FalseZ" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ZUnits" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="FalseM" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MUnits" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IsHighPrecision" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="XYTolerance" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ZTolerance" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MTolerance" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="GDB_ReplicaLog"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="436"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -14737.9"
#! BOUNDING_RECT="91.6328 -14737.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="ID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ReplicaID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Event" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ErrorCode" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="LogDate" ATTR_TYPE="datetime" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SourceBeginGen" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SourceEndGen" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TargetGen" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="GDB_ItemTypes"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="437"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -6871.91"
#! BOUNDING_RECT="91.6328 -6871.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="ObjectID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="UUID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ParentTypeID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Name" ATTR_TYPE="text(160)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="GDB_Items_Shape_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="438"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -28951.9"
#! BOUNDING_RECT="91.6328 -28951.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="GDB_Items"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="439"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -12115.9"
#! BOUNDING_RECT="91.6328 -12115.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="ObjectID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="UUID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Type" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Name" ATTR_TYPE="text(160)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="PhysicalName" ATTR_TYPE="text(160)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Path" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DatasetSubtype1" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DatasetSubtype2" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DatasetInfo1" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DatasetInfo2" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="URL" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Definition" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Documentation" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ItemInfo" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Properties" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Defaults" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Shape" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="GDB_ItemRelationshipTypes"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="440"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -10183.9"
#! BOUNDING_RECT="91.6328 -10183.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="ObjectID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="UUID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OrigItemTypeID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DestItemTypeID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Name" ATTR_TYPE="text(160)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ForwardLabel" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="BackwardLabel" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IsContainment" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="GDB_ItemRelationships"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="441"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -18049.9"
#! BOUNDING_RECT="91.6328 -18049.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="ObjectID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="UUID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OriginID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DestID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Type" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Attributes" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Properties" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="GDB_GeomColumns"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="442"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -8941.91"
#! BOUNDING_RECT="91.6328 -8941.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="TableName" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="FieldName" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ShapeType" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ExtentLeft" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ExtentBottom" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ExtentRight" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ExtentTop" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IdxOriginX" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IdxOriginY" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IdxGridSize" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SRID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="HasZ" ATTR_TYPE="yesno" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="HasM" ATTR_TYPE="yesno" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ZLow" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ZHigh" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MLow" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MHigh" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="GDB_DatabaseLocks"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="443"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -7975.91"
#! BOUNDING_RECT="91.6328 -7975.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="LockID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="LockType" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="UserName" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MachineName" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="GDB_ColumnInfo"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="444"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -22603.9"
#! BOUNDING_RECT="91.6328 -22603.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="TableName" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="FieldName" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="columnFlags" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Galeria_Bueiro_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="445"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -28537.9"
#! BOUNDING_RECT="91.6328 -28537.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Galeria_Bueiro_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="446"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -14875.9"
#! BOUNDING_RECT="91.6328 -14875.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="pesoMaxSuportTon" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Fonte_Dagua_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="447"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -27571.9"
#! BOUNDING_RECT="91.6328 -27571.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Fonte_Dagua"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="448"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -21361.9"
#! BOUNDING_RECT="91.6328 -21361.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoFonteDagua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="regime" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="qualidAgua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Est_Gerad_Energia_Eletr_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="449"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -19705.9"
#! BOUNDING_RECT="91.6328 -19705.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Est_Gerad_Energia_Eletr_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="450"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -23707.9"
#! BOUNDING_RECT="91.6328 -23707.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEstGerad" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="potenciaFiscalizadaKW" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplGerEnEletr" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="codigoEstacao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="destEnergElet" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="potenciaOutorgadaKW" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Entroncamento_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="451"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -29917.9"
#! BOUNDING_RECT="91.6328 -29917.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Entroncamento"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="452"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -11287.9"
#! BOUNDING_RECT="91.6328 -11287.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEntroncamento" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Elemento_Fisiog_Natural_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="453"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -24673.9"
#! BOUNDING_RECT="91.6328 -24673.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Elemento_Fisiog_Natural_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="454"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -9631.91"
#! BOUNDING_RECT="91.6328 -9631.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoElemNat" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Elemento_Fisiog_Natural_line_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="455"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -22741.9"
#! BOUNDING_RECT="91.6328 -22741.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Elemento_Fisiog_Natural_line"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="456"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -21085.9"
#! BOUNDING_RECT="91.6328 -21085.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoElemNat" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Servico_Social_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="457"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -4663.91"
#! BOUNDING_RECT="91.6328 -4663.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Servico_Social_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="458"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -6457.91"
#! BOUNDING_RECT="91.6328 -6457.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoClasseCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSvSoc" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Servico_Social_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="459"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -25087.9"
#! BOUNDING_RECT="91.6328 -25087.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Servico_Social_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="460"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -22327.9"
#! BOUNDING_RECT="91.6328 -22327.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoClasseCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSvSoc" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Saude_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="461"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -7285.91"
#! BOUNDING_RECT="91.6328 -7285.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Saude_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="462"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -19429.9"
#! BOUNDING_RECT="91.6328 -19429.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSaude" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoClasseCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nivelAtencao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Saude_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="463"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -661.902"
#! BOUNDING_RECT="91.6328 -661.902 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Saude_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="464"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -19153.9"
#! BOUNDING_RECT="91.6328 -19153.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSaude" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoClasseCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nivelAtencao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Saneamento_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="465"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -26881.9"
#! BOUNDING_RECT="91.6328 -26881.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Saneamento_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="466"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -11011.9"
#! BOUNDING_RECT="91.6328 -11011.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSaneam" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifSaneam" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Rodoviaria_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="467"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -14185.9"
#! BOUNDING_RECT="91.6328 -14185.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Rodoviaria_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="468"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -1765.91"
#! BOUNDING_RECT="91.6328 -1765.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifRod" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="administracao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplEstrApoio" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Rodoviaria_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="469"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -12943.9"
#! BOUNDING_RECT="91.6328 -12943.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Rodoviaria_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="470"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -22189.9"
#! BOUNDING_RECT="91.6328 -22189.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifRod" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="administracao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplEstrApoio" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Religiosa_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="471"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -13633.9"
#! BOUNDING_RECT="91.6328 -13633.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Religiosa_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="472"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -18463.9"
#! BOUNDING_RECT="91.6328 -18463.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="religiao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgRel" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifRelig" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ensino" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Religiosa_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="473"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -25225.9"
#! BOUNDING_RECT="91.6328 -25225.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Religiosa_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="474"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -23431.9"
#! BOUNDING_RECT="91.6328 -23431.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="religiao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgRel" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifRelig" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ensino" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Pub_Militar_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="475"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -3283.91"
#! BOUNDING_RECT="91.6328 -3283.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Pub_Militar_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="476"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -28261.9"
#! BOUNDING_RECT="91.6328 -28261.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplMilitar" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdif" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoUsoEdif" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Pub_Militar_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="477"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -7423.91"
#! BOUNDING_RECT="91.6328 -7423.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Pub_Militar_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="478"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -14461.9"
#! BOUNDING_RECT="91.6328 -14461.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplMilitar" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdif" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoUsoEdif" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Pub_Civil_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="479"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -23983.9"
#! BOUNDING_RECT="91.6328 -23983.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Pub_Civil_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="480"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -7561.91"
#! BOUNDING_RECT="91.6328 -7561.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplPubCivil" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdif" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoUsoEdif" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Pub_Civil_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="481"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -26605.9"
#! BOUNDING_RECT="91.6328 -26605.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Pub_Civil_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="482"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -11977.9"
#! BOUNDING_RECT="91.6328 -11977.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplPubCivil" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdif" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoUsoEdif" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Industrial_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="483"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -18601.9"
#! BOUNDING_RECT="91.6328 -18601.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Industrial_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="484"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -15979.9"
#! BOUNDING_RECT="91.6328 -15979.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplIndustria" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="chamine" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDivisaoCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Industrial_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="485"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -25777.9"
#! BOUNDING_RECT="91.6328 -25777.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Industrial_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="486"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -22879.9"
#! BOUNDING_RECT="91.6328 -22879.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplIndustria" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="chamine" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDivisaoCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Habitacional_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="487"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -16531.9"
#! BOUNDING_RECT="91.6328 -16531.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Habitacional_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="488"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -4939.91"
#! BOUNDING_RECT="91.6328 -4939.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplHabit" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Ext_Mineral_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="489"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -4387.91"
#! BOUNDING_RECT="91.6328 -4387.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Ext_Mineral_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="490"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -15427.9"
#! BOUNDING_RECT="91.6328 -15427.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgExtMin" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDivisaoCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Ext_Mineral_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="491"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -17083.9"
#! BOUNDING_RECT="91.6328 -17083.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Ext_Mineral_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="492"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -9769.91"
#! BOUNDING_RECT="91.6328 -9769.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgExtMin" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDivisaoCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Ensino_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="493"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -15151.9"
#! BOUNDING_RECT="91.6328 -15151.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Ensino_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="494"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -26743.9"
#! BOUNDING_RECT="91.6328 -26743.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoClasseCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgEnsino" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Ensino_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="495"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -7009.91"
#! BOUNDING_RECT="91.6328 -7009.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Ensino_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="496"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -8113.91"
#! BOUNDING_RECT="91.6328 -8113.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoClasseCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgEnsino" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Constr_Est_Med_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="497"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -6595.91"
#! BOUNDING_RECT="91.6328 -6595.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Constr_Est_Med_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="498"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -12391.9"
#! BOUNDING_RECT="91.6328 -12391.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplEstMedFen" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Const_Turistica_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="499"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -5215.91"
#! BOUNDING_RECT="91.6328 -5215.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Const_Turistica_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="500"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -3559.91"
#! BOUNDING_RECT="91.6328 -3559.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ovgd" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplLazer" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifTurist" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Const_Lazer_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="501"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -8665.91"
#! BOUNDING_RECT="91.6328 -8665.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Const_Lazer_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="502"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -27295.9"
#! BOUNDING_RECT="91.6328 -27295.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifLazer" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplLazer" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Const_Lazer_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="503"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -2455.91"
#! BOUNDING_RECT="91.6328 -2455.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Const_Lazer_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="504"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -8803.91"
#! BOUNDING_RECT="91.6328 -8803.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifLazer" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplLazer" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Const_Aeroportuaria_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="505"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -5077.91"
#! BOUNDING_RECT="91.6328 -5077.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Const_Aeroportuaria_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="506"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -13357.9"
#! BOUNDING_RECT="91.6328 -13357.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplAeroport" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifAero" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="administracao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Comunic_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="507"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -17773.9"
#! BOUNDING_RECT="91.6328 -17773.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Comunic_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="508"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -17911.9"
#! BOUNDING_RECT="91.6328 -17911.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifComunic" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="modalidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplComunic" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Comerc_Serv_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="509"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -3145.91"
#! BOUNDING_RECT="91.6328 -3145.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Comerc_Serv_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="510"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -12805.9"
#! BOUNDING_RECT="91.6328 -12805.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgComSv" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="finalidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifComercServ" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Comerc_Serv_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="511"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -15289.9"
#! BOUNDING_RECT="91.6328 -15289.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Comerc_Serv_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="512"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -11563.9"
#! BOUNDING_RECT="91.6328 -11563.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgComSv" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="finalidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifComercServ" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="513"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -1489.91"
#! BOUNDING_RECT="91.6328 -1489.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Agrop_Ext_Veg_Pesca_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="514"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -20533.9"
#! BOUNDING_RECT="91.6328 -20533.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgAgrop" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifAgropec" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Abast_Agua_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="515"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -16669.9"
#! BOUNDING_RECT="91.6328 -16669.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Edif_Abast_Agua_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="516"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -18739.9"
#! BOUNDING_RECT="91.6328 -18739.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifAbast" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplAbsAgua" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Deposito_Geral_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="517"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -799.907"
#! BOUNDING_RECT="91.6328 -799.907 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Deposito_Geral_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="518"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -6733.91"
#! BOUNDING_RECT="91.6328 -6733.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoExposicao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgExtMin" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplAeroport" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoProdutoResiduo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoConteudo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="valorVolume" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgComSv" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tratamento" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplIndustria" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplPortuario" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplGerEnEletr" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgAgrop" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDepGeral" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplEstrApoio" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="unidadeVolume" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Deposito_Geral_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="519"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -13771.9"
#! BOUNDING_RECT="91.6328 -13771.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Deposito_Geral_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="520"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -15013.9"
#! BOUNDING_RECT="91.6328 -15013.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoExposicao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgExtMin" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplAeroport" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoProdutoResiduo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoConteudo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="valorVolume" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgComSv" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tratamento" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplIndustria" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplPortuario" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplGerEnEletr" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgAgrop" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDepGeral" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplEstrApoio" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="unidadeVolume" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Dep_Saneamento_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="521"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -18877.9"
#! BOUNDING_RECT="91.6328 -18877.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Dep_Saneamento_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="522"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -3973.91"
#! BOUNDING_RECT="91.6328 -3973.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSaneam" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="residuo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="finalidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="construcao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDepSaneam" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoResiduo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Dep_Saneamento_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="523"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -21637.9"
#! BOUNDING_RECT="91.6328 -21637.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Dep_Saneamento_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="524"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -11425.9"
#! BOUNDING_RECT="91.6328 -11425.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSaneam" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="residuo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="finalidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="construcao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDepSaneam" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoResiduo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Dep_Abast_Agua_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="525"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -10459.9"
#! BOUNDING_RECT="91.6328 -10459.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Delimitacao_Fisica_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="527"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -16945.9"
#! BOUNDING_RECT="91.6328 -16945.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Delimitacao_Fisica"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="528"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -2041.91"
#! BOUNDING_RECT="91.6328 -2041.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDelimFis" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="eletrificada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Curva_Nivel_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="529"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -21499.9"
#! BOUNDING_RECT="91.6328 -21499.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Curva_Nivel"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="530"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -10873.9"
#! BOUNDING_RECT="91.6328 -10873.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="indice" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="depressao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="cota" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ordemTickDepressao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="emMassaDagua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="cotadaPorProcesso" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Confluencia_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="531"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -27847.9"
#! BOUNDING_RECT="91.6328 -27847.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Confluencia"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="532"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -17497.9"
#! BOUNDING_RECT="91.6328 -17497.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="relacionado" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Comporta_line_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="533"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -24397.9"
#! BOUNDING_RECT="91.6328 -24397.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Comporta_line"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="534"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -9493.91"
#! BOUNDING_RECT="91.6328 -9493.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Cidade_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="535"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -8251.91"
#! BOUNDING_RECT="91.6328 -8251.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Cidade"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="536"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -27985.9"
#! BOUNDING_RECT="91.6328 -27985.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="identificadorPosicGeo" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizar" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="longitude" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="latitude" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="longitude_txt" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="latitude_txt" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Cerrado_Cerradao_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="537"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -28675.9"
#! BOUNDING_RECT="91.6328 -28675.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Cerrado_Cerradao"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="538"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -10735.9"
#! BOUNDING_RECT="91.6328 -10735.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="alturaMediaIndividuos" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="denso" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="classificacaoPorte" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="antropizada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCerr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Cemiterio_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="539"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -5629.91"
#! BOUNDING_RECT="91.6328 -5629.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Cemiterio_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="540"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -3697.91"
#! BOUNDING_RECT="91.6328 -3697.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="denominacaoAssociada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCemiterio" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Cemiterio_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="541"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -23017.9"
#! BOUNDING_RECT="91.6328 -23017.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Cemiterio_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="542"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -5905.91"
#! BOUNDING_RECT="91.6328 -5905.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="denominacaoAssociada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCemiterio" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Campo_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="543"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -1075.91"
#! BOUNDING_RECT="91.6328 -1075.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Campo_Quadra_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="544"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -24811.9"
#! BOUNDING_RECT="91.6328 -24811.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Campo_Quadra_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="545"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -12529.9"
#! BOUNDING_RECT="91.6328 -12529.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplLazer" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCampoQuadra" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Campo_Quadra_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="546"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -1213.91"
#! BOUNDING_RECT="91.6328 -1213.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Campo_Quadra_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="547"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -15841.9"
#! BOUNDING_RECT="91.6328 -15841.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplLazer" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCampoQuadra" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Campo"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="548"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -27019.9"
#! BOUNDING_RECT="91.6328 -27019.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ocorrenciaEm" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCampo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Caatinga_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="549"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -5767.91"
#! BOUNDING_RECT="91.6328 -5767.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Caatinga"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="550"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -3835.91"
#! BOUNDING_RECT="91.6328 -3835.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="alturaMediaIndividuos" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="classificacaoPorte" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="denso" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="antropizada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Barragem_line_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="551"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -2869.91"
#! BOUNDING_RECT="91.6328 -2869.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Barragem_line"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="552"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -4801.91"
#! BOUNDING_RECT="91.6328 -4801.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplGerEnEletr" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="usoPrincipal" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Banco_Areia_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="553"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -24121.9"
#! BOUNDING_RECT="91.6328 -24121.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Banco_Areia_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="554"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -29641.9"
#! BOUNDING_RECT="91.6328 -29641.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="materialPredominante" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoEmAgua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoBanco" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Atracadouro_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="555"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -5491.91"
#! BOUNDING_RECT="91.6328 -5491.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Atracadouro_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="556"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -1627.91"
#! BOUNDING_RECT="91.6328 -1627.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplPortuario" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="administracao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoAtracad" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Atracadouro_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="557"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -12253.9"
#! BOUNDING_RECT="91.6328 -12253.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Atracadouro_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="558"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -19981.9"
#! BOUNDING_RECT="91.6328 -19981.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplPortuario" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="administracao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoAtracad" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Arruamento_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="559"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -26191.9"
#! BOUNDING_RECT="91.6328 -26191.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Arruamento"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="560"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -3007.91"
#! BOUNDING_RECT="91.6328 -3007.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="revestimento" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nrFaixas" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="trafego" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="canteiroDivisorio" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Arquibancada_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="561"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -4249.91"
#! BOUNDING_RECT="91.6328 -4249.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Arquibancada_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="562"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -29365.9"
#! BOUNDING_RECT="91.6328 -29365.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplLazer" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Area_Uso_Comunitario_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="563"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -19015.9"
#! BOUNDING_RECT="91.6328 -19015.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Area_Uso_Comunitario_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="564"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -385.902"
#! BOUNDING_RECT="91.6328 -385.902 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoAreaUsoComun" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Area_Lazer_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="565"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -28813.9"
#! BOUNDING_RECT="91.6328 -28813.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Area_Lazer"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="566"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -19843.9"
#! BOUNDING_RECT="91.6328 -19843.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplLazer" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Area_Industrial_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="567"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -19291.9"
#! BOUNDING_RECT="91.6328 -19291.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Area_Industrial"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="568"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -13495.9"
#! BOUNDING_RECT="91.6328 -13495.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplIndustria" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Area_Ext_Mineral_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="569"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -24535.9"
#! BOUNDING_RECT="91.6328 -24535.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Area_Ext_Mineral"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="570"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -20671.9"
#! BOUNDING_RECT="91.6328 -20671.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgExtMin" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Area_Energia_Eletrica_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="571"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -6181.91"
#! BOUNDING_RECT="91.6328 -6181.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Area_Energia_Eletrica"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="572"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -18325.9"
#! BOUNDING_RECT="91.6328 -18325.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplGerEnEletr" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSubEnEletr" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Area_Edificada_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="573"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -21913.9"
#! BOUNDING_RECT="91.6328 -21913.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Area_Edificada"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="574"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -22465.9"
#! BOUNDING_RECT="91.6328 -22465.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Antena_Comunic_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="575"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -20395.9"
#! BOUNDING_RECT="91.6328 -20395.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Antena_Comunic"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="576"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -2593.91"
#! BOUNDING_RECT="91.6328 -2593.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplComunic" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="posicaoRelEdific" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Alter_Fisiog_Antropica_line_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="577"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -15565.9"
#! BOUNDING_RECT="91.6328 -15565.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Alter_Fisiog_Antropica_line"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="578"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -1351.91"
#! BOUNDING_RECT="91.6328 -1351.91 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSet" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoAlterAntrop" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Aglomerado_Rural_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="579"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -23845.9"
#! BOUNDING_RECT="91.6328 -23845.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Aglomerado_Rural"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="580"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="91.6328 -20947.9"
#! BOUNDING_RECT="91.6328 -20947.9 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoAglomerado" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="identificadorPosicGeo" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizar" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="longitude" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="latitude" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="longitude_txt" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="latitude_txt" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Veg_Cultivada_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="582"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="2924.51 159.22"
#! BOUNDING_RECT="2924.51 159.22 -1 -1"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_2"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER="*"
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="true"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ExtentRight" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OriginClassID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifAero" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nrPistas" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCemiterio" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="FieldName" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IsRetired" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MUnits" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MLow" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplDuto" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DirtyArea" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SRTEXT" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TargetGen" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoResiduo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoAglomerado" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="LockID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nrDutos" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ZUnits" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ExtentTop" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDivisaoCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="relacionado" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ZLow" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplEstrApoio" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="classificacaoPorte" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifAgropec" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="salinidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="posicaoPista" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="causa" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="denominacaoAssociada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="longitude_txt" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nrFaixas" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoConteudo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IdxOriginY" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoEspacial" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifRod" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoTrechoRod" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoEmAgua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tensaoEletrica" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoTerrExp" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifTurist" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="vaoLivreHoriz" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgEnsino" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DatasetSubtype1" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="velocidadeMedCorrente" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="XYTolerance" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="jurisdicao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SourceBeginGen" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoUsoEdif" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Type" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEstGerad" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DirtyArea_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="repTipoTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplRodovia" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DatasetSubtype2" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="pesoMaxSuportTon" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="causaExposicao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="HasM" ATTR_TYPE="yesno" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="FalseM" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDepAbast" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="potenciaFiscalizadaKW" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DestID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IdxOriginX" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OrigItemTypeID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizar" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Defaults" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matTransp" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdif" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoExposicao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DatasetInfo1" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="destEnergElet" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="indice" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoAreaUsoComun" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Shape" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="emDuto" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ReplicaID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="terreno" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplIndustria" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="denso" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="canteiroDivisorio" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifLazer" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="coincideComDentroDe" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="dentroDePoligono" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ShapeType" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCampo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoBanco" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoLimMassa" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="homologacao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="especie" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgAgrop" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="alturaEstimada" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="latitude" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoPonte" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="larguraMedia" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="BackwardLabel" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="codigoEstacao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="modalidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IsContainment" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoAgua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoPtoEnergia" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ExtentBottom" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="setor" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="qualidAgua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifComunic" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplEstMedFen" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MachineName" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="latitude_txt" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoElemNat" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDelimFis" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ZHigh" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplPubCivil" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SelectionID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TableName" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="valorVolume" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="construcao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoPista" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="profundidadeMedia" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="revestimento" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ovgd" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DirtyArea_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCampoQuadra" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ParentTypeID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="XYUnits" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OriginID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoAtracad" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDepSaneam" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="cota" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSvSoc" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCerr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="largura" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgRel" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="modalUso" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="periodicidadeInunda" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Name" ATTR_TYPE="text(160)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoLavoura" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Attributes" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ordemTickDepressao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="necessidadeManutencao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="religiao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="espacamentoIndividuos" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoPtoEstMed" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="espessuraDAP" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifRelig" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoTravessia" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="FalseZ" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDepGeral" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Shape_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ExtentLeft" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoSumVert" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Properties" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplComunic" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="unidadeVolume" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplAbsAgua" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="emMassaDagua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IdxGridSize" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ErrorCode" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="UserName" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplTrCurDagua" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orgaoEnteResp" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MTolerance" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplPortuario" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="eixoPrincipal" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplHabit" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoTrechoDuto" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IsHighPrecision" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoFonteDagua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoProdutoResiduo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEntroncamento" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ocorrenciaEm" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="velocidadeMedia" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="sigla" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Shape_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="PhysicalName" ATTR_TYPE="text(160)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="eletrificada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="regime" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplLazer" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="administracao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TargetName" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ZTolerance" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifSaneam" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="cultivoPredominante" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Event" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="caladoMax" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifAbast" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ForwardLabel" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="FalseY" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="codEstacao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSubEnEletr" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="FalseX" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Documentation" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="cotaComprovada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSet" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="chamine" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="compartilhado" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DestClassID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="extensao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Path" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="antropizada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="HasZ" ATTR_TYPE="yesno" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nascente" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplAeroport" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="posicaoRelativa" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="longitude" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="alturaMediaMargem" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplMilitar" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="usoPista" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IsException" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="LogDate" ATTR_TYPE="datetime" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgExtMin" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoClasseCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="navegabilidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="LockType" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="vaoVertical" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplGerEnEletr" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgComSv" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="UUID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoAlterAntrop" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TopoRuleID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="cotadaPorProcesso" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="columnFlags" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="usoPrincipal" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="depressao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nivelAtencao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SRID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="identificadorPosicGeo" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ObjectID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="trafego" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DestItemTypeID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="URL" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="codTrechoRodov" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifComercServ" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="materialPredominante" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Definition" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSaneam" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tratamento" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSaude" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="residuo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="posicaoRelEdific" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ensino" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="alturaMediaIndividuos" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MHigh" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="potenciaOutorgadaKW" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoMassaDagua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TopoRuleType" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="numCircuitos" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SourceEndGen" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="visivel" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="concessionaria" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="finalidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ItemInfo" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DatasetInfo2" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Dep_Abast_Agua_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="526"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="2924.51 -158.395"
#! BOUNDING_RECT="2924.51 -158.395 945.802 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_1"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgExtMin" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgComSv" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplIndustria" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="construcao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplAbsAgua" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="finalidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgAgrop" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoAgua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDepAbast" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Gruta_Caverna_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="584"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -18408.1"
#! BOUNDING_RECT="5799.68 -18408.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoElemNat" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Ponto_Duto_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="592"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -28344.1"
#! BOUNDING_RECT="5799.68 -28344.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="T_1_DirtyAreas_DirtyArea_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="604"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -10542.1"
#! BOUNDING_RECT="5799.68 -10542.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Delimitacao_Fisica"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="606"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -2262.05"
#! BOUNDING_RECT="5799.68 -2262.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDelimFis" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="eletrificada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Massa_Dagua"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="609"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -10128.1"
#! BOUNDING_RECT="5799.68 -10128.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="salinidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="regime" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoMassaDagua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="GDB_Items"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="612"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -12336.1"
#! BOUNDING_RECT="5799.68 -12336.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="ObjectID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="UUID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Type" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Name" ATTR_TYPE="text(160)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="PhysicalName" ATTR_TYPE="text(160)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Path" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DatasetSubtype1" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DatasetSubtype2" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DatasetInfo1" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DatasetInfo2" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="URL" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Definition" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Documentation" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ItemInfo" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Properties" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Defaults" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Shape" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Saude_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="613"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -19650.1"
#! BOUNDING_RECT="5799.68 -19650.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSaude" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoClasseCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nivelAtencao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Galeria_Bueiro_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="614"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -28758.1"
#! BOUNDING_RECT="5799.68 -28758.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Servico_Social_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="615"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -25308.1"
#! BOUNDING_RECT="5799.68 -25308.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Religiosa_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="616"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -13854.1"
#! BOUNDING_RECT="5799.68 -13854.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Ponte_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="619"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -13302.1"
#! BOUNDING_RECT="5799.68 -13302.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="largura" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="extensao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="vaoVertical" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="vaoLivreHoriz" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nrFaixas" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoPonte" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nrPistas" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="necessidadeManutencao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="modalUso" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="pesoMaxSuportTon" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="posicaoPista" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Cidade_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="620"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -8472.05"
#! BOUNDING_RECT="5799.68 -8472.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Trecho_Rodoviario"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="621"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -2124.05"
#! BOUNDING_RECT="5799.68 -2124.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="revestimento" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nrPistas" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="trafego" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSet" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="sigla" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="administracao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="velocidadeMedia" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nrFaixas" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="codTrechoRodov" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="concessionaria" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="canteiroDivisorio" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplRodovia" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoTrechoRod" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="pesoMaxSuportTon" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="jurisdicao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Trecho_Rodoviario_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="624"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -27378.1"
#! BOUNDING_RECT="5799.68 -27378.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Ext_Mineral_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="627"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -9990.05"
#! BOUNDING_RECT="5799.68 -9990.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgExtMin" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDivisaoCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Posto_Combustivel_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="628"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -12888.1"
#! BOUNDING_RECT="5799.68 -12888.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Ponto_Trecho_Energia_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="629"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -6264.05"
#! BOUNDING_RECT="5799.68 -6264.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Area_Industrial"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="630"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -13716.1"
#! BOUNDING_RECT="5799.68 -13716.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplIndustria" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Patio_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="631"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -11370.1"
#! BOUNDING_RECT="5799.68 -11370.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplAeroport" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplPortuario" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgRel" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplIndustria" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgEnsino" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="administracao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgComSv" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgExtMin" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="modalUso" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplLazer" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgAgrop" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplEstrApoio" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Rodoviaria_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="632"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -1986.05"
#! BOUNDING_RECT="5799.68 -1986.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifRod" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="administracao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplEstrApoio" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Campo_Quadra_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="633"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -16062.1"
#! BOUNDING_RECT="5799.68 -16062.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplLazer" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCampoQuadra" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Pto_Est_Med_Fenomenos_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="634"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -26274.1"
#! BOUNDING_RECT="5799.68 -26274.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Terreno_Suj_Inundacao_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="635"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -26550.1"
#! BOUNDING_RECT="5799.68 -26550.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Grupo_Transform_Energ_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="636"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -29448.1"
#! BOUNDING_RECT="5799.68 -29448.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSubEnEletr" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Patio_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="637"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -9300.05"
#! BOUNDING_RECT="5799.68 -9300.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Dep_Saneamento_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="638"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -4194.05"
#! BOUNDING_RECT="5799.68 -4194.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSaneam" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="residuo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="finalidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="construcao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDepSaneam" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoResiduo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Servico_Social_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="639"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -6678.05"
#! BOUNDING_RECT="5799.68 -6678.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoClasseCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSvSoc" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Servico_Social_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="640"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -4884.05"
#! BOUNDING_RECT="5799.68 -4884.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Ponto_Rodoviario_Ferrov"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="643"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -24480.1"
#! BOUNDING_RECT="5799.68 -24480.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="relacionado" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="modalUso" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Veg_Cultivada_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="646"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -7920.05"
#! BOUNDING_RECT="5799.68 -7920.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Identific_Trecho_Rod_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="649"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -8610.05"
#! BOUNDING_RECT="5799.68 -8610.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Ensino_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="654"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -8334.05"
#! BOUNDING_RECT="5799.68 -8334.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoClasseCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgEnsino" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Travessia_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="655"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -28620.1"
#! BOUNDING_RECT="5799.68 -28620.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoTravessia" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Cemiterio_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="656"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -5850.05"
#! BOUNDING_RECT="5799.68 -5850.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Ponto_Drenagem_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="659"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -23514.1"
#! BOUNDING_RECT="5799.68 -23514.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Ponto_Cotado_Altimetrico"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="660"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -7368.05"
#! BOUNDING_RECT="5799.68 -7368.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="cota" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="cotaComprovada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="visivel" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Dep_Abast_Agua_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="663"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -10680.1"
#! BOUNDING_RECT="5799.68 -10680.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Area_Lazer_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="664"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -29034.1"
#! BOUNDING_RECT="5799.68 -29034.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Torre_Comunic_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="667"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -14130.1"
#! BOUNDING_RECT="5799.68 -14130.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Aglomerado_Rural"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="668"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -21168.1"
#! BOUNDING_RECT="5799.68 -21168.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoAglomerado" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="identificadorPosicGeo" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizar" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="longitude" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="latitude" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="longitude_txt" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="latitude_txt" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Religiosa_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="669"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -23652.1"
#! BOUNDING_RECT="5799.68 -23652.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="religiao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgRel" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifRelig" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ensino" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Torre_Comunic"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="671"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -25860.1"
#! BOUNDING_RECT="5799.68 -25860.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="alturaEstimada" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ovgd" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplComunic" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="posicaoRelEdific" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Entroncamento_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="677"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -30138.1"
#! BOUNDING_RECT="5799.68 -30138.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Trecho_Energia_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="682"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 108.347"
#! BOUNDING_RECT="5799.68 108.347 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Barragem_line"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="685"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -5022.05"
#! BOUNDING_RECT="5799.68 -5022.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplGerEnEletr" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="usoPrincipal" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Campo"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="686"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -27240.1"
#! BOUNDING_RECT="5799.68 -27240.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ocorrenciaEm" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCampo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Rocha_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="689"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -330.046"
#! BOUNDING_RECT="5799.68 -330.046 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="GDB_ReplicaLog"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="690"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -14958.1"
#! BOUNDING_RECT="5799.68 -14958.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="ID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ReplicaID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Event" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ErrorCode" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="LogDate" ATTR_TYPE="datetime" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SourceBeginGen" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SourceEndGen" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TargetGen" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Cerrado_Cerradao"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="691"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -10956.1"
#! BOUNDING_RECT="5799.68 -10956.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="alturaMediaIndividuos" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="denso" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="classificacaoPorte" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="antropizada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCerr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Arruamento"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="692"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -3228.05"
#! BOUNDING_RECT="5799.68 -3228.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="revestimento" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nrFaixas" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="trafego" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="canteiroDivisorio" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Servico_Social_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="693"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -22548.1"
#! BOUNDING_RECT="5799.68 -22548.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoClasseCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSvSoc" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Saude_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="694"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -7506.05"
#! BOUNDING_RECT="5799.68 -7506.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Pub_Militar_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="695"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -7644.05"
#! BOUNDING_RECT="5799.68 -7644.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Const_Lazer_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="696"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -8886.05"
#! BOUNDING_RECT="5799.68 -8886.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Veg_Cultivada_SHAPE_Index00"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="697"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 263.569"
#! BOUNDING_RECT="5799.68 263.569 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ExtentRight" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OriginClassID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifAero" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nrPistas" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCemiterio" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="FieldName" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IsRetired" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MUnits" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MLow" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplDuto" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DirtyArea" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SRTEXT" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TargetGen" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoResiduo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoAglomerado" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="LockID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nrDutos" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ZUnits" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ExtentTop" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDivisaoCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="relacionado" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ZLow" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplEstrApoio" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="classificacaoPorte" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifAgropec" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="salinidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="posicaoPista" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="causa" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="denominacaoAssociada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="longitude_txt" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nrFaixas" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoConteudo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IdxOriginY" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoEspacial" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifRod" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoTrechoRod" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoEmAgua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tensaoEletrica" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoTerrExp" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifTurist" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="vaoLivreHoriz" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgEnsino" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DatasetSubtype1" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="velocidadeMedCorrente" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="XYTolerance" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="jurisdicao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SourceBeginGen" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoUsoEdif" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Type" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEstGerad" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DirtyArea_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="repTipoTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplRodovia" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DatasetSubtype2" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="pesoMaxSuportTon" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="causaExposicao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="HasM" ATTR_TYPE="yesno" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="FalseM" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDepAbast" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="potenciaFiscalizadaKW" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DestID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IdxOriginX" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OrigItemTypeID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizar" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Defaults" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matTransp" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdif" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoExposicao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DatasetInfo1" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="destEnergElet" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="indice" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoAreaUsoComun" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Shape" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="emDuto" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ReplicaID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="terreno" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplIndustria" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="denso" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="canteiroDivisorio" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifLazer" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="coincideComDentroDe" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="dentroDePoligono" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ShapeType" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCampo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoBanco" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoLimMassa" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="homologacao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="especie" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgAgrop" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="alturaEstimada" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="latitude" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoPonte" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="larguraMedia" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="BackwardLabel" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="codigoEstacao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="modalidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IsContainment" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoAgua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoPtoEnergia" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ExtentBottom" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="setor" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="qualidAgua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifComunic" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplEstMedFen" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MachineName" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="latitude_txt" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoElemNat" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDelimFis" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ZHigh" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplPubCivil" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SelectionID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TableName" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="valorVolume" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="construcao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoPista" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="profundidadeMedia" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="revestimento" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ovgd" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DirtyArea_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCampoQuadra" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ParentTypeID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="XYUnits" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OriginID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoAtracad" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDepSaneam" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="cota" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSvSoc" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCerr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="largura" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgRel" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="modalUso" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="periodicidadeInunda" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Name" ATTR_TYPE="text(160)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoLavoura" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Attributes" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ordemTickDepressao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="necessidadeManutencao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="religiao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="espacamentoIndividuos" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoPtoEstMed" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="espessuraDAP" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifRelig" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoTravessia" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="FalseZ" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDepGeral" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Shape_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ExtentLeft" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoSumVert" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Properties" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplComunic" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="unidadeVolume" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplAbsAgua" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="emMassaDagua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IdxGridSize" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ErrorCode" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="UserName" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplTrCurDagua" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orgaoEnteResp" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MTolerance" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplPortuario" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="eixoPrincipal" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplHabit" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoTrechoDuto" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IsHighPrecision" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoFonteDagua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoProdutoResiduo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEntroncamento" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ocorrenciaEm" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="velocidadeMedia" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="sigla" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Shape_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="PhysicalName" ATTR_TYPE="text(160)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="eletrificada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="regime" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplLazer" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="administracao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TargetName" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ZTolerance" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifSaneam" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="cultivoPredominante" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Event" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="caladoMax" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifAbast" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ForwardLabel" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="FalseY" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="codEstacao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSubEnEletr" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="FalseX" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Documentation" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="cotaComprovada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSet" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="chamine" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="compartilhado" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DestClassID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="extensao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Path" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="antropizada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="HasZ" ATTR_TYPE="yesno" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nascente" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplAeroport" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="posicaoRelativa" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="longitude" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="alturaMediaMargem" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplMilitar" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="usoPista" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IsException" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="LogDate" ATTR_TYPE="datetime" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgExtMin" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoClasseCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="navegabilidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="LockType" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="vaoVertical" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplGerEnEletr" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgComSv" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="UUID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoAlterAntrop" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TopoRuleID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="cotadaPorProcesso" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="columnFlags" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="usoPrincipal" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="depressao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nivelAtencao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SRID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="identificadorPosicGeo" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ObjectID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="trafego" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DestItemTypeID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="URL" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="codTrechoRodov" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifComercServ" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="materialPredominante" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Definition" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSaneam" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tratamento" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSaude" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="residuo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="posicaoRelEdific" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ensino" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="alturaMediaIndividuos" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MHigh" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="potenciaOutorgadaKW" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoMassaDagua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TopoRuleType" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="numCircuitos" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SourceEndGen" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="visivel" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="concessionaria" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="finalidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ItemInfo" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DatasetInfo2" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Arquibancada_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="698"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -29586.1"
#! BOUNDING_RECT="5799.68 -29586.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplLazer" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Deposito_Geral_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="701"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -15234.1"
#! BOUNDING_RECT="5799.68 -15234.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoExposicao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgExtMin" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplAeroport" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoProdutoResiduo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoConteudo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="valorVolume" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgComSv" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tratamento" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplIndustria" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplPortuario" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplGerEnEletr" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgAgrop" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDepGeral" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplEstrApoio" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="unidadeVolume" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Pto_Est_Med_Fenomenos"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="702"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -16338.1"
#! BOUNDING_RECT="5799.68 -16338.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="codEstacao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplEstMedFen" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orgaoEnteResp" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoPtoEstMed" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Area_Uso_Comunitario_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="705"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -606.046"
#! BOUNDING_RECT="5799.68 -606.046 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoAreaUsoComun" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Delimitacao_Fisica_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="706"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -17166.1"
#! BOUNDING_RECT="5799.68 -17166.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Ponte_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="707"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -20478.1"
#! BOUNDING_RECT="5799.68 -20478.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Const_Lazer_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="708"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -2676.05"
#! BOUNDING_RECT="5799.68 -2676.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Comerc_Serv_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="709"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -3366.05"
#! BOUNDING_RECT="5799.68 -3366.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Elemento_Fisiog_Natural_line"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="710"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -21306.1"
#! BOUNDING_RECT="5799.68 -21306.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoElemNat" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Area_Energia_Eletrica_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="711"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -6402.05"
#! BOUNDING_RECT="5799.68 -6402.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Area_Energia_Eletrica"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="714"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -18546.1"
#! BOUNDING_RECT="5799.68 -18546.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplGerEnEletr" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSubEnEletr" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Ensino_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="715"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -7230.05"
#! BOUNDING_RECT="5799.68 -7230.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Dep_Saneamento_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="718"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -19098.1"
#! BOUNDING_RECT="5799.68 -19098.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Const_Lazer_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="719"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -27516.1"
#! BOUNDING_RECT="5799.68 -27516.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifLazer" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplLazer" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Nome_Local"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="721"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -17028.1"
#! BOUNDING_RECT="5799.68 -17028.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Area_Uso_Comunitario_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="726"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -19236.1"
#! BOUNDING_RECT="5799.68 -19236.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Ilha_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="731"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -14820.1"
#! BOUNDING_RECT="5799.68 -14820.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoElemNat" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Comerc_Serv_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="732"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -11784.1"
#! BOUNDING_RECT="5799.68 -11784.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgComSv" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="finalidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifComercServ" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Deposito_Geral_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="733"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -1020.05"
#! BOUNDING_RECT="5799.68 -1020.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="T_1_LineErrors_Shape_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="734"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -30276.1"
#! BOUNDING_RECT="5799.68 -30276.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Pub_Civil_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="735"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -7782.05"
#! BOUNDING_RECT="5799.68 -7782.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplPubCivil" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdif" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoUsoEdif" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Comerc_Serv_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="736"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -13026.1"
#! BOUNDING_RECT="5799.68 -13026.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgComSv" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="finalidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifComercServ" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Constr_Est_Med_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="737"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -6816.05"
#! BOUNDING_RECT="5799.68 -6816.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="738"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -1710.05"
#! BOUNDING_RECT="5799.68 -1710.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Banco_Areia_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="739"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -29862.1"
#! BOUNDING_RECT="5799.68 -29862.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="materialPredominante" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoEmAgua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoBanco" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Ponto_Inicio_Drenagem"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="740"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -744.046"
#! BOUNDING_RECT="5799.68 -744.046 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nascente" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="T_1_PolyErrors_Shape_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="741"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -9576.05"
#! BOUNDING_RECT="5799.68 -9576.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="GDB_SpatialRefs"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="742"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -27654.1"
#! BOUNDING_RECT="5799.68 -27654.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="SRID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SRTEXT" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="FalseX" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="FalseY" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="XYUnits" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="FalseZ" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ZUnits" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="FalseM" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MUnits" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IsHighPrecision" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="XYTolerance" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ZTolerance" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MTolerance" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Pista_Ponto_Pouso_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="743"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -21444.1"
#! BOUNDING_RECT="5799.68 -21444.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="revestimento" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="homologacao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoPista" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplAeroport" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="largura" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="usoPista" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="extensao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Selections"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="744"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -11922.1"
#! BOUNDING_RECT="5799.68 -11922.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="SelectionID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TargetName" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Dep_Abast_Agua_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="745"
#! FEAT_GEOMTYPE="All"
#! POSITION="4311.96 -941.012"
#! BOUNDING_RECT="4311.96 -941.012 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="true"
#! ENABLED="true"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgExtMin" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgComSv" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplIndustria" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="construcao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplAbsAgua" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="finalidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgAgrop" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoAgua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDepAbast" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="UPDATE"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Limite_Massa_Dagua"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="746"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -14268.1"
#! BOUNDING_RECT="5799.68 -14268.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="materialPredominante" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoLimMassa" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="alturaMediaMargem" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Elemento_Fisiog_Natural_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="747"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -24894.1"
#! BOUNDING_RECT="5799.68 -24894.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Ponto_Duto"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="748"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -2400.05"
#! BOUNDING_RECT="5799.68 -2400.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="relacionado" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Ext_Mineral_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="749"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -15648.1"
#! BOUNDING_RECT="5799.68 -15648.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgExtMin" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDivisaoCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Dep_Saneamento_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="750"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -21858.1"
#! BOUNDING_RECT="5799.68 -21858.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Trecho_Massa_Dagua"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="753"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -10266.1"
#! BOUNDING_RECT="5799.68 -10266.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="salinidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="regime" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplTrCurDagua" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoMassaDagua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Cerrado_Cerradao_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="756"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -28896.1"
#! BOUNDING_RECT="5799.68 -28896.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="GDB_DatabaseLocks"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="761"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -8196.05"
#! BOUNDING_RECT="5799.68 -8196.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="LockID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="LockType" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="UserName" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MachineName" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Pub_Civil_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="764"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -24204.1"
#! BOUNDING_RECT="5799.68 -24204.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Area_Lazer"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="767"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -20064.1"
#! BOUNDING_RECT="5799.68 -20064.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplLazer" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Fonte_Dagua"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="772"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -21582.1"
#! BOUNDING_RECT="5799.68 -21582.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoFonteDagua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="regime" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="qualidAgua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Industrial_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="775"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -25998.1"
#! BOUNDING_RECT="5799.68 -25998.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Ensino_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="778"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -15372.1"
#! BOUNDING_RECT="5799.68 -15372.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="SelectedObjects"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="779"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -21996.1"
#! BOUNDING_RECT="5799.68 -21996.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="SelectionID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ObjectID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Pista_Competicao_line"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="780"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -16614.1"
#! BOUNDING_RECT="5799.68 -16614.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoPista" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplLazer" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Religiosa_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="785"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -18684.1"
#! BOUNDING_RECT="5799.68 -18684.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="religiao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgRel" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifRelig" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ensino" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Dep_Saneamento_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="790"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -11646.1"
#! BOUNDING_RECT="5799.68 -11646.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSaneam" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="residuo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="finalidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="construcao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDepSaneam" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoResiduo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Rodoviaria_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="793"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -14406.1"
#! BOUNDING_RECT="5799.68 -14406.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Const_Lazer_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="798"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -9024.05"
#! BOUNDING_RECT="5799.68 -9024.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifLazer" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplLazer" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="GDB_ItemRelationships"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="799"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -18270.1"
#! BOUNDING_RECT="5799.68 -18270.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="ObjectID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="UUID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OriginID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DestID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Type" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Attributes" ATTR_TYPE="memo" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Properties" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Trecho_Drenagem"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="804"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -192.046"
#! BOUNDING_RECT="5799.68 -192.046 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="dentroDePoligono" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="caladoMax" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="navegabilidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplTrCurDagua" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="compartilhado" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="larguraMedia" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="velocidadeMedCorrente" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="regime" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="profundidadeMedia" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="coincideComDentroDe" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="eixoPrincipal" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Arruamento_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="809"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -26412.1"
#! BOUNDING_RECT="5799.68 -26412.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Area_Ext_Mineral_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="814"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -24756.1"
#! BOUNDING_RECT="5799.68 -24756.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Pub_Civil_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="819"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -26826.1"
#! BOUNDING_RECT="5799.68 -26826.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Const_Turistica_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="822"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -3780.05"
#! BOUNDING_RECT="5799.68 -3780.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ovgd" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplLazer" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifTurist" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Trecho_Energia"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="827"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -3642.05"
#! BOUNDING_RECT="5799.68 -3642.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="especie" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="posicaoRelativa" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tensaoEletrica" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="numCircuitos" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="emDuto" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="GDB_ItemTypes"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="832"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -7092.05"
#! BOUNDING_RECT="5799.68 -7092.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="ObjectID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="UUID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ParentTypeID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Name" ATTR_TYPE="text(160)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Rodoviaria_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="833"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -13164.1"
#! BOUNDING_RECT="5799.68 -13164.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Trecho_Massa_Dagua_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="838"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -2538.05"
#! BOUNDING_RECT="5799.68 -2538.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Abast_Agua_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="839"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -18960.1"
#! BOUNDING_RECT="5799.68 -18960.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifAbast" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplAbsAgua" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Curva_Nivel"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="842"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -11094.1"
#! BOUNDING_RECT="5799.68 -11094.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="indice" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="depressao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="cota" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ordemTickDepressao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="emMassaDagua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="cotadaPorProcesso" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="T_1_PointErrors"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="843"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -30000.1"
#! BOUNDING_RECT="5799.68 -30000.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="ObjectID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OriginClassID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OriginID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DestClassID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DestID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TopoRuleType" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TopoRuleID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Shape" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IsException" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Area_Ext_Mineral"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="846"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -20892.1"
#! BOUNDING_RECT="5799.68 -20892.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgExtMin" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Cemiterio_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="847"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -6126.05"
#! BOUNDING_RECT="5799.68 -6126.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="denominacaoAssociada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCemiterio" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Industrial_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="848"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -16200.1"
#! BOUNDING_RECT="5799.68 -16200.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplIndustria" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="chamine" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDivisaoCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Sumidouro_Vertedouro"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="849"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -14544.1"
#! BOUNDING_RECT="5799.68 -14544.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoSumVert" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="causa" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Elemento_Fisiog_Natural_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="850"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -9852.05"
#! BOUNDING_RECT="5799.68 -9852.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoElemNat" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Confluencia"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="851"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -17718.1"
#! BOUNDING_RECT="5799.68 -17718.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="relacionado" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Limite_Massa_Dagua_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="852"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -17442.1"
#! BOUNDING_RECT="5799.68 -17442.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Industrial_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="853"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -18822.1"
#! BOUNDING_RECT="5799.68 -18822.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Pub_Militar_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="856"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -28482.1"
#! BOUNDING_RECT="5799.68 -28482.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplMilitar" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdif" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoUsoEdif" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Comporta_line_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="857"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -24618.1"
#! BOUNDING_RECT="5799.68 -24618.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Alter_Fisiog_Antropica_line"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="858"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -1572.05"
#! BOUNDING_RECT="5799.68 -1572.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSet" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoAlterAntrop" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Pista_Competicao_line_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="859"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -8748.05"
#! BOUNDING_RECT="5799.68 -8748.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Atracadouro_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="870"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -5712.05"
#! BOUNDING_RECT="5799.68 -5712.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Campo_Quadra_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="873"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -12750.1"
#! BOUNDING_RECT="5799.68 -12750.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplLazer" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCampoQuadra" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Rodoviaria_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="874"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -22410.1"
#! BOUNDING_RECT="5799.68 -22410.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifRod" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="administracao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplEstrApoio" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Saneamento_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="877"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -11232.1"
#! BOUNDING_RECT="5799.68 -11232.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSaneam" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifSaneam" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Ext_Mineral_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="880"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -17304.1"
#! BOUNDING_RECT="5799.68 -17304.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Rocha_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="881"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -1158.05"
#! BOUNDING_RECT="5799.68 -1158.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoElemNat" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Deposito_Geral_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="882"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -13992.1"
#! BOUNDING_RECT="5799.68 -13992.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Grupo_Transform_Energ_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="883"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -29724.1"
#! BOUNDING_RECT="5799.68 -29724.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Est_Gerad_Energia_Eletr_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="886"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -19926.1"
#! BOUNDING_RECT="5799.68 -19926.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Deposito_Geral_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="889"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -6954.05"
#! BOUNDING_RECT="5799.68 -6954.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoExposicao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgExtMin" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplAeroport" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoProdutoResiduo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoConteudo" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="valorVolume" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgComSv" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tratamento" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplIndustria" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplPortuario" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplGerEnEletr" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgAgrop" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDepGeral" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplEstrApoio" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="unidadeVolume" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Entroncamento"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="890"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -11508.1"
#! BOUNDING_RECT="5799.68 -11508.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEntroncamento" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Terreno_Exposto_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="891"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -26136.1"
#! BOUNDING_RECT="5799.68 -26136.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Campo_Quadra_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="892"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -25032.1"
#! BOUNDING_RECT="5799.68 -25032.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Comunic_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="893"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -17994.1"
#! BOUNDING_RECT="5799.68 -17994.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Terreno_Suj_Inundacao"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="896"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -22272.1"
#! BOUNDING_RECT="5799.68 -22272.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="periodicidadeInunda" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Industrial_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="897"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -23100.1"
#! BOUNDING_RECT="5799.68 -23100.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplIndustria" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="chamine" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDivisaoCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Comporta_line"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="898"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -9714.05"
#! BOUNDING_RECT="5799.68 -9714.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="GDB_GeomColumns"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="899"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -9162.05"
#! BOUNDING_RECT="5799.68 -9162.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="TableName" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="FieldName" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ShapeType" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ExtentLeft" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ExtentBottom" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ExtentRight" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ExtentTop" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IdxOriginX" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IdxOriginY" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IdxGridSize" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SRID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="HasZ" ATTR_TYPE="yesno" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="HasM" ATTR_TYPE="yesno" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ZLow" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ZHigh" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MLow" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MHigh" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Curva_Nivel_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="900"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -21720.1"
#! BOUNDING_RECT="5799.68 -21720.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Ponto_Rodoviario_Ferrov_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="901"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -17580.1"
#! BOUNDING_RECT="5799.68 -17580.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Area_Edificada_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="902"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -22134.1"
#! BOUNDING_RECT="5799.68 -22134.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Pub_Militar_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="903"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -3504.05"
#! BOUNDING_RECT="5799.68 -3504.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Abast_Agua_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="904"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -16890.1"
#! BOUNDING_RECT="5799.68 -16890.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Confluencia_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="905"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -28068.1"
#! BOUNDING_RECT="5799.68 -28068.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Pub_Militar_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="906"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -14682.1"
#! BOUNDING_RECT="5799.68 -14682.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplMilitar" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdif" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoUsoEdif" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Caatinga"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="907"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -4056.05"
#! BOUNDING_RECT="5799.68 -4056.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="alturaMediaIndividuos" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="classificacaoPorte" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="denso" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="antropizada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Religiosa_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="910"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -25446.1"
#! BOUNDING_RECT="5799.68 -25446.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Gruta_Caverna_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="911"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -16476.1"
#! BOUNDING_RECT="5799.68 -16476.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Ponto_Inicio_Drenagem_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="912"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -23376.1"
#! BOUNDING_RECT="5799.68 -23376.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Saude_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="915"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -19374.1"
#! BOUNDING_RECT="5799.68 -19374.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplSaude" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoClasseCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nivelAtencao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Comunic_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="916"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -18132.1"
#! BOUNDING_RECT="5799.68 -18132.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifComunic" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="modalidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplComunic" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Arquibancada_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="917"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -4470.05"
#! BOUNDING_RECT="5799.68 -4470.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Atracadouro_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="918"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -12474.1"
#! BOUNDING_RECT="5799.68 -12474.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Aglomerado_Rural_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="919"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -24066.1"
#! BOUNDING_RECT="5799.68 -24066.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="GDB_Items_Shape_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="920"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -29172.1"
#! BOUNDING_RECT="5799.68 -29172.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Trecho_Drenagem_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="921"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -26688.1"
#! BOUNDING_RECT="5799.68 -26688.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Antena_Comunic_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="922"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -20616.1"
#! BOUNDING_RECT="5799.68 -20616.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="T_1_DirtyAreas"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="923"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -5574.05"
#! BOUNDING_RECT="5799.68 -5574.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="ObjectID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IsRetired" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DirtyArea" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DirtyArea_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DirtyArea_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Area_Edificada"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="924"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -22686.1"
#! BOUNDING_RECT="5799.68 -22686.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Elemento_Fisiog_Natural_line_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="925"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -22962.1"
#! BOUNDING_RECT="5799.68 -22962.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Cidade"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="926"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -28206.1"
#! BOUNDING_RECT="5799.68 -28206.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="identificadorPosicGeo" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizar" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="longitude" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="latitude" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="longitude_txt" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="latitude_txt" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Banco_Areia_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="927"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -24342.1"
#! BOUNDING_RECT="5799.68 -24342.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Trecho_Duto"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="928"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -20340.1"
#! BOUNDING_RECT="5799.68 -20340.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoTrechoDuto" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="setor" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="posicaoRelativa" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoEspacial" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplDuto" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nrDutos" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matTransp" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Massa_Dagua_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="929"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -21030.1"
#! BOUNDING_RECT="5799.68 -21030.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Fonte_Dagua_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="930"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -27792.1"
#! BOUNDING_RECT="5799.68 -27792.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Ilha_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="931"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -25584.1"
#! BOUNDING_RECT="5799.68 -25584.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Veg_Cultivada"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="932"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -8058.05"
#! BOUNDING_RECT="5799.68 -8058.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoLavoura" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="denso" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="espessuraDAP" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="classificacaoPorte" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="cultivoPredominante" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="alturaMediaIndividuos" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="terreno" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="espacamentoIndividuos" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="finalidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Atracadouro_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="933"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -1848.05"
#! BOUNDING_RECT="5799.68 -1848.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplPortuario" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="administracao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoAtracad" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Habitacional_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="934"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -16752.1"
#! BOUNDING_RECT="5799.68 -16752.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Antena_Comunic"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="935"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -2814.05"
#! BOUNDING_RECT="5799.68 -2814.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplComunic" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="posicaoRelEdific" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Const_Aeroportuaria_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="936"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -5298.05"
#! BOUNDING_RECT="5799.68 -5298.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Galeria_Bueiro_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="937"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -15096.1"
#! BOUNDING_RECT="5799.68 -15096.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="pesoMaxSuportTon" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Trilha_Picada_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="938"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -4746.05"
#! BOUNDING_RECT="5799.68 -4746.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Est_Gerad_Energia_Eletr_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="939"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -23928.1"
#! BOUNDING_RECT="5799.68 -23928.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEstGerad" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="potenciaFiscalizadaKW" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplGerEnEletr" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="codigoEstacao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="destEnergElet" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="potenciaOutorgadaKW" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Travessia_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="942"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -468.046"
#! BOUNDING_RECT="5799.68 -468.046 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Terreno_Exposto"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="943"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -27930.1"
#! BOUNDING_RECT="5799.68 -27930.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoTerrExp" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="causaExposicao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Cemiterio_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="944"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -23238.1"
#! BOUNDING_RECT="5799.68 -23238.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Trecho_Duto_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="947"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -9438.05"
#! BOUNDING_RECT="5799.68 -9438.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Sumidouro_Vertedouro_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="950"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -6540.05"
#! BOUNDING_RECT="5799.68 -6540.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Const_Turistica_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="951"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -5436.05"
#! BOUNDING_RECT="5799.68 -5436.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="T_1_PointErrors_Shape_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="952"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -29310.1"
#! BOUNDING_RECT="5799.68 -29310.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Saude_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="955"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -882.046"
#! BOUNDING_RECT="5799.68 -882.046 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Nome_Local_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="958"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -12060.1"
#! BOUNDING_RECT="5799.68 -12060.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Ext_Mineral_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="959"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -4608.05"
#! BOUNDING_RECT="5799.68 -4608.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Habitacional_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="962"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -5160.05"
#! BOUNDING_RECT="5799.68 -5160.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplHabit" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Const_Aeroportuaria_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="965"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -13578.1"
#! BOUNDING_RECT="5799.68 -13578.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplAeroport" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifAero" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="administracao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="GDB_ItemRelationshipTypes"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="966"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -10404.1"
#! BOUNDING_RECT="5799.68 -10404.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="ObjectID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="UUID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OrigItemTypeID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DestItemTypeID" ATTR_TYPE="replicationid" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Name" ATTR_TYPE="text(160)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="ForwardLabel" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="BackwardLabel" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IsContainment" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Pista_Ponto_Pouso_polygon_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="967"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -25170.1"
#! BOUNDING_RECT="5799.68 -25170.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Ponto_Drenagem"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="970"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -25722.1"
#! BOUNDING_RECT="5799.68 -25722.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="relacionado" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="T_1_LineErrors"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="973"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -15924.1"
#! BOUNDING_RECT="5799.68 -15924.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="ObjectID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OriginClassID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OriginID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DestClassID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DestID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TopoRuleType" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TopoRuleID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Shape" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IsException" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Shape_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Campo_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="976"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -1296.05"
#! BOUNDING_RECT="5799.68 -1296.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Caatinga_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="977"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -5988.05"
#! BOUNDING_RECT="5799.68 -5988.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Ponto_Trecho_Energia"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="980"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -10818.1"
#! BOUNDING_RECT="5799.68 -10818.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoPtoEnergia" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Ponto_Cotado_Altimetrico_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="981"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -23790.1"
#! BOUNDING_RECT="5799.68 -23790.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Trilha_Picada"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="982"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -13440.1"
#! BOUNDING_RECT="5799.68 -13440.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Comerc_Serv_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="983"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -15510.1"
#! BOUNDING_RECT="5799.68 -15510.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Campo_Quadra_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="986"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -1434.05"
#! BOUNDING_RECT="5799.68 -1434.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Alter_Fisiog_Antropica_line_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="987"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -15786.1"
#! BOUNDING_RECT="5799.68 -15786.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="GDB_ColumnInfo"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="988"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -22824.1"
#! BOUNDING_RECT="5799.68 -22824.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="TableName" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="FieldName" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="columnFlags" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Atracadouro_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="989"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -20202.1"
#! BOUNDING_RECT="5799.68 -20202.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplPortuario" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="administracao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoAtracad" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Constr_Est_Med_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="990"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -12612.1"
#! BOUNDING_RECT="5799.68 -12612.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplEstMedFen" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Saneamento_point_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="991"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -27102.1"
#! BOUNDING_RECT="5799.68 -27102.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Area_Industrial_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="992"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -19512.1"
#! BOUNDING_RECT="5799.68 -19512.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Cemiterio_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="993"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -3918.05"
#! BOUNDING_RECT="5799.68 -3918.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="denominacaoAssociada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoCemiterio" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Agrop_Ext_Veg_Pesca_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="994"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -20754.1"
#! BOUNDING_RECT="5799.68 -20754.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgAgrop" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdifAgropec" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tamanhoTxt" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Identific_Trecho_Rod"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="997"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -4332.05"
#! BOUNDING_RECT="5799.68 -4332.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplRodovia" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizar" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSet" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="sigla" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="repTipoTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="codTrechoRodov" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Ensino_polygon"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="1000"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -26964.1"
#! BOUNDING_RECT="5799.68 -26964.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoClasseCnae" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgEnsino" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Barragem_line_SHAPE_Index"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="1001"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -3090.05"
#! BOUNDING_RECT="5799.68 -3090.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="IndexedObjectId" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MinGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGX" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="MaxGY" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Posto_Combustivel_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="1002"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -17856.1"
#! BOUNDING_RECT="5799.68 -17856.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="administracao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplEstrApoio" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="T_1_PolyErrors"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="1003"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -2952.05"
#! BOUNDING_RECT="5799.68 -2952.05 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="ObjectID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OriginClassID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="OriginID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DestClassID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="DestID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TopoRuleType" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="TopoRuleID" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Shape" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="IsException" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Shape_Length" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="Shape_Area" ATTR_TYPE="double" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="false"
#! NODE_NAME="Edif_Pub_Civil_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="true"
#! IDENTIFIER="1004"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="5799.68 -12198.1"
#! BOUNDING_RECT="5799.68 -12198.1 817.078 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_4"
#! PARMS_EDITED="false"
#! ENABLED="false"
#! SCHEMA_ATTRIBUTE_SOURCE="1"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplPubCivil" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoEdif" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoUsoEdif" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="integer" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_update_key_columns" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_truncate_table" PARM_VALUE="NO"/>
#! <DEFLINE_PARM PARM_NAME="mdb_table_writer_mode" PARM_VALUE="INHERIT_FROM_WRITER"/>
#! <DEFLINE_PARM PARM_NAME="mdb_drop_table" PARM_VALUE="NO"/>
#! </FEATURE_TYPE>
#! <FEATURE_TYPE
#! IS_SOURCE="true"
#! NODE_NAME="Dep_Abast_Agua_point"
#! FEATURE_TYPE_NAME=""
#! FEATURE_TYPE_NAME_QUALIFIER=""
#! IS_EDITABLE="false"
#! IDENTIFIER="1007"
#! FEAT_GEOMTYPE="db_none"
#! POSITION="3870.22 159.22"
#! BOUNDING_RECT="3870.22 159.22 670.366 71"
#! ORDER="5e+014"
#! COLLAPSED="true"
#! KEYWORD="MDB_ADO_5"
#! PARMS_EDITED="false"
#! ENABLED="true"
#! HIDDEN_USER_ATTRS=""
#! MERGE_FILTER=""
#! MERGE_FILTER_TYPE="FILTER_TYPE_GLOB"
#! MERGE_FILTER_CASE_SENSITIVE="true"
#! DYNAMIC_SCHEMA="false"
#! >
#! <FEAT_ATTRIBUTE ATTR_NAME="OBJECTID" ATTR_TYPE="autonumber" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="SHAPE" ATTR_TYPE="oleobject" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="simbolizarCartaMini" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="justTxt" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgExtMin" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgComSv" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplIndustria" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controleId" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="construcao" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplAbsAgua" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="orientacao" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nomeAbrev" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="finalidade" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbY" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkComplOrgAgrop" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="escalaMaxSimbolizar" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="fkClassificador" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="operacional" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="geometriaAproximada" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="obsAquisicao" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoFisica" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="situacaoAgua" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="tipoDepAbast" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="nome" ATTR_TYPE="text(255)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="offSetSimbX" ATTR_TYPE="single" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="matConstr" ATTR_TYPE="long" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <FEAT_ATTRIBUTE ATTR_NAME="controle_id" ATTR_TYPE="text(200)" ATTR_HAS_PORT="true" ATTR_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_where_clause" PARM_VALUE=""/>
#! <DEFLINE_PARM PARM_NAME="mdb_sql_statement" PARM_VALUE=""/>
#! </FEATURE_TYPE>
#! </FEATURE_TYPES>
#! <FMESERVER>
#! </FMESERVER>
#! <GLOBAL_PARAMETERS>
#! <GLOBAL_PARAMETER
#! GUI_LINE="GUI MULTIFILE SourceDataset_MDB_ADO Access_Database_Files(*.mdb;*.accdb)|*.mdb;*.accdb|All_files(*)|* Source Microsoft Access Database File(s):"
#! DEFAULT_VALUE="$(FME_MF_DIR)mdb\b_sirgas_utm.mdb"
#! IS_STAND_ALONE="false"
#! />
#! <GLOBAL_PARAMETER
#! GUI_LINE="GUI MULTIFILE SourceDataset_MDB_ADO_3 Access_Database_Files(*.mdb;*.accdb)|*.mdb;*.accdb|All_files(*)|* Source Microsoft Access Database File(s):"
#! DEFAULT_VALUE="$(FME_MF_DIR)mdb\b_sirgas_utm.mdb"
#! IS_STAND_ALONE="false"
#! />
#! <GLOBAL_PARAMETER
#! GUI_LINE="GUI OPTIONAL FEATURE_TYPES FEATURE_TYPES &quot;C:&lt;backslash&gt;Marcos_Batista&lt;backslash&gt;FME&lt;backslash&gt;mdb&lt;backslash&gt;b_sirgas_utm.mdb,_FORMAT_OVERRIDE_,MDB_ADO,_DATASET_OVERRIDE_,SourceDataset_MDB_ADO_3,EXPOSE_ATTRS_GROUP,FME_DISCLOSURE_CLOSED,READ_CACHE_SIZE,10,QUERY_FEATURE_TYPES_FOR_MERGE_FILTERS,Yes,DYNAMIC_WORKFLOW,yes,_MERGE_SCHEMAS,YES,TABLELIST,\&quot;Aglomerado_Rural Aglomerado_Rural_SHAPE_Index Alter_Fisiog_Antropica_line Alter_Fisiog_Antropica_line_SHAPE_Index Antena_Comunic Antena_Comunic_SHAPE_Index Area_Edificada Area_Edificada_SHAPE_Index Area_Energia_Eletrica Area_Energia_Eletrica_SHAPE_Index Area_Ext_Mineral Area_Ext_Mineral_SHAPE_Index Area_Industrial Area_Industrial_SHAPE_Index Area_Lazer Area_Lazer_SHAPE_Index Area_Uso_Comunitario_point Area_Uso_Comunitario_point_SHAPE_Index Arquibancada_point Arquibancada_point_SHAPE_Index Arruamento Arruamento_SHAPE_Index Atracadouro_point Atracadouro_point_SHAPE_Index Atracadouro_polygon Atracadouro_polygon_SHAPE_Index Banco_Areia_polygon Banco_Areia_polygon_SHAPE_Index Barragem_line Barragem_line_SHAPE_Index Caatinga Caatinga_SHAPE_Index Campo Campo_Quadra_point Campo_Quadra_point_SHAPE_Index Campo_Quadra_polygon Campo_Quadra_polygon_SHAPE_Index Campo_SHAPE_Index Cemiterio_point Cemiterio_point_SHAPE_Index Cemiterio_polygon Cemiterio_polygon_SHAPE_Index Cerrado_Cerradao Cerrado_Cerradao_SHAPE_Index Cidade Cidade_SHAPE_Index Comporta_line Comporta_line_SHAPE_Index Confluencia Confluencia_SHAPE_Index Curva_Nivel Curva_Nivel_SHAPE_Index Delimitacao_Fisica Delimitacao_Fisica_SHAPE_Index Dep_Abast_Agua_point Dep_Abast_Agua_point_SHAPE_Index Dep_Saneamento_point Dep_Saneamento_point_SHAPE_Index Dep_Saneamento_polygon Dep_Saneamento_polygon_SHAPE_Index Deposito_Geral_point Deposito_Geral_point_SHAPE_Index Deposito_Geral_polygon Deposito_Geral_polygon_SHAPE_Index Edif_Abast_Agua_point Edif_Abast_Agua_point_SHAPE_Index Edif_Agrop_Ext_Veg_Pesca_point Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index Edif_Comerc_Serv_point Edif_Comerc_Serv_point_SHAPE_Index Edif_Comerc_Serv_polygon Edif_Comerc_Serv_polygon_SHAPE_Index Edif_Comunic_point Edif_Comunic_point_SHAPE_Index Edif_Const_Aeroportuaria_point Edif_Const_Aeroportuaria_point_SHAPE_Index Edif_Const_Lazer_point Edif_Const_Lazer_point_SHAPE_Index Edif_Const_Lazer_polygon Edif_Const_Lazer_polygon_SHAPE_Index Edif_Const_Turistica_point Edif_Const_Turistica_point_SHAPE_Index Edif_Constr_Est_Med_point Edif_Constr_Est_Med_point_SHAPE_Index Edif_Ensino_point Edif_Ensino_point_SHAPE_Index Edif_Ensino_polygon Edif_Ensino_polygon_SHAPE_Index Edif_Ext_Mineral_point Edif_Ext_Mineral_point_SHAPE_Index Edif_Ext_Mineral_polygon Edif_Ext_Mineral_polygon_SHAPE_Index Edif_Habitacional_point Edif_Habitacional_point_SHAPE_Index Edif_Industrial_point Edif_Industrial_point_SHAPE_Index Edif_Industrial_polygon Edif_Industrial_polygon_SHAPE_Index Edif_Pub_Civil_point Edif_Pub_Civil_point_SHAPE_Index Edif_Pub_Civil_polygon Edif_Pub_Civil_polygon_SHAPE_Index Edif_Pub_Militar_point Edif_Pub_Militar_point_SHAPE_Index Edif_Pub_Militar_polygon Edif_Pub_Militar_polygon_SHAPE_Index Edif_Religiosa_point Edif_Religiosa_point_SHAPE_Index Edif_Religiosa_polygon Edif_Religiosa_polygon_SHAPE_Index Edif_Rodoviaria_point Edif_Rodoviaria_point_SHAPE_Index Edif_Rodoviaria_polygon Edif_Rodoviaria_polygon_SHAPE_Index Edif_Saneamento_point Edif_Saneamento_point_SHAPE_Index Edif_Saude_point Edif_Saude_point_SHAPE_Index Edif_Saude_polygon Edif_Saude_polygon_SHAPE_Index Edif_Servico_Social_point Edif_Servico_Social_point_SHAPE_Index Edif_Servico_Social_polygon Edif_Servico_Social_polygon_SHAPE_Index Elemento_Fisiog_Natural_line Elemento_Fisiog_Natural_line_SHAPE_Index Elemento_Fisiog_Natural_point Elemento_Fisiog_Natural_point_SHAPE_Index Entroncamento Entroncamento_SHAPE_Index Est_Gerad_Energia_Eletr_polygon Est_Gerad_Energia_Eletr_polygon_SHAPE_Index Fonte_Dagua Fonte_Dagua_SHAPE_Index Galeria_Bueiro_point Galeria_Bueiro_point_SHAPE_Index GDB_ColumnInfo GDB_DatabaseLocks GDB_GeomColumns GDB_ItemRelationships GDB_ItemRelationshipTypes GDB_Items GDB_Items_Shape_Index GDB_ItemTypes GDB_ReplicaLog GDB_SpatialRefs Grupo_Transform_Energ_point Grupo_Transform_Energ_point_SHAPE_Index Gruta_Caverna_point Gruta_Caverna_point_SHAPE_Index Identific_Trecho_Rod Identific_Trecho_Rod_SHAPE_Index Ilha_polygon Ilha_polygon_SHAPE_Index Limite_Massa_Dagua Limite_Massa_Dagua_SHAPE_Index Massa_Dagua Massa_Dagua_SHAPE_Index Nome_Local Nome_Local_SHAPE_Index Patio_polygon Patio_polygon_SHAPE_Index Pista_Competicao_line Pista_Competicao_line_SHAPE_Index Pista_Ponto_Pouso_polygon Pista_Ponto_Pouso_polygon_SHAPE_Index Ponte_point Ponte_point_SHAPE_Index Ponto_Cotado_Altimetrico Ponto_Cotado_Altimetrico_SHAPE_Index Ponto_Drenagem Ponto_Drenagem_SHAPE_Index Ponto_Duto Ponto_Duto_SHAPE_Index Ponto_Inicio_Drenagem Ponto_Inicio_Drenagem_SHAPE_Index Ponto_Rodoviario_Ferrov Ponto_Rodoviario_Ferrov_SHAPE_Index Ponto_Trecho_Energia Ponto_Trecho_Energia_SHAPE_Index Posto_Combustivel_point Posto_Combustivel_point_SHAPE_Index Pto_Est_Med_Fenomenos Pto_Est_Med_Fenomenos_SHAPE_Index Rocha_polygon Rocha_polygon_SHAPE_Index SelectedObjects Selections Sumidouro_Vertedouro Sumidouro_Vertedouro_SHAPE_Index T_1_DirtyAreas T_1_DirtyAreas_DirtyArea_Index T_1_LineErrors T_1_LineErrors_Shape_Index T_1_PointErrors T_1_PointErrors_Shape_Index T_1_PolyErrors T_1_PolyErrors_Shape_Index Terreno_Exposto Terreno_Exposto_SHAPE_Index Terreno_Suj_Inundacao Terreno_Suj_Inundacao_SHAPE_Index Torre_Comunic Torre_Comunic_SHAPE_Index Travessia_point Travessia_point_SHAPE_Index Trecho_Drenagem Trecho_Drenagem_SHAPE_Index Trecho_Duto Trecho_Duto_SHAPE_Index Trecho_Energia Trecho_Energia_SHAPE_Index Trecho_Massa_Dagua Trecho_Massa_Dagua_SHAPE_Index Trecho_Rodoviario Trecho_Rodoviario_SHAPE_Index Trilha_Picada Trilha_Picada_SHAPE_Index Veg_Cultivada Veg_Cultivada_SHAPE_Index\&quot;,_MERGE_SCHEMAS,YES&quot; Feature Types to Read:"
#! DEFAULT_VALUE="Veg_Cultivada_SHAPE_Index Veg_Cultivada Trilha_Picada_SHAPE_Index Trilha_Picada Trecho_Rodoviario_SHAPE_Index Trecho_Rodoviario Trecho_Massa_Dagua_SHAPE_Index Trecho_Massa_Dagua Trecho_Energia_SHAPE_Index Trecho_Energia Trecho_Duto_SHAPE_Index Trecho_Duto Trecho_Drenagem_SHAPE_Index Trecho_Drenagem Travessia_point_SHAPE_Index Travessia_point Torre_Comunic_SHAPE_Index Torre_Comunic Terreno_Suj_Inundacao_SHAPE_Index Terreno_Suj_Inundacao Terreno_Exposto_SHAPE_Index Terreno_Exposto T_1_PolyErrors_Shape_Index T_1_PolyErrors T_1_PointErrors_Shape_Index T_1_PointErrors T_1_LineErrors_Shape_Index T_1_LineErrors T_1_DirtyAreas_DirtyArea_Index T_1_DirtyAreas Sumidouro_Vertedouro_SHAPE_Index Sumidouro_Vertedouro Selections SelectedObjects Rocha_polygon_SHAPE_Index Rocha_polygon Pto_Est_Med_Fenomenos_SHAPE_Index Pto_Est_Med_Fenomenos Posto_Combustivel_point_SHAPE_Index Posto_Combustivel_point Ponto_Trecho_Energia_SHAPE_Index Ponto_Trecho_Energia Ponto_Rodoviario_Ferrov_SHAPE_Index Ponto_Rodoviario_Ferrov Ponto_Inicio_Drenagem_SHAPE_Index Ponto_Inicio_Drenagem Ponto_Duto_SHAPE_Index Ponto_Duto Ponto_Drenagem_SHAPE_Index Ponto_Drenagem Ponto_Cotado_Altimetrico_SHAPE_Index Ponto_Cotado_Altimetrico Ponte_point_SHAPE_Index Ponte_point Pista_Ponto_Pouso_polygon_SHAPE_Index Pista_Ponto_Pouso_polygon Pista_Competicao_line_SHAPE_Index Pista_Competicao_line Patio_polygon_SHAPE_Index Patio_polygon Nome_Local_SHAPE_Index Nome_Local Massa_Dagua_SHAPE_Index Massa_Dagua Limite_Massa_Dagua_SHAPE_Index Limite_Massa_Dagua Ilha_polygon_SHAPE_Index Ilha_polygon Identific_Trecho_Rod_SHAPE_Index Identific_Trecho_Rod Gruta_Caverna_point_SHAPE_Index Gruta_Caverna_point Grupo_Transform_Energ_point_SHAPE_Index Grupo_Transform_Energ_point GDB_SpatialRefs GDB_ReplicaLog GDB_ItemTypes GDB_Items_Shape_Index GDB_Items GDB_ItemRelationshipTypes GDB_ItemRelationships GDB_GeomColumns GDB_DatabaseLocks GDB_ColumnInfo Galeria_Bueiro_point_SHAPE_Index Galeria_Bueiro_point Fonte_Dagua_SHAPE_Index Fonte_Dagua Est_Gerad_Energia_Eletr_polygon_SHAPE_Index Est_Gerad_Energia_Eletr_polygon Entroncamento_SHAPE_Index Entroncamento Elemento_Fisiog_Natural_point_SHAPE_Index Elemento_Fisiog_Natural_point Elemento_Fisiog_Natural_line_SHAPE_Index Elemento_Fisiog_Natural_line Edif_Servico_Social_polygon_SHAPE_Index Edif_Servico_Social_polygon Edif_Servico_Social_point_SHAPE_Index Edif_Servico_Social_point Edif_Saude_polygon_SHAPE_Index Edif_Saude_polygon Edif_Saude_point_SHAPE_Index Edif_Saude_point Edif_Saneamento_point_SHAPE_Index Edif_Saneamento_point Edif_Rodoviaria_polygon_SHAPE_Index Edif_Rodoviaria_polygon Edif_Rodoviaria_point_SHAPE_Index Edif_Rodoviaria_point Edif_Religiosa_polygon_SHAPE_Index Edif_Religiosa_polygon Edif_Religiosa_point_SHAPE_Index Edif_Religiosa_point Edif_Pub_Militar_polygon_SHAPE_Index Edif_Pub_Militar_polygon Edif_Pub_Militar_point_SHAPE_Index Edif_Pub_Militar_point Edif_Pub_Civil_polygon_SHAPE_Index Edif_Pub_Civil_polygon Edif_Pub_Civil_point_SHAPE_Index Edif_Pub_Civil_point Edif_Industrial_polygon_SHAPE_Index Edif_Industrial_polygon Edif_Industrial_point_SHAPE_Index Edif_Industrial_point Edif_Habitacional_point_SHAPE_Index Edif_Habitacional_point Edif_Ext_Mineral_polygon_SHAPE_Index Edif_Ext_Mineral_polygon Edif_Ext_Mineral_point_SHAPE_Index Edif_Ext_Mineral_point Edif_Ensino_polygon_SHAPE_Index Edif_Ensino_polygon Edif_Ensino_point_SHAPE_Index Edif_Ensino_point Edif_Constr_Est_Med_point_SHAPE_Index Edif_Constr_Est_Med_point Edif_Const_Turistica_point_SHAPE_Index Edif_Const_Turistica_point Edif_Const_Lazer_polygon_SHAPE_Index Edif_Const_Lazer_polygon Edif_Const_Lazer_point_SHAPE_Index Edif_Const_Lazer_point Edif_Const_Aeroportuaria_point_SHAPE_Index Edif_Const_Aeroportuaria_point Edif_Comunic_point_SHAPE_Index Edif_Comunic_point Edif_Comerc_Serv_polygon_SHAPE_Index Edif_Comerc_Serv_polygon Edif_Comerc_Serv_point_SHAPE_Index Edif_Comerc_Serv_point Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index Edif_Agrop_Ext_Veg_Pesca_point Edif_Abast_Agua_point_SHAPE_Index Edif_Abast_Agua_point Deposito_Geral_polygon_SHAPE_Index Deposito_Geral_polygon Deposito_Geral_point_SHAPE_Index Deposito_Geral_point Dep_Saneamento_polygon_SHAPE_Index Dep_Saneamento_polygon Dep_Saneamento_point_SHAPE_Index Dep_Saneamento_point Dep_Abast_Agua_point_SHAPE_Index Dep_Abast_Agua_point Delimitacao_Fisica_SHAPE_Index Delimitacao_Fisica Curva_Nivel_SHAPE_Index Curva_Nivel Confluencia_SHAPE_Index Confluencia Comporta_line_SHAPE_Index Comporta_line Cidade_SHAPE_Index Cidade Cerrado_Cerradao_SHAPE_Index Cerrado_Cerradao Cemiterio_polygon_SHAPE_Index Cemiterio_polygon Cemiterio_point_SHAPE_Index Cemiterio_point Campo_SHAPE_Index Campo_Quadra_polygon_SHAPE_Index Campo_Quadra_polygon Campo_Quadra_point_SHAPE_Index Campo_Quadra_point Campo Caatinga_SHAPE_Index Caatinga Barragem_line_SHAPE_Index Barragem_line Banco_Areia_polygon_SHAPE_Index Banco_Areia_polygon Atracadouro_polygon_SHAPE_Index Atracadouro_polygon Atracadouro_point_SHAPE_Index Atracadouro_point Arruamento_SHAPE_Index Arruamento Arquibancada_point_SHAPE_Index Arquibancada_point Area_Uso_Comunitario_point_SHAPE_Index Area_Uso_Comunitario_point Area_Lazer_SHAPE_Index Area_Lazer Area_Industrial_SHAPE_Index Area_Industrial Area_Ext_Mineral_SHAPE_Index Area_Ext_Mineral Area_Energia_Eletrica_SHAPE_Index Area_Energia_Eletrica Area_Edificada_SHAPE_Index Area_Edificada Antena_Comunic_SHAPE_Index Antena_Comunic Alter_Fisiog_Antropica_line_SHAPE_Index Alter_Fisiog_Antropica_line Aglomerado_Rural_SHAPE_Index Aglomerado_Rural"
#! IS_STAND_ALONE="false"
#! />
#! <GLOBAL_PARAMETER
#! GUI_LINE="GUI FILENAME DestDataset_MDB_ADO Access_Database_Files(*.mdb;*.accdb)|*.mdb;*.accdb|All_files(*)|* Destination Microsoft Access Database File:"
#! DEFAULT_VALUE="$(FME_MF_DIR)mdb\b_sirgas_utm_nomeAbrev.mdb"
#! IS_STAND_ALONE="false"
#! />
#! <GLOBAL_PARAMETER
#! GUI_LINE="GUI FILENAME DestDataset_MDB_ADO_2 Access_Database_Files(*.mdb;*.accdb)|*.mdb;*.accdb|All_files(*)|* Destination Microsoft Access Database File:"
#! DEFAULT_VALUE="$(FME_MF_DIR)mdb\b_sirgas_utm_nomeAbrev.mdb"
#! IS_STAND_ALONE="false"
#! />
#! <GLOBAL_PARAMETER
#! GUI_LINE="GUI MULTIFILE SourceDataset_MDB_ADO_4 Access_Database_Files(*.mdb;*.accdb)|*.mdb;*.accdb|All_files(*)|* Source Microsoft Access Database File(s):"
#! DEFAULT_VALUE="$(FME_MF_DIR)mdb\b_sirgas_utm_NOMEABREV.mdb"
#! IS_STAND_ALONE="false"
#! />
#! </GLOBAL_PARAMETERS>
#! <COMMENTS>
#! <COMMENT
#! IDENTIFIER="583"
#! COMMENT_VALUE="&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;&#10;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;&#10;p, li { white-space: pre-wrap; }&#10;&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;MS Shell Dlg 2&apos;; font-size:8.25pt; font-weight:400; font-style:normal;&quot;&gt;&#10;&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;B_SIRGAS_UTM MDB&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"
#! POSITION="2924.51 354.884"
#! TOP_LEFT="2924.51 354.884"
#! BOTTOM_RIGHT="2923.51 355.884"
#! BOUNDING_RECT="2924.51 354.884 -1 -1"
#! ORDER="5e+014"
#! FOLLOW_ANCHOR="true"
#! INFO_NODE="false"
#! COLOUR="1,1,0.784314,0.192157"
#! SIZE_POLICY="8"
#! COMMENT_TYPE="REGULAR"
#! ANCHORED_NODE="582"
#! />
#! </COMMENTS>
#! <CONSTANTS>
#! </CONSTANTS>
#! <BOOKMARKS>
#! <BOOKMARK
#! IDENTIFIER="581"
#! NAME="mdb"
#! DESCRIPTION="&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"
#! TOP_LEFT="-0.367184 274.598"
#! BOTTOM_RIGHT="1148.77 -30160.4"
#! BOUNDING_RECT="-0.367184 274.598 1149.14 30435"
#! STICKY="true"
#! COLOUR="0.658824,0.027451,0.247059"
#! CONTENTS="500 539 558 430 511 513 455 386 361 451 542 557 427 494 496 512 404 424 514 468 453 406 389 493 476 559 523 421 433 563 449 460 515 384 385 492 490 370 566 564 428 576 499 444 450 521 411 528 373 362 378 483 445 429 554 555 527 481 452 508 379 432 375 459 454 545 550 437 498 516 423 485 377 543 447 448 532 383 497 565 517 431 419 368 569 540 462 440 391 531 397 482 395 495 417 366 551 568 474 443 506 520 524 393 390 503 458 388 571 573 416 567 556 502 491 471 505 519 382 380 371 365 394 470 456 420 541 484 487 530 518 438 426 387 441 538 446 536 392 403 570 501 473 413 509 369 363 547 553 408 425 469 457 534 381 414 522 504 415 410 580 489 544 463 548 535 418 401 367 488 467 562 552 412 480 478 400 422 533 364 372 579 405 466 439 399 407 475 479 560 574 537 578 409 549 396 510 464 442 398 376 477 472 525 561 546 436 575 465 461 507 529 402 374 434 486 577 435 572 "
#! />
#! <BOOKMARK
#! IDENTIFIER="1005"
#! NAME="New Bookmark"
#! DESCRIPTION=""
#! TOP_LEFT="5725.68 372.069"
#! BOTTOM_RIGHT="6720.72 -30380.6"
#! BOUNDING_RECT="5725.68 372.069 995.035 30752.6"
#! STICKY="true"
#! COLOUR="0.0666667,0.466667,0.882353"
#! CONTENTS="819 850 620 833 790 663 939 635 934 779 976 905 736 889 592 852 630 903 959 933 669 967 822 927 780 853 849 1004 732 633 628 932 743 778 733 584 668 702 962 926 874 655 710 893 944 997 846 643 619 624 873 814 749 907 952 701 707 899 695 989 677 741 637 750 604 721 951 698 924 638 753 694 958 775 918 690 734 891 1001 613 715 693 942 898 746 928 981 832 793 904 719 986 632 636 756 744 660 612 897 870 973 900 955 906 994 714 631 858 890 970 925 739 614 711 935 920 991 659 767 880 627 718 965 917 606 738 705 983 798 896 993 686 848 982 843 726 616 682 708 919 990 761 671 785 664 937 838 857 902 737 943 654 615 747 685 748 859 656 966 883 696 950 931 731 901 649 609 856 772 930 892 922 706 915 709 980 839 667 1002 842 629 929 987 764 912 921 809 697 947 827 923 877 640 1003 911 992 621 886 742 804 851 692 938 735 916 882 988 1000 639 634 740 799 936 691 881 847 689 977 646 910 "
#! />
#! </BOOKMARKS>
#! <TRANSFORMERS>
#! <TRANSFORMER
#! IDENTIFIER="585"
#! TYPE="AttributeFilter"
#! VERSION="4"
#! POSITION="3479.21 -1159.82"
#! BOUNDING_RECT="3479.21 -1159.82 -1 -1"
#! ORDER="5e+014"
#! PARMS_EDITED="true"
#! ENABLED="false"
#! LAST_PARM_EDIT="15539"
#! >
#! <OUTPUT_FEAT NAME="&lt;EMPTY&gt;"/>
#! <FEAT_COLLAPSED COLLAPSED="0"/>
#! <XFORM_ATTR ATTR_NAME="IndexedObjectId" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="MinGX" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="MinGY" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="MaxGX" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="MaxGY" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="OBJECTID" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="SHAPE" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="materialPredominante" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="controleId" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="geometriaAproximada" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="simbolizarCartaMini" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkClassificador" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="obsAquisicao" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="nomeAbrev" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoLimMassa" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="alturaMediaMargem" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="nome" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="controle_id" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="SHAPE_Length" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="offSetSimbX" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoEstGerad" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="potenciaFiscalizadaKW" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplGerEnEletr" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="offSetY" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="justTxt" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="offSetX" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="offSetSimbY" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="operacional" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="codigoEstacao" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="destEnergElet" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="potenciaOutorgadaKW" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="situacaoFisica" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="escalaMaxSimbolizar" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="SHAPE_Area" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgComSv" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="orientacao" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="finalidade" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="matConstr" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifComercServ" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="relacionado" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="modalUso" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoClasseCnae" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplSvSoc" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplAeroport" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplPortuario" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgRel" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplIndustria" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgEnsino" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="administracao" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgExtMin" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplLazer" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgAgrop" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplEstrApoio" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="alturaEstimada" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="ovgd" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplComunic" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="posicaoRelEdific" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifTurist" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="SelectionID" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="ObjectID" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="revestimento" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="nrPistas" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="trafego" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="offSet" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="sigla" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="velocidadeMedia" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="nrFaixas" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="codTrechoRodov" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="concessionaria" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="canteiroDivisorio" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplRodovia" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoTrechoRod" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="pesoMaxSuportTon" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="jurisdicao" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="identificadorPosicGeo" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="simbolizar" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="longitude" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="latitude" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="longitude_txt" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tamanhoTxt" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="latitude_txt" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoCidade" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="salinidade" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="regime" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoMassaDagua" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifAbast" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplAbsAgua" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="dentroDePoligono" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="caladoMax" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="navegabilidade" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplTrCurDagua" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="compartilhado" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="larguraMedia" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="velocidadeMedCorrente" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="profundidadeMedia" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="coincideComDentroDe" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="eixoPrincipal" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="UUID" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="OrigItemTypeID" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="DestItemTypeID" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="Name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="ForwardLabel" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="BackwardLabel" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="IsContainment" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoCampoQuadra" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplSaude" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="nivelAtencao" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifAero" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoElemNat" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="LockID" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="LockType" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="UserName" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="MachineName" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoAglomerado" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="largura" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="extensao" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="vaoVertical" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="vaoLivreHoriz" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoPonte" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="necessidadeManutencao" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="posicaoPista" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="chamine" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoDivisaoCnae" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoEntroncamento" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoTrechoDuto" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="setor" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="posicaoRelativa" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="situacaoEspacial" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplDuto" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="nrDutos" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="matTransp" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplSaneam" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="residuo" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="construcao" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoDepSaneam" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoResiduo" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoAreaUsoComun" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoAlterAntrop" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplPubCivil" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoEdif" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoUsoEdif" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="alturaMediaIndividuos" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="classificacaoPorte" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="denso" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="antropizada" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="nascente" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="OriginClassID" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="OriginID" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="DestClassID" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="DestID" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="TopoRuleType" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="TopoRuleID" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="Shape" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="IsException" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="Shape_Length" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="Shape_Area" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplHabit" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="TableName" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="FieldName" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="columnFlags" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="repTipoTxt" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="especie" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tensaoEletrica" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="numCircuitos" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="emDuto" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplSubEnEletr" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="denominacaoAssociada" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoCemiterio" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoAtracad" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifLazer" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoPtoEnergia" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="homologacao" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoPista" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="usoPista" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoTravessia" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifComunic" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="modalidade" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifRod" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="cota" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="cotaComprovada" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="visivel" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="religiao" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifRelig" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="ensino" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="ocorrenciaEm" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoCampo" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="Type" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="PhysicalName" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="Path" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="DatasetSubtype1" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="DatasetSubtype2" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="DatasetInfo1" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="DatasetInfo2" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="URL" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="Definition" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="Documentation" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="ItemInfo" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="Properties" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="Defaults" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoExposicao" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoProdutoResiduo" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoConteudo" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="valorVolume" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tratamento" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoDepGeral" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="unidadeVolume" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="codEstacao" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplEstMedFen" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="orgaoEnteResp" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoPtoEstMed" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifAgropec" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="indice" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="depressao" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="ordemTickDepressao" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="emMassaDagua" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="cotadaPorProcesso" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoCerr" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoDelimFis" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="eletrificada" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="IsRetired" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="DirtyArea" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="DirtyArea_Length" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="DirtyArea_Area" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplMilitar" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="ShapeType" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="ExtentLeft" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="ExtentBottom" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="ExtentRight" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="ExtentTop" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="IdxOriginX" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="IdxOriginY" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="IdxGridSize" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="SRID" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="HasZ" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="HasM" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="ZLow" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="ZHigh" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="MLow" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="MHigh" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="periodicidadeInunda" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoTerrExp" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="causaExposicao" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="SRTEXT" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="FalseX" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="FalseY" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="XYUnits" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="FalseZ" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="ZUnits" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="FalseM" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="MUnits" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="IsHighPrecision" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="XYTolerance" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="ZTolerance" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="MTolerance" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="TargetName" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="Attributes" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="usoPrincipal" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifSaneam" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoLavoura" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="espessuraDAP" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="cultivoPredominante" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="terreno" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="espacamentoIndividuos" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoSumVert" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="causa" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="ParentTypeID" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoFonteDagua" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="qualidAgua" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="ID" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="ReplicaID" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="Event" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="ErrorCode" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="LogDate" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="SourceBeginGen" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="SourceEndGen" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="TargetGen" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="situacaoEmAgua" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoBanco" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <OUTPUT_FEAT NAME="&lt;MISSING&gt;"/>
#! <FEAT_COLLAPSED COLLAPSED="1"/>
#! <XFORM_ATTR ATTR_NAME="IndexedObjectId" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="MinGX" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="MinGY" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="MaxGX" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="MaxGY" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="OBJECTID" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="SHAPE" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="materialPredominante" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="controleId" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="geometriaAproximada" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="simbolizarCartaMini" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkClassificador" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="obsAquisicao" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="nomeAbrev" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoLimMassa" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="alturaMediaMargem" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="nome" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="controle_id" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="SHAPE_Length" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="offSetSimbX" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoEstGerad" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="potenciaFiscalizadaKW" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplGerEnEletr" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="offSetY" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="justTxt" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="offSetX" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="offSetSimbY" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="operacional" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="codigoEstacao" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="destEnergElet" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="potenciaOutorgadaKW" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="situacaoFisica" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="escalaMaxSimbolizar" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="SHAPE_Area" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgComSv" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="orientacao" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="finalidade" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="matConstr" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifComercServ" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="relacionado" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="modalUso" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoClasseCnae" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplSvSoc" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplAeroport" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplPortuario" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgRel" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplIndustria" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgEnsino" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="administracao" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgExtMin" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplLazer" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgAgrop" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplEstrApoio" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="alturaEstimada" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="ovgd" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplComunic" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="posicaoRelEdific" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifTurist" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="SelectionID" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="ObjectID" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="revestimento" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="nrPistas" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="trafego" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="offSet" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="sigla" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="velocidadeMedia" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="nrFaixas" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="codTrechoRodov" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="concessionaria" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="canteiroDivisorio" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplRodovia" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoTrechoRod" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="pesoMaxSuportTon" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="jurisdicao" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="identificadorPosicGeo" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="simbolizar" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="longitude" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="latitude" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="longitude_txt" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tamanhoTxt" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="latitude_txt" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoCidade" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="salinidade" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="regime" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoMassaDagua" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifAbast" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplAbsAgua" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="dentroDePoligono" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="caladoMax" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="navegabilidade" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplTrCurDagua" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="compartilhado" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="larguraMedia" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="velocidadeMedCorrente" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="profundidadeMedia" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="coincideComDentroDe" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="eixoPrincipal" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="UUID" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="OrigItemTypeID" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="DestItemTypeID" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="Name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="ForwardLabel" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="BackwardLabel" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="IsContainment" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoCampoQuadra" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplSaude" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="nivelAtencao" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifAero" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoElemNat" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="LockID" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="LockType" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="UserName" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="MachineName" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoAglomerado" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="largura" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="extensao" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="vaoVertical" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="vaoLivreHoriz" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoPonte" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="necessidadeManutencao" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="posicaoPista" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="chamine" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoDivisaoCnae" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoEntroncamento" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoTrechoDuto" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="setor" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="posicaoRelativa" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="situacaoEspacial" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplDuto" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="nrDutos" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="matTransp" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplSaneam" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="residuo" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="construcao" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoDepSaneam" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoResiduo" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoAreaUsoComun" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoAlterAntrop" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplPubCivil" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoEdif" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoUsoEdif" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="alturaMediaIndividuos" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="classificacaoPorte" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="denso" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="antropizada" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="nascente" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="OriginClassID" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="OriginID" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="DestClassID" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="DestID" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="TopoRuleType" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="TopoRuleID" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="Shape" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="IsException" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="Shape_Length" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="Shape_Area" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplHabit" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="TableName" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="FieldName" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="columnFlags" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="repTipoTxt" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="especie" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tensaoEletrica" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="numCircuitos" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="emDuto" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplSubEnEletr" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="denominacaoAssociada" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoCemiterio" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoAtracad" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifLazer" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoPtoEnergia" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="homologacao" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoPista" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="usoPista" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoTravessia" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifComunic" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="modalidade" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifRod" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="cota" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="cotaComprovada" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="visivel" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="religiao" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifRelig" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="ensino" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="ocorrenciaEm" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoCampo" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="Type" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="PhysicalName" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="Path" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="DatasetSubtype1" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="DatasetSubtype2" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="DatasetInfo1" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="DatasetInfo2" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="URL" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="Definition" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="Documentation" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="ItemInfo" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="Properties" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="Defaults" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoExposicao" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoProdutoResiduo" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoConteudo" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="valorVolume" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tratamento" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoDepGeral" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="unidadeVolume" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="codEstacao" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplEstMedFen" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="orgaoEnteResp" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoPtoEstMed" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifAgropec" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="indice" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="depressao" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="ordemTickDepressao" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="emMassaDagua" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="cotadaPorProcesso" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoCerr" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoDelimFis" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="eletrificada" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="IsRetired" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="DirtyArea" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="DirtyArea_Length" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="DirtyArea_Area" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplMilitar" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="ShapeType" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="ExtentLeft" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="ExtentBottom" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="ExtentRight" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="ExtentTop" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="IdxOriginX" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="IdxOriginY" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="IdxGridSize" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="SRID" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="HasZ" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="HasM" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="ZLow" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="ZHigh" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="MLow" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="MHigh" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="periodicidadeInunda" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoTerrExp" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="causaExposicao" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="SRTEXT" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="FalseX" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="FalseY" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="XYUnits" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="FalseZ" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="ZUnits" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="FalseM" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="MUnits" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="IsHighPrecision" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="XYTolerance" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="ZTolerance" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="MTolerance" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="TargetName" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="Attributes" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="usoPrincipal" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifSaneam" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoLavoura" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="espessuraDAP" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="cultivoPredominante" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="terreno" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="espacamentoIndividuos" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoSumVert" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="causa" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="ParentTypeID" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoFonteDagua" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="qualidAgua" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="ID" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="ReplicaID" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="Event" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="ErrorCode" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="LogDate" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="SourceBeginGen" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="SourceEndGen" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="TargetGen" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="situacaoEmAgua" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoBanco" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <OUTPUT_FEAT NAME="&lt;NULL&gt;"/>
#! <FEAT_COLLAPSED COLLAPSED="2"/>
#! <XFORM_ATTR ATTR_NAME="IndexedObjectId" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="MinGX" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="MinGY" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="MaxGX" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="MaxGY" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="OBJECTID" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="SHAPE" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="materialPredominante" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="controleId" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="geometriaAproximada" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="simbolizarCartaMini" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkClassificador" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="obsAquisicao" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="nomeAbrev" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoLimMassa" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="alturaMediaMargem" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="nome" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="controle_id" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="SHAPE_Length" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="offSetSimbX" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoEstGerad" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="potenciaFiscalizadaKW" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplGerEnEletr" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="offSetY" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="justTxt" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="offSetX" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="offSetSimbY" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="operacional" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="codigoEstacao" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="destEnergElet" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="potenciaOutorgadaKW" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="situacaoFisica" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="escalaMaxSimbolizar" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="SHAPE_Area" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgComSv" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="orientacao" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="finalidade" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="matConstr" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifComercServ" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="relacionado" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="modalUso" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoClasseCnae" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplSvSoc" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplAeroport" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplPortuario" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgRel" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplIndustria" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgEnsino" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="administracao" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgExtMin" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplLazer" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgAgrop" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplEstrApoio" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="alturaEstimada" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="ovgd" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplComunic" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="posicaoRelEdific" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifTurist" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="SelectionID" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="ObjectID" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="revestimento" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="nrPistas" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="trafego" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="offSet" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="sigla" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="velocidadeMedia" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="nrFaixas" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="codTrechoRodov" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="concessionaria" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="canteiroDivisorio" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplRodovia" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoTrechoRod" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="pesoMaxSuportTon" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="jurisdicao" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="identificadorPosicGeo" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="simbolizar" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="longitude" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="latitude" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="longitude_txt" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tamanhoTxt" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="latitude_txt" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoCidade" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="salinidade" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="regime" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoMassaDagua" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifAbast" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplAbsAgua" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="dentroDePoligono" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="caladoMax" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="navegabilidade" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplTrCurDagua" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="compartilhado" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="larguraMedia" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="velocidadeMedCorrente" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="profundidadeMedia" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="coincideComDentroDe" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="eixoPrincipal" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="UUID" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="OrigItemTypeID" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="DestItemTypeID" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="Name" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="ForwardLabel" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="BackwardLabel" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="IsContainment" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoCampoQuadra" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplSaude" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="nivelAtencao" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifAero" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoElemNat" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="LockID" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="LockType" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="UserName" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="MachineName" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoAglomerado" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="largura" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="extensao" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="vaoVertical" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="vaoLivreHoriz" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoPonte" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="necessidadeManutencao" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="posicaoPista" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="chamine" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoDivisaoCnae" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoEntroncamento" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoTrechoDuto" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="setor" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="posicaoRelativa" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="situacaoEspacial" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplDuto" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="nrDutos" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="matTransp" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplSaneam" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="residuo" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="construcao" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoDepSaneam" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoResiduo" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoAreaUsoComun" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoAlterAntrop" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplPubCivil" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoEdif" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoUsoEdif" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="alturaMediaIndividuos" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="classificacaoPorte" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="denso" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="antropizada" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="nascente" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="OriginClassID" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="OriginID" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="DestClassID" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="DestID" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="TopoRuleType" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="TopoRuleID" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="Shape" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="IsException" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="Shape_Length" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="Shape_Area" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplHabit" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="TableName" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="FieldName" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="columnFlags" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="repTipoTxt" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="especie" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tensaoEletrica" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="numCircuitos" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="emDuto" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplSubEnEletr" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="denominacaoAssociada" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoCemiterio" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoAtracad" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifLazer" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoPtoEnergia" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="homologacao" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoPista" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="usoPista" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoTravessia" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifComunic" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="modalidade" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifRod" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="cota" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="cotaComprovada" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="visivel" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="religiao" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifRelig" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="ensino" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="ocorrenciaEm" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoCampo" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="Type" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="PhysicalName" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="Path" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="DatasetSubtype1" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="DatasetSubtype2" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="DatasetInfo1" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="DatasetInfo2" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="URL" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="Definition" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="Documentation" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="ItemInfo" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="Properties" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="Defaults" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoExposicao" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoProdutoResiduo" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoConteudo" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="valorVolume" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tratamento" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoDepGeral" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="unidadeVolume" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="codEstacao" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplEstMedFen" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="orgaoEnteResp" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoPtoEstMed" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifAgropec" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="indice" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="depressao" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="ordemTickDepressao" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="emMassaDagua" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="cotadaPorProcesso" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoCerr" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoDelimFis" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="eletrificada" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="IsRetired" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="DirtyArea" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="DirtyArea_Length" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="DirtyArea_Area" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="fkComplMilitar" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="ShapeType" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="ExtentLeft" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="ExtentBottom" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="ExtentRight" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="ExtentTop" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="IdxOriginX" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="IdxOriginY" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="IdxGridSize" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="SRID" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="HasZ" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="HasM" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="ZLow" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="ZHigh" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="MLow" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="MHigh" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="periodicidadeInunda" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoTerrExp" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="causaExposicao" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="SRTEXT" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="FalseX" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="FalseY" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="XYUnits" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="FalseZ" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="ZUnits" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="FalseM" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="MUnits" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="IsHighPrecision" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="XYTolerance" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="ZTolerance" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="MTolerance" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="TargetName" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="Attributes" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="usoPrincipal" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifSaneam" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoLavoura" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="espessuraDAP" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="cultivoPredominante" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="terreno" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="espacamentoIndividuos" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoSumVert" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="causa" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="ParentTypeID" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoFonteDagua" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="qualidAgua" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="ID" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="ReplicaID" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="Event" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="ErrorCode" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="LogDate" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="SourceBeginGen" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="SourceEndGen" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="TargetGen" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="situacaoEmAgua" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <XFORM_ATTR ATTR_NAME="tipoBanco" IS_USER_CREATED="false" FEAT_INDEX="2" />
#! <OUTPUT_FEAT NAME="&lt;UNFILTERED&gt;"/>
#! <FEAT_COLLAPSED COLLAPSED="3"/>
#! <XFORM_ATTR ATTR_NAME="IndexedObjectId" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="MinGX" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="MinGY" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="MaxGX" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="MaxGY" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="OBJECTID" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="SHAPE" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="materialPredominante" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="controleId" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="geometriaAproximada" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="simbolizarCartaMini" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkClassificador" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="obsAquisicao" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="nomeAbrev" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoLimMassa" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="alturaMediaMargem" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="nome" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="controle_id" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="SHAPE_Length" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="offSetSimbX" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoEstGerad" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="potenciaFiscalizadaKW" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplGerEnEletr" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="offSetY" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="justTxt" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="offSetX" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="offSetSimbY" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="operacional" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="codigoEstacao" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="destEnergElet" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="potenciaOutorgadaKW" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="situacaoFisica" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="escalaMaxSimbolizar" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="SHAPE_Area" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgComSv" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="orientacao" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="finalidade" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="matConstr" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifComercServ" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="relacionado" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="modalUso" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoClasseCnae" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplSvSoc" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplAeroport" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplPortuario" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgRel" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplIndustria" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgEnsino" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="administracao" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgExtMin" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplLazer" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgAgrop" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplEstrApoio" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="alturaEstimada" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="ovgd" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplComunic" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="posicaoRelEdific" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifTurist" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="SelectionID" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="ObjectID" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="revestimento" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="nrPistas" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="trafego" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="offSet" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="sigla" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="velocidadeMedia" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="nrFaixas" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="codTrechoRodov" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="concessionaria" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="canteiroDivisorio" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplRodovia" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoTrechoRod" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="pesoMaxSuportTon" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="jurisdicao" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="identificadorPosicGeo" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="simbolizar" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="longitude" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="latitude" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="longitude_txt" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tamanhoTxt" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="latitude_txt" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoCidade" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="salinidade" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="regime" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoMassaDagua" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifAbast" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplAbsAgua" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="dentroDePoligono" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="caladoMax" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="navegabilidade" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplTrCurDagua" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="compartilhado" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="larguraMedia" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="velocidadeMedCorrente" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="profundidadeMedia" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="coincideComDentroDe" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="eixoPrincipal" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="UUID" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="OrigItemTypeID" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="DestItemTypeID" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="Name" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="ForwardLabel" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="BackwardLabel" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="IsContainment" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoCampoQuadra" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplSaude" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="nivelAtencao" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifAero" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoElemNat" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="LockID" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="LockType" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="UserName" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="MachineName" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoAglomerado" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="largura" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="extensao" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="vaoVertical" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="vaoLivreHoriz" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoPonte" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="necessidadeManutencao" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="posicaoPista" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="chamine" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoDivisaoCnae" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoEntroncamento" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoTrechoDuto" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="setor" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="posicaoRelativa" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="situacaoEspacial" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplDuto" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="nrDutos" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="matTransp" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplSaneam" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="residuo" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="construcao" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoDepSaneam" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoResiduo" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoAreaUsoComun" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoAlterAntrop" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplPubCivil" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoEdif" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoUsoEdif" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="alturaMediaIndividuos" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="classificacaoPorte" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="denso" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="antropizada" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="nascente" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="OriginClassID" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="OriginID" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="DestClassID" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="DestID" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="TopoRuleType" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="TopoRuleID" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="Shape" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="IsException" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="Shape_Length" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="Shape_Area" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplHabit" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="TableName" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="FieldName" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="columnFlags" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="repTipoTxt" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="especie" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tensaoEletrica" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="numCircuitos" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="emDuto" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplSubEnEletr" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="denominacaoAssociada" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoCemiterio" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoAtracad" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifLazer" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoPtoEnergia" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="homologacao" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoPista" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="usoPista" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoTravessia" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifComunic" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="modalidade" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifRod" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="cota" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="cotaComprovada" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="visivel" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="religiao" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifRelig" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="ensino" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="ocorrenciaEm" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoCampo" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="Type" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="PhysicalName" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="Path" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="DatasetSubtype1" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="DatasetSubtype2" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="DatasetInfo1" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="DatasetInfo2" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="URL" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="Definition" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="Documentation" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="ItemInfo" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="Properties" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="Defaults" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoExposicao" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoProdutoResiduo" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoConteudo" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="valorVolume" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tratamento" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoDepGeral" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="unidadeVolume" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="codEstacao" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplEstMedFen" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="orgaoEnteResp" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoPtoEstMed" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifAgropec" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="indice" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="depressao" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="ordemTickDepressao" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="emMassaDagua" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="cotadaPorProcesso" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoCerr" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoDelimFis" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="eletrificada" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="IsRetired" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="DirtyArea" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="DirtyArea_Length" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="DirtyArea_Area" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="fkComplMilitar" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="ShapeType" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="ExtentLeft" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="ExtentBottom" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="ExtentRight" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="ExtentTop" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="IdxOriginX" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="IdxOriginY" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="IdxGridSize" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="SRID" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="HasZ" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="HasM" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="ZLow" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="ZHigh" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="MLow" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="MHigh" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="periodicidadeInunda" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoTerrExp" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="causaExposicao" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="SRTEXT" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="FalseX" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="FalseY" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="XYUnits" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="FalseZ" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="ZUnits" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="FalseM" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="MUnits" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="IsHighPrecision" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="XYTolerance" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="ZTolerance" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="MTolerance" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="TargetName" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="Attributes" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="usoPrincipal" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoEdifSaneam" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoLavoura" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="espessuraDAP" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="cultivoPredominante" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="terreno" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="espacamentoIndividuos" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoSumVert" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="causa" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="ParentTypeID" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoFonteDagua" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="qualidAgua" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="ID" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="ReplicaID" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="Event" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="ErrorCode" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="LogDate" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="SourceBeginGen" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="SourceEndGen" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="TargetGen" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="situacaoEmAgua" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_ATTR ATTR_NAME="tipoBanco" IS_USER_CREATED="false" FEAT_INDEX="3" />
#! <XFORM_PARM PARM_NAME="ATTR_GROUP" PARM_VALUE=""/>
#! <XFORM_PARM PARM_NAME="ATTR_NAME" PARM_VALUE="nomeAbrev"/>
#! <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="AttributeFilter"/>
#! <XFORM_PARM PARM_NAME="ATTR_VALUES" PARM_VALUE="&lt;lt&gt;EMPTY&lt;gt&gt;,&lt;lt&gt;MISSING&lt;gt&gt;,&lt;lt&gt;NULL&lt;gt&gt;,&lt;lt&gt;UNFILTERED&lt;gt&gt;"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#! IDENTIFIER="588"
#! TYPE="AttributeCreator"
#! VERSION="7"
#! POSITION="4241.37 -645.174"
#! BOUNDING_RECT="4241.37 -645.174 -1 -1"
#! ORDER="5e+014"
#! PARMS_EDITED="true"
#! ENABLED="true"
#! LAST_PARM_EDIT="15539"
#! >
#! <OUTPUT_FEAT NAME="OUTPUT"/>
#! <FEAT_COLLAPSED COLLAPSED="0"/>
#! <XFORM_ATTR ATTR_NAME="OBJECTID" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="SHAPE" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="simbolizarCartaMini" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="justTxt" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="offSetY" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgExtMin" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgComSv" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="offSetX" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplIndustria" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="controleId" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="construcao" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplAbsAgua" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="orientacao" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="nomeAbrev" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="finalidade" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="offSetSimbY" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgAgrop" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="escalaMaxSimbolizar" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkClassificador" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="operacional" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="geometriaAproximada" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="obsAquisicao" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="situacaoFisica" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="situacaoAgua" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoDepAbast" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="nome" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="offSetSimbX" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="matConstr" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="controle_id" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_PARM PARM_NAME="NULL_ATTR_VALUE" PARM_VALUE="&lt;Unused&gt;"/>
#! <XFORM_PARM PARM_NAME="NUM_PRIOR_FEATURES" PARM_VALUE="&lt;Unused&gt;"/>
#! <XFORM_PARM PARM_NAME="ATTRIBUTE_HANDLING" PARM_VALUE=""/>
#! <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="AttributeCreator"/>
#! <XFORM_PARM PARM_NAME="NUM_SUBSEQUENT_FEATURES" PARM_VALUE="&lt;Unused&gt;"/>
#! <XFORM_PARM PARM_NAME="ATTR_LIST" PARM_VALUE="nomeAbrev,Caixa&lt;space&gt;d&lt;apos&gt;&lt;u00e1&gt;gua&lt;space&gt;22"/>
#! <XFORM_PARM PARM_NAME="NULL_ATTR_MODE_DISPLAY" PARM_VALUE="No Substitution"/>
#! <XFORM_PARM PARM_NAME="MULTI_FEATURE_MODE" PARM_VALUE="NO"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#! IDENTIFIER="600"
#! TYPE="Tester"
#! VERSION="2"
#! POSITION="3642.29 -505.724"
#! BOUNDING_RECT="3642.29 -505.724 -1 -1"
#! ORDER="5e+014"
#! PARMS_EDITED="true"
#! ENABLED="true"
#! LAST_PARM_EDIT="15539"
#! >
#! <OUTPUT_FEAT NAME="PASSED"/>
#! <FEAT_COLLAPSED COLLAPSED="0"/>
#! <XFORM_ATTR ATTR_NAME="OBJECTID" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="SHAPE" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="simbolizarCartaMini" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="justTxt" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="offSetY" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgExtMin" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgComSv" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="offSetX" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplIndustria" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="controleId" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="construcao" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplAbsAgua" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="orientacao" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="nomeAbrev" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="finalidade" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="offSetSimbY" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgAgrop" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="escalaMaxSimbolizar" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="fkClassificador" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="operacional" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="geometriaAproximada" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="obsAquisicao" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="situacaoFisica" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="situacaoAgua" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="tipoDepAbast" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="nome" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="offSetSimbX" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="matConstr" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <XFORM_ATTR ATTR_NAME="controle_id" IS_USER_CREATED="false" FEAT_INDEX="0" />
#! <OUTPUT_FEAT NAME="FAILED"/>
#! <FEAT_COLLAPSED COLLAPSED="1"/>
#! <XFORM_ATTR ATTR_NAME="OBJECTID" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="SHAPE" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="simbolizarCartaMini" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="justTxt" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="offSetY" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgExtMin" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgComSv" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="offSetX" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplIndustria" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="controleId" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="construcao" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplAbsAgua" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="orientacao" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="nomeAbrev" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="finalidade" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="offSetSimbY" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkComplOrgAgrop" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="escalaMaxSimbolizar" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="fkClassificador" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="operacional" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="geometriaAproximada" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="obsAquisicao" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="situacaoFisica" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="situacaoAgua" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="tipoDepAbast" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="nome" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="offSetSimbX" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="matConstr" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_ATTR ATTR_NAME="controle_id" IS_USER_CREATED="false" FEAT_INDEX="1" />
#! <XFORM_PARM PARM_NAME="BOOL_OP" PARM_VALUE="OR"/>
#! <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="Tester"/>
#! <XFORM_PARM PARM_NAME="TEST_LIST" PARM_VALUE=""/>
#! <XFORM_PARM PARM_NAME="TEST_DESCRIPTION" PARM_VALUE="&quot;&quot;"/>
#! <XFORM_PARM PARM_NAME="TEST_MODE" PARM_VALUE="Automatic"/>
#! <XFORM_PARM PARM_NAME="COMPOSITE_TEST" PARM_VALUE="&lt;Unused&gt;"/>
#! <XFORM_PARM PARM_NAME="TEST_CLAUSE" PARM_VALUE="TEST nomeAbrev ATTRIBUTE_VALUE_NULL &quot;&quot;"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#! IDENTIFIER="1008"
#! TYPE="Inspector"
#! VERSION="3"
#! POSITION="4888.76 108.347"
#! BOUNDING_RECT="4888.76 108.347 -1 -1"
#! ORDER="5e+014"
#! PARMS_EDITED="false"
#! ENABLED="true"
#! LAST_PARM_EDIT="15539"
#! >
#! <XFORM_PARM PARM_NAME="POINTCLOUD_GROUP" PARM_VALUE=""/>
#! <XFORM_PARM PARM_NAME="THINNER_MAX_NUM_POINTS" PARM_VALUE="&lt;Unused&gt;"/>
#! <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="Dep_Abast_Agua_point"/>
#! <XFORM_PARM PARM_NAME="VECTOR_GROUP" PARM_VALUE=""/>
#! <XFORM_PARM PARM_NAME="AREA_COLOR" PARM_VALUE=""/>
#! <XFORM_PARM PARM_NAME="TACKATTRS" PARM_VALUE=""/>
#! <XFORM_PARM PARM_NAME="RASTER_GROUP" PARM_VALUE=""/>
#! <XFORM_PARM PARM_NAME="RASTER_START_ROW" PARM_VALUE="&lt;Unused&gt;"/>
#! <XFORM_PARM PARM_NAME="RASTER_VISUALIZATION_OPTION" PARM_VALUE="No Reduction"/>
#! <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#! <XFORM_PARM PARM_NAME="RASTER_NUM_COLS" PARM_VALUE="&lt;Unused&gt;"/>
#! <XFORM_PARM PARM_NAME="PEN_COLOR" PARM_VALUE=""/>
#! <XFORM_PARM PARM_NAME="THINNER_INTERVAL" PARM_VALUE="&lt;Unused&gt;"/>
#! <XFORM_PARM PARM_NAME="RASTER_START_COL" PARM_VALUE="&lt;Unused&gt;"/>
#! <XFORM_PARM PARM_NAME="RASTER_NUM_ROWS" PARM_VALUE="&lt;Unused&gt;"/>
#! <XFORM_PARM PARM_NAME="THINNER_TYPE_DISPLAY" PARM_VALUE="No Thinning"/>
#! </TRANSFORMER>
#! </TRANSFORMERS>
#! <FEAT_LINKS>
#! <FEAT_LINK
#! IDENTIFIER="586"
#! SOURCE_NODE="369"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="590"
#! SOURCE_NODE="580"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="591"
#! SOURCE_NODE="579"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="594"
#! SOURCE_NODE="578"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="595"
#! SOURCE_NODE="577"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="597"
#! SOURCE_NODE="576"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="598"
#! SOURCE_NODE="575"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="607"
#! SOURCE_NODE="574"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="608"
#! SOURCE_NODE="573"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="610"
#! SOURCE_NODE="572"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="611"
#! SOURCE_NODE="571"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="617"
#! SOURCE_NODE="570"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="618"
#! SOURCE_NODE="569"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="622"
#! SOURCE_NODE="568"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="623"
#! SOURCE_NODE="567"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="625"
#! SOURCE_NODE="566"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="626"
#! SOURCE_NODE="565"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="641"
#! SOURCE_NODE="564"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="642"
#! SOURCE_NODE="563"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="644"
#! SOURCE_NODE="562"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="645"
#! SOURCE_NODE="561"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="647"
#! SOURCE_NODE="560"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="648"
#! SOURCE_NODE="559"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="650"
#! SOURCE_NODE="558"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="651"
#! SOURCE_NODE="557"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="652"
#! SOURCE_NODE="556"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="653"
#! SOURCE_NODE="555"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="657"
#! SOURCE_NODE="554"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="658"
#! SOURCE_NODE="553"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="661"
#! SOURCE_NODE="552"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="662"
#! SOURCE_NODE="551"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="665"
#! SOURCE_NODE="550"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="666"
#! SOURCE_NODE="549"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="670"
#! SOURCE_NODE="548"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="672"
#! SOURCE_NODE="547"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="673"
#! SOURCE_NODE="546"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="674"
#! SOURCE_NODE="545"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="675"
#! SOURCE_NODE="544"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="676"
#! SOURCE_NODE="543"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="678"
#! SOURCE_NODE="542"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="679"
#! SOURCE_NODE="541"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="680"
#! SOURCE_NODE="540"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="681"
#! SOURCE_NODE="539"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="683"
#! SOURCE_NODE="538"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="684"
#! SOURCE_NODE="537"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="687"
#! SOURCE_NODE="536"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="688"
#! SOURCE_NODE="535"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="699"
#! SOURCE_NODE="534"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="700"
#! SOURCE_NODE="533"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="703"
#! SOURCE_NODE="532"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="704"
#! SOURCE_NODE="531"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="712"
#! SOURCE_NODE="530"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="713"
#! SOURCE_NODE="529"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="716"
#! SOURCE_NODE="528"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="717"
#! SOURCE_NODE="527"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="720"
#! SOURCE_NODE="525"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="722"
#! SOURCE_NODE="524"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="723"
#! SOURCE_NODE="523"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="724"
#! SOURCE_NODE="522"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="725"
#! SOURCE_NODE="521"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="727"
#! SOURCE_NODE="520"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="728"
#! SOURCE_NODE="519"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="729"
#! SOURCE_NODE="518"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="730"
#! SOURCE_NODE="517"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="751"
#! SOURCE_NODE="516"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="752"
#! SOURCE_NODE="515"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="754"
#! SOURCE_NODE="514"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="755"
#! SOURCE_NODE="513"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="757"
#! SOURCE_NODE="512"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="758"
#! SOURCE_NODE="511"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="759"
#! SOURCE_NODE="510"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="760"
#! SOURCE_NODE="509"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="762"
#! SOURCE_NODE="508"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="763"
#! SOURCE_NODE="507"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="765"
#! SOURCE_NODE="506"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="766"
#! SOURCE_NODE="505"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="768"
#! SOURCE_NODE="504"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="769"
#! SOURCE_NODE="503"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="770"
#! SOURCE_NODE="502"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="771"
#! SOURCE_NODE="501"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="773"
#! SOURCE_NODE="500"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="774"
#! SOURCE_NODE="499"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="776"
#! SOURCE_NODE="498"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="777"
#! SOURCE_NODE="497"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="781"
#! SOURCE_NODE="496"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="782"
#! SOURCE_NODE="495"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="783"
#! SOURCE_NODE="494"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="784"
#! SOURCE_NODE="493"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="786"
#! SOURCE_NODE="492"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="787"
#! SOURCE_NODE="491"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="788"
#! SOURCE_NODE="490"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="789"
#! SOURCE_NODE="489"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="791"
#! SOURCE_NODE="488"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="792"
#! SOURCE_NODE="487"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="794"
#! SOURCE_NODE="486"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="795"
#! SOURCE_NODE="485"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="796"
#! SOURCE_NODE="484"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="797"
#! SOURCE_NODE="483"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="800"
#! SOURCE_NODE="482"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="801"
#! SOURCE_NODE="481"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="802"
#! SOURCE_NODE="480"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="803"
#! SOURCE_NODE="479"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="805"
#! SOURCE_NODE="478"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="806"
#! SOURCE_NODE="477"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="807"
#! SOURCE_NODE="476"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="808"
#! SOURCE_NODE="475"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="810"
#! SOURCE_NODE="474"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="811"
#! SOURCE_NODE="473"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="812"
#! SOURCE_NODE="472"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="813"
#! SOURCE_NODE="471"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="815"
#! SOURCE_NODE="470"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="816"
#! SOURCE_NODE="469"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="817"
#! SOURCE_NODE="468"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="818"
#! SOURCE_NODE="467"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="820"
#! SOURCE_NODE="466"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="821"
#! SOURCE_NODE="465"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="823"
#! SOURCE_NODE="464"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="824"
#! SOURCE_NODE="463"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="825"
#! SOURCE_NODE="462"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="826"
#! SOURCE_NODE="461"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="828"
#! SOURCE_NODE="460"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="829"
#! SOURCE_NODE="459"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="830"
#! SOURCE_NODE="458"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="831"
#! SOURCE_NODE="457"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="834"
#! SOURCE_NODE="456"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="835"
#! SOURCE_NODE="455"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="836"
#! SOURCE_NODE="454"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="837"
#! SOURCE_NODE="453"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="840"
#! SOURCE_NODE="452"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="841"
#! SOURCE_NODE="451"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="844"
#! SOURCE_NODE="450"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="845"
#! SOURCE_NODE="449"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="854"
#! SOURCE_NODE="448"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="855"
#! SOURCE_NODE="447"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="860"
#! SOURCE_NODE="444"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="861"
#! SOURCE_NODE="443"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="862"
#! SOURCE_NODE="442"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="863"
#! SOURCE_NODE="440"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="864"
#! SOURCE_NODE="441"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="865"
#! SOURCE_NODE="437"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="866"
#! SOURCE_NODE="439"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="867"
#! SOURCE_NODE="438"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="868"
#! SOURCE_NODE="436"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="869"
#! SOURCE_NODE="435"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="871"
#! SOURCE_NODE="446"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="872"
#! SOURCE_NODE="445"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="875"
#! SOURCE_NODE="434"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="876"
#! SOURCE_NODE="433"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="878"
#! SOURCE_NODE="432"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="879"
#! SOURCE_NODE="431"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="884"
#! SOURCE_NODE="430"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="885"
#! SOURCE_NODE="429"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="887"
#! SOURCE_NODE="428"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="888"
#! SOURCE_NODE="427"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="894"
#! SOURCE_NODE="426"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="895"
#! SOURCE_NODE="425"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="908"
#! SOURCE_NODE="424"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="909"
#! SOURCE_NODE="423"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="913"
#! SOURCE_NODE="422"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="914"
#! SOURCE_NODE="421"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="940"
#! SOURCE_NODE="420"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="941"
#! SOURCE_NODE="419"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="945"
#! SOURCE_NODE="418"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="946"
#! SOURCE_NODE="417"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="948"
#! SOURCE_NODE="416"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="949"
#! SOURCE_NODE="415"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="953"
#! SOURCE_NODE="414"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="954"
#! SOURCE_NODE="413"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="956"
#! SOURCE_NODE="412"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="957"
#! SOURCE_NODE="411"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="960"
#! SOURCE_NODE="410"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="961"
#! SOURCE_NODE="409"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="963"
#! SOURCE_NODE="408"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="964"
#! SOURCE_NODE="407"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="968"
#! SOURCE_NODE="406"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="969"
#! SOURCE_NODE="405"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="971"
#! SOURCE_NODE="404"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="972"
#! SOURCE_NODE="403"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="974"
#! SOURCE_NODE="402"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="975"
#! SOURCE_NODE="401"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="978"
#! SOURCE_NODE="400"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="979"
#! SOURCE_NODE="399"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="984"
#! SOURCE_NODE="398"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="985"
#! SOURCE_NODE="397"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="995"
#! SOURCE_NODE="396"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="996"
#! SOURCE_NODE="395"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="998"
#! SOURCE_NODE="394"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="999"
#! SOURCE_NODE="393"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1025"
#! SOURCE_NODE="392"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1026"
#! SOURCE_NODE="391"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1027"
#! SOURCE_NODE="390"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1028"
#! SOURCE_NODE="389"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1029"
#! SOURCE_NODE="388"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1030"
#! SOURCE_NODE="387"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1031"
#! SOURCE_NODE="386"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1032"
#! SOURCE_NODE="385"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1033"
#! SOURCE_NODE="384"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1034"
#! SOURCE_NODE="383"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1039"
#! SOURCE_NODE="382"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1040"
#! SOURCE_NODE="381"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1042"
#! SOURCE_NODE="380"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1043"
#! SOURCE_NODE="379"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1049"
#! SOURCE_NODE="377"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1053"
#! SOURCE_NODE="376"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1054"
#! SOURCE_NODE="375"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1059"
#! SOURCE_NODE="374"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1060"
#! SOURCE_NODE="373"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1062"
#! SOURCE_NODE="372"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1063"
#! SOURCE_NODE="371"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1065"
#! SOURCE_NODE="370"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1069"
#! SOURCE_NODE="368"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1070"
#! SOURCE_NODE="367"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1072"
#! SOURCE_NODE="366"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1073"
#! SOURCE_NODE="365"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1075"
#! SOURCE_NODE="364"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1076"
#! SOURCE_NODE="363"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1087"
#! SOURCE_NODE="362"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1088"
#! SOURCE_NODE="361"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="605"
#! SOURCE_NODE="378"
#! TARGET_NODE="585"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1006"
#! SOURCE_NODE="588"
#! TARGET_NODE="745"
#! SOURCE_PORT_DESC="fo 0"
#! TARGET_PORT_DESC="-1"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1012"
#! SOURCE_NODE="526"
#! TARGET_NODE="600"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1013"
#! SOURCE_NODE="1007"
#! TARGET_NODE="588"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#! IDENTIFIER="1009"
#! SOURCE_NODE="1007"
#! TARGET_NODE="1008"
#! SOURCE_PORT_DESC="-1"
#! TARGET_PORT_DESC="fi 0"
#! ENABLED="true"
#! EXTRA_POINTS=""
#! />
#! </FEAT_LINKS>
#! <BREAKPOINTS>
#! </BREAKPOINTS>
#! <ATTR_LINKS>
#! </ATTR_LINKS>
#! <SUBDOCUMENTS>
#! </SUBDOCUMENTS>
#! <LOOKUP_TABLES>
#! </LOOKUP_TABLES>
#! </WORKSPACE>
#! 
GUI IGNORE SourceDataset_MDB_ADO_1,MDB_ADO_IN_PASSWORD_MDB_ADO_1,MDB_ADO_IN_WHERE_CLAUSE_MDB_ADO_1,MDB_ADO_IN_EXPOSE_ATTRS_GROUP_MDB_ADO_1,MDB_ADO_IN_NETWORK_AUTHENTICATION_MDB_ADO_1,MDB_ADO_IN_READ_CACHE_SIZE_MDB_ADO_1,SourceDataset_MDB_ADO_2,MDB_ADO_IN_PASSWORD_MDB_ADO_2,MDB_ADO_IN_WHERE_CLAUSE_MDB_ADO_2,MDB_ADO_IN_EXPOSE_ATTRS_GROUP_MDB_ADO_2,MDB_ADO_IN_NETWORK_AUTHENTICATION_MDB_ADO_2,MDB_ADO_IN_READ_CACHE_SIZE_MDB_ADO_2,SourceDataset_MDB_ADO_5,MDB_ADO_IN_PASSWORD_MDB_ADO_5,MDB_ADO_IN_WHERE_CLAUSE_MDB_ADO_5,MDB_ADO_IN_EXPOSE_ATTRS_GROUP_MDB_ADO_5,MDB_ADO_IN_NETWORK_AUTHENTICATION_MDB_ADO_5,MDB_ADO_IN_READ_CACHE_SIZE_MDB_ADO_5,DestDataset_MDB_ADO_3,MDB_ADO_OUT_PASSWORD_MDB_ADO_3,MDB_ADO_OUT_VERSION_MDB_ADO_3,MDB_ADO_OUT_OVERWRITE_FILE_MDB_ADO_3,MDB_ADO_OUT_COMPRESS_AT_END_MDB_ADO_3,MDB_ADO_OUT_WRITER_MODE_MDB_ADO_3,MDB_ADO_OUT_START_TRANSACTION_MDB_ADO_3,MDB_ADO_OUT_TRANSACTION_INTERVAL_MDB_ADO_3,MDB_ADO_OUT_BEGIN_SQL_MDB_ADO_3,MDB_ADO_OUT_END_SQL_MDB_ADO_3,DestDataset_MDB_ADO_4,MDB_ADO_OUT_PASSWORD_MDB_ADO_4,MDB_ADO_OUT_VERSION_MDB_ADO_4,MDB_ADO_OUT_OVERWRITE_FILE_MDB_ADO_4,MDB_ADO_OUT_COMPRESS_AT_END_MDB_ADO_4,MDB_ADO_OUT_WRITER_MODE_MDB_ADO_4,MDB_ADO_OUT_START_TRANSACTION_MDB_ADO_4,MDB_ADO_OUT_TRANSACTION_INTERVAL_MDB_ADO_4,MDB_ADO_OUT_BEGIN_SQL_MDB_ADO_4,MDB_ADO_OUT_END_SQL_MDB_ADO_4
DEFAULT_MACRO SourceDataset_MDB_ADO $(FME_MF_DIR)mdb\b_sirgas_utm.mdb
GUI MULTIFILE SourceDataset_MDB_ADO Access_Database_Files(*.mdb;*.accdb)|*.mdb;*.accdb|All_files(*)|* Source Microsoft Access Database File(s):
DEFAULT_MACRO SourceDataset_MDB_ADO_3 $(FME_MF_DIR)mdb\b_sirgas_utm.mdb
GUI MULTIFILE SourceDataset_MDB_ADO_3 Access_Database_Files(*.mdb;*.accdb)|*.mdb;*.accdb|All_files(*)|* Source Microsoft Access Database File(s):
DEFAULT_MACRO FEATURE_TYPES Veg_Cultivada_SHAPE_Index Veg_Cultivada Trilha_Picada_SHAPE_Index Trilha_Picada Trecho_Rodoviario_SHAPE_Index Trecho_Rodoviario Trecho_Massa_Dagua_SHAPE_Index Trecho_Massa_Dagua Trecho_Energia_SHAPE_Index Trecho_Energia Trecho_Duto_SHAPE_Index Trecho_Duto Trecho_Drenagem_SHAPE_Index Trecho_Drenagem Travessia_point_SHAPE_Index Travessia_point Torre_Comunic_SHAPE_Index Torre_Comunic Terreno_Suj_Inundacao_SHAPE_Index Terreno_Suj_Inundacao Terreno_Exposto_SHAPE_Index Terreno_Exposto T_1_PolyErrors_Shape_Index T_1_PolyErrors T_1_PointErrors_Shape_Index T_1_PointErrors T_1_LineErrors_Shape_Index T_1_LineErrors T_1_DirtyAreas_DirtyArea_Index T_1_DirtyAreas Sumidouro_Vertedouro_SHAPE_Index Sumidouro_Vertedouro Selections SelectedObjects Rocha_polygon_SHAPE_Index Rocha_polygon Pto_Est_Med_Fenomenos_SHAPE_Index Pto_Est_Med_Fenomenos Posto_Combustivel_point_SHAPE_Index Posto_Combustivel_point Ponto_Trecho_Energia_SHAPE_Index Ponto_Trecho_Energia Ponto_Rodoviario_Ferrov_SHAPE_Index Ponto_Rodoviario_Ferrov Ponto_Inicio_Drenagem_SHAPE_Index Ponto_Inicio_Drenagem Ponto_Duto_SHAPE_Index Ponto_Duto Ponto_Drenagem_SHAPE_Index Ponto_Drenagem Ponto_Cotado_Altimetrico_SHAPE_Index Ponto_Cotado_Altimetrico Ponte_point_SHAPE_Index Ponte_point Pista_Ponto_Pouso_polygon_SHAPE_Index Pista_Ponto_Pouso_polygon Pista_Competicao_line_SHAPE_Index Pista_Competicao_line Patio_polygon_SHAPE_Index Patio_polygon Nome_Local_SHAPE_Index Nome_Local Massa_Dagua_SHAPE_Index Massa_Dagua Limite_Massa_Dagua_SHAPE_Index Limite_Massa_Dagua Ilha_polygon_SHAPE_Index Ilha_polygon Identific_Trecho_Rod_SHAPE_Index Identific_Trecho_Rod Gruta_Caverna_point_SHAPE_Index Gruta_Caverna_point Grupo_Transform_Energ_point_SHAPE_Index Grupo_Transform_Energ_point GDB_SpatialRefs GDB_ReplicaLog GDB_ItemTypes GDB_Items_Shape_Index GDB_Items GDB_ItemRelationshipTypes GDB_ItemRelationships GDB_GeomColumns GDB_DatabaseLocks GDB_ColumnInfo Galeria_Bueiro_point_SHAPE_Index Galeria_Bueiro_point Fonte_Dagua_SHAPE_Index Fonte_Dagua Est_Gerad_Energia_Eletr_polygon_SHAPE_Index Est_Gerad_Energia_Eletr_polygon Entroncamento_SHAPE_Index Entroncamento Elemento_Fisiog_Natural_point_SHAPE_Index Elemento_Fisiog_Natural_point Elemento_Fisiog_Natural_line_SHAPE_Index Elemento_Fisiog_Natural_line Edif_Servico_Social_polygon_SHAPE_Index Edif_Servico_Social_polygon Edif_Servico_Social_point_SHAPE_Index Edif_Servico_Social_point Edif_Saude_polygon_SHAPE_Index Edif_Saude_polygon Edif_Saude_point_SHAPE_Index Edif_Saude_point Edif_Saneamento_point_SHAPE_Index Edif_Saneamento_point Edif_Rodoviaria_polygon_SHAPE_Index Edif_Rodoviaria_polygon Edif_Rodoviaria_point_SHAPE_Index Edif_Rodoviaria_point Edif_Religiosa_polygon_SHAPE_Index Edif_Religiosa_polygon Edif_Religiosa_point_SHAPE_Index Edif_Religiosa_point Edif_Pub_Militar_polygon_SHAPE_Index Edif_Pub_Militar_polygon Edif_Pub_Militar_point_SHAPE_Index Edif_Pub_Militar_point Edif_Pub_Civil_polygon_SHAPE_Index Edif_Pub_Civil_polygon Edif_Pub_Civil_point_SHAPE_Index Edif_Pub_Civil_point Edif_Industrial_polygon_SHAPE_Index Edif_Industrial_polygon Edif_Industrial_point_SHAPE_Index Edif_Industrial_point Edif_Habitacional_point_SHAPE_Index Edif_Habitacional_point Edif_Ext_Mineral_polygon_SHAPE_Index Edif_Ext_Mineral_polygon Edif_Ext_Mineral_point_SHAPE_Index Edif_Ext_Mineral_point Edif_Ensino_polygon_SHAPE_Index Edif_Ensino_polygon Edif_Ensino_point_SHAPE_Index Edif_Ensino_point Edif_Constr_Est_Med_point_SHAPE_Index Edif_Constr_Est_Med_point Edif_Const_Turistica_point_SHAPE_Index Edif_Const_Turistica_point Edif_Const_Lazer_polygon_SHAPE_Index Edif_Const_Lazer_polygon Edif_Const_Lazer_point_SHAPE_Index Edif_Const_Lazer_point Edif_Const_Aeroportuaria_point_SHAPE_Index Edif_Const_Aeroportuaria_point Edif_Comunic_point_SHAPE_Index Edif_Comunic_point Edif_Comerc_Serv_polygon_SHAPE_Index Edif_Comerc_Serv_polygon Edif_Comerc_Serv_point_SHAPE_Index Edif_Comerc_Serv_point Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index Edif_Agrop_Ext_Veg_Pesca_point Edif_Abast_Agua_point_SHAPE_Index Edif_Abast_Agua_point Deposito_Geral_polygon_SHAPE_Index Deposito_Geral_polygon Deposito_Geral_point_SHAPE_Index Deposito_Geral_point Dep_Saneamento_polygon_SHAPE_Index Dep_Saneamento_polygon Dep_Saneamento_point_SHAPE_Index Dep_Saneamento_point Dep_Abast_Agua_point_SHAPE_Index Dep_Abast_Agua_point Delimitacao_Fisica_SHAPE_Index Delimitacao_Fisica Curva_Nivel_SHAPE_Index Curva_Nivel Confluencia_SHAPE_Index Confluencia Comporta_line_SHAPE_Index Comporta_line Cidade_SHAPE_Index Cidade Cerrado_Cerradao_SHAPE_Index Cerrado_Cerradao Cemiterio_polygon_SHAPE_Index Cemiterio_polygon Cemiterio_point_SHAPE_Index Cemiterio_point Campo_SHAPE_Index Campo_Quadra_polygon_SHAPE_Index Campo_Quadra_polygon Campo_Quadra_point_SHAPE_Index Campo_Quadra_point Campo Caatinga_SHAPE_Index Caatinga Barragem_line_SHAPE_Index Barragem_line Banco_Areia_polygon_SHAPE_Index Banco_Areia_polygon Atracadouro_polygon_SHAPE_Index Atracadouro_polygon Atracadouro_point_SHAPE_Index Atracadouro_point Arruamento_SHAPE_Index Arruamento Arquibancada_point_SHAPE_Index Arquibancada_point Area_Uso_Comunitario_point_SHAPE_Index Area_Uso_Comunitario_point Area_Lazer_SHAPE_Index Area_Lazer Area_Industrial_SHAPE_Index Area_Industrial Area_Ext_Mineral_SHAPE_Index Area_Ext_Mineral Area_Energia_Eletrica_SHAPE_Index Area_Energia_Eletrica Area_Edificada_SHAPE_Index Area_Edificada Antena_Comunic_SHAPE_Index Antena_Comunic Alter_Fisiog_Antropica_line_SHAPE_Index Alter_Fisiog_Antropica_line Aglomerado_Rural_SHAPE_Index Aglomerado_Rural
GUI OPTIONAL FEATURE_TYPES FEATURE_TYPES "C:<backslash>Marcos_Batista<backslash>FME<backslash>mdb<backslash>b_sirgas_utm.mdb,_FORMAT_OVERRIDE_,MDB_ADO,_DATASET_OVERRIDE_,SourceDataset_MDB_ADO_3,EXPOSE_ATTRS_GROUP,FME_DISCLOSURE_CLOSED,READ_CACHE_SIZE,10,QUERY_FEATURE_TYPES_FOR_MERGE_FILTERS,Yes,DYNAMIC_WORKFLOW,yes,_MERGE_SCHEMAS,YES,TABLELIST,\"Aglomerado_Rural Aglomerado_Rural_SHAPE_Index Alter_Fisiog_Antropica_line Alter_Fisiog_Antropica_line_SHAPE_Index Antena_Comunic Antena_Comunic_SHAPE_Index Area_Edificada Area_Edificada_SHAPE_Index Area_Energia_Eletrica Area_Energia_Eletrica_SHAPE_Index Area_Ext_Mineral Area_Ext_Mineral_SHAPE_Index Area_Industrial Area_Industrial_SHAPE_Index Area_Lazer Area_Lazer_SHAPE_Index Area_Uso_Comunitario_point Area_Uso_Comunitario_point_SHAPE_Index Arquibancada_point Arquibancada_point_SHAPE_Index Arruamento Arruamento_SHAPE_Index Atracadouro_point Atracadouro_point_SHAPE_Index Atracadouro_polygon Atracadouro_polygon_SHAPE_Index Banco_Areia_polygon Banco_Areia_polygon_SHAPE_Index Barragem_line Barragem_line_SHAPE_Index Caatinga Caatinga_SHAPE_Index Campo Campo_Quadra_point Campo_Quadra_point_SHAPE_Index Campo_Quadra_polygon Campo_Quadra_polygon_SHAPE_Index Campo_SHAPE_Index Cemiterio_point Cemiterio_point_SHAPE_Index Cemiterio_polygon Cemiterio_polygon_SHAPE_Index Cerrado_Cerradao Cerrado_Cerradao_SHAPE_Index Cidade Cidade_SHAPE_Index Comporta_line Comporta_line_SHAPE_Index Confluencia Confluencia_SHAPE_Index Curva_Nivel Curva_Nivel_SHAPE_Index Delimitacao_Fisica Delimitacao_Fisica_SHAPE_Index Dep_Abast_Agua_point Dep_Abast_Agua_point_SHAPE_Index Dep_Saneamento_point Dep_Saneamento_point_SHAPE_Index Dep_Saneamento_polygon Dep_Saneamento_polygon_SHAPE_Index Deposito_Geral_point Deposito_Geral_point_SHAPE_Index Deposito_Geral_polygon Deposito_Geral_polygon_SHAPE_Index Edif_Abast_Agua_point Edif_Abast_Agua_point_SHAPE_Index Edif_Agrop_Ext_Veg_Pesca_point Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index Edif_Comerc_Serv_point Edif_Comerc_Serv_point_SHAPE_Index Edif_Comerc_Serv_polygon Edif_Comerc_Serv_polygon_SHAPE_Index Edif_Comunic_point Edif_Comunic_point_SHAPE_Index Edif_Const_Aeroportuaria_point Edif_Const_Aeroportuaria_point_SHAPE_Index Edif_Const_Lazer_point Edif_Const_Lazer_point_SHAPE_Index Edif_Const_Lazer_polygon Edif_Const_Lazer_polygon_SHAPE_Index Edif_Const_Turistica_point Edif_Const_Turistica_point_SHAPE_Index Edif_Constr_Est_Med_point Edif_Constr_Est_Med_point_SHAPE_Index Edif_Ensino_point Edif_Ensino_point_SHAPE_Index Edif_Ensino_polygon Edif_Ensino_polygon_SHAPE_Index Edif_Ext_Mineral_point Edif_Ext_Mineral_point_SHAPE_Index Edif_Ext_Mineral_polygon Edif_Ext_Mineral_polygon_SHAPE_Index Edif_Habitacional_point Edif_Habitacional_point_SHAPE_Index Edif_Industrial_point Edif_Industrial_point_SHAPE_Index Edif_Industrial_polygon Edif_Industrial_polygon_SHAPE_Index Edif_Pub_Civil_point Edif_Pub_Civil_point_SHAPE_Index Edif_Pub_Civil_polygon Edif_Pub_Civil_polygon_SHAPE_Index Edif_Pub_Militar_point Edif_Pub_Militar_point_SHAPE_Index Edif_Pub_Militar_polygon Edif_Pub_Militar_polygon_SHAPE_Index Edif_Religiosa_point Edif_Religiosa_point_SHAPE_Index Edif_Religiosa_polygon Edif_Religiosa_polygon_SHAPE_Index Edif_Rodoviaria_point Edif_Rodoviaria_point_SHAPE_Index Edif_Rodoviaria_polygon Edif_Rodoviaria_polygon_SHAPE_Index Edif_Saneamento_point Edif_Saneamento_point_SHAPE_Index Edif_Saude_point Edif_Saude_point_SHAPE_Index Edif_Saude_polygon Edif_Saude_polygon_SHAPE_Index Edif_Servico_Social_point Edif_Servico_Social_point_SHAPE_Index Edif_Servico_Social_polygon Edif_Servico_Social_polygon_SHAPE_Index Elemento_Fisiog_Natural_line Elemento_Fisiog_Natural_line_SHAPE_Index Elemento_Fisiog_Natural_point Elemento_Fisiog_Natural_point_SHAPE_Index Entroncamento Entroncamento_SHAPE_Index Est_Gerad_Energia_Eletr_polygon Est_Gerad_Energia_Eletr_polygon_SHAPE_Index Fonte_Dagua Fonte_Dagua_SHAPE_Index Galeria_Bueiro_point Galeria_Bueiro_point_SHAPE_Index GDB_ColumnInfo GDB_DatabaseLocks GDB_GeomColumns GDB_ItemRelationships GDB_ItemRelationshipTypes GDB_Items GDB_Items_Shape_Index GDB_ItemTypes GDB_ReplicaLog GDB_SpatialRefs Grupo_Transform_Energ_point Grupo_Transform_Energ_point_SHAPE_Index Gruta_Caverna_point Gruta_Caverna_point_SHAPE_Index Identific_Trecho_Rod Identific_Trecho_Rod_SHAPE_Index Ilha_polygon Ilha_polygon_SHAPE_Index Limite_Massa_Dagua Limite_Massa_Dagua_SHAPE_Index Massa_Dagua Massa_Dagua_SHAPE_Index Nome_Local Nome_Local_SHAPE_Index Patio_polygon Patio_polygon_SHAPE_Index Pista_Competicao_line Pista_Competicao_line_SHAPE_Index Pista_Ponto_Pouso_polygon Pista_Ponto_Pouso_polygon_SHAPE_Index Ponte_point Ponte_point_SHAPE_Index Ponto_Cotado_Altimetrico Ponto_Cotado_Altimetrico_SHAPE_Index Ponto_Drenagem Ponto_Drenagem_SHAPE_Index Ponto_Duto Ponto_Duto_SHAPE_Index Ponto_Inicio_Drenagem Ponto_Inicio_Drenagem_SHAPE_Index Ponto_Rodoviario_Ferrov Ponto_Rodoviario_Ferrov_SHAPE_Index Ponto_Trecho_Energia Ponto_Trecho_Energia_SHAPE_Index Posto_Combustivel_point Posto_Combustivel_point_SHAPE_Index Pto_Est_Med_Fenomenos Pto_Est_Med_Fenomenos_SHAPE_Index Rocha_polygon Rocha_polygon_SHAPE_Index SelectedObjects Selections Sumidouro_Vertedouro Sumidouro_Vertedouro_SHAPE_Index T_1_DirtyAreas T_1_DirtyAreas_DirtyArea_Index T_1_LineErrors T_1_LineErrors_Shape_Index T_1_PointErrors T_1_PointErrors_Shape_Index T_1_PolyErrors T_1_PolyErrors_Shape_Index Terreno_Exposto Terreno_Exposto_SHAPE_Index Terreno_Suj_Inundacao Terreno_Suj_Inundacao_SHAPE_Index Torre_Comunic Torre_Comunic_SHAPE_Index Travessia_point Travessia_point_SHAPE_Index Trecho_Drenagem Trecho_Drenagem_SHAPE_Index Trecho_Duto Trecho_Duto_SHAPE_Index Trecho_Energia Trecho_Energia_SHAPE_Index Trecho_Massa_Dagua Trecho_Massa_Dagua_SHAPE_Index Trecho_Rodoviario Trecho_Rodoviario_SHAPE_Index Trilha_Picada Trilha_Picada_SHAPE_Index Veg_Cultivada Veg_Cultivada_SHAPE_Index\",_MERGE_SCHEMAS,YES" Feature Types to Read:
DEFAULT_MACRO DestDataset_MDB_ADO $(FME_MF_DIR)mdb\b_sirgas_utm_nomeAbrev.mdb
GUI FILENAME DestDataset_MDB_ADO Access_Database_Files(*.mdb;*.accdb)|*.mdb;*.accdb|All_files(*)|* Destination Microsoft Access Database File:
DEFAULT_MACRO DestDataset_MDB_ADO_2 $(FME_MF_DIR)mdb\b_sirgas_utm_nomeAbrev.mdb
GUI FILENAME DestDataset_MDB_ADO_2 Access_Database_Files(*.mdb;*.accdb)|*.mdb;*.accdb|All_files(*)|* Destination Microsoft Access Database File:
DEFAULT_MACRO SourceDataset_MDB_ADO_4 $(FME_MF_DIR)mdb\b_sirgas_utm_NOMEABREV.mdb
GUI MULTIFILE SourceDataset_MDB_ADO_4 Access_Database_Files(*.mdb;*.accdb)|*.mdb;*.accdb|All_files(*)|* Source Microsoft Access Database File(s):
INCLUDE [ if {{$(SourceDataset_MDB_ADO)} == {}} { puts_real {Parameter 'SourceDataset_MDB_ADO' must be given a value.}; exit 1; }; ]
INCLUDE [ if {{$(SourceDataset_MDB_ADO_3)} == {}} { puts_real {Parameter 'SourceDataset_MDB_ADO_3' must be given a value.}; exit 1; }; ]
INCLUDE [ if {{$(DestDataset_MDB_ADO)} == {}} { puts_real {Parameter 'DestDataset_MDB_ADO' must be given a value.}; exit 1; }; ]
INCLUDE [ if {{$(DestDataset_MDB_ADO_2)} == {}} { puts_real {Parameter 'DestDataset_MDB_ADO_2' must be given a value.}; exit 1; }; ]
INCLUDE [ if {{$(SourceDataset_MDB_ADO_4)} == {}} { puts_real {Parameter 'SourceDataset_MDB_ADO_4' must be given a value.}; exit 1; }; ]
#! START_HEADER
#! encoding="utf-8"
#! WORKSPACE_VERSION 1
# ============================================================================ 
# 
# This mapping file was generated by FME Workbench
# on 01/28/20 09:29:04 for translation between LSL_GOTHIC and LSL_GOTHIC
# 
# This workspace was generated with FME build 15539
#
# You may edit this mapping file to customize its operation.  Comments are 
# placed throughout to assist you. 
# 
# Modification History:
# 
#     Name              Date     Description
#     ================= ======== =============================================
# 
# 
# ============================================================================ 
# ============================================================================ 
# The following line defines the title presented to the user when this
# mapping file is run through the FME GUI.  You may modify this
# if a more meaningful title would be appropriate.
GUI TITLE LSL_GOTHIC to LSL_GOTHIC Translation 
# ============================================================================ 
# The following line names the log file to which useful statistics about
# the translation will be written.  This line can be uncommented and
# updated if you do wish to keep these statistics.
# LOG_FILENAME translation.log
# LOG_APPEND NO
# ============================================================================ 
# The following line instructs the FME to log any features that do not
# match any of the source feature patterns listed further down in
# this file.  If you are modifying this mapping file, this will be
# useful to describe to you exactly which features you are losing
# during translation, if the statistics indicate that features are
# not being correlated or grouped.  Uncorrelated features do not
# match any source specification, ungrouped features do not have
# any corresponding _DEF line. 
# FME_DEBUG UNGROUPED UNCORRELATED
# ============================================================================ 
# The following two lines define the type of reader and writer to be
# used for this translation.  If you want to translate your data
# back into its original format, you may make a copy of this file
# and switch the reader and writer types.  If you rerun the FME, you
# will get your original data back again (together with any modifications
# you made in the meantime).  Note that several formats are NOT
# bi-directional (for example, GIF can only be used as a WRITER)
# so a reverse translation may not always be possible.
#! START_WB_HEADER
READER_TYPE MULTI_READER
MULTI_READER_TYPE{0} NULL
MULTI_READER_FORMAT{0} MDB_ADO
MULTI_READER_KEYWORD{0} MDB_ADO_1
MULTI_READER_GEN_DIRECTIVES{0} EXPOSE_ATTRS_GROUP,FME_DISCLOSURE_CLOSED,QUERY_FEATURE_TYPES_FOR_MERGE_FILTERS,Yes,WHERE_CLAUSE,,MDB_ADO_EXPOSE_FORMAT_ATTRS,,_MERGE_SCHEMAS,YES,TABLELIST,Aglomerado_Rural<space>Aglomerado_Rural_SHAPE_Index<space>Alter_Fisiog_Antropica_line<space>Alter_Fisiog_Antropica_line_SHAPE_Index<space>Antena_Comunic<space>Antena_Comunic_SHAPE_Index<space>Area_Edificada<space>Area_Edificada_SHAPE_Index<space>Area_Energia_Eletrica<space>Area_Energia_Eletrica_SHAPE_Index<space>Area_Ext_Mineral<space>Area_Ext_Mineral_SHAPE_Index<space>Area_Industrial<space>Area_Industrial_SHAPE_Index<space>Area_Lazer<space>Area_Lazer_SHAPE_Index<space>Area_Uso_Comunitario_point<space>Area_Uso_Comunitario_point_SHAPE_Index<space>Arquibancada_point<space>Arquibancada_point_SHAPE_Index<space>Arruamento<space>Arruamento_SHAPE_Index<space>Atracadouro_point<space>Atracadouro_point_SHAPE_Index<space>Atracadouro_polygon<space>Atracadouro_polygon_SHAPE_Index<space>Banco_Areia_polygon<space>Banco_Areia_polygon_SHAPE_Index<space>Barragem_line<space>Barragem_line_SHAPE_Index<space>Caatinga<space>Caatinga_SHAPE_Index<space>Campo<space>Campo_Quadra_point<space>Campo_Quadra_point_SHAPE_Index<space>Campo_Quadra_polygon<space>Campo_Quadra_polygon_SHAPE_Index<space>Campo_SHAPE_Index<space>Cemiterio_point<space>Cemiterio_point_SHAPE_Index<space>Cemiterio_polygon<space>Cemiterio_polygon_SHAPE_Index<space>Cerrado_Cerradao<space>Cerrado_Cerradao_SHAPE_Index<space>Cidade<space>Cidade_SHAPE_Index<space>Comporta_line<space>Comporta_line_SHAPE_Index<space>Confluencia<space>Confluencia_SHAPE_Index<space>Curva_Nivel<space>Curva_Nivel_SHAPE_Index<space>Delimitacao_Fisica<space>Delimitacao_Fisica_SHAPE_Index<space>Dep_Abast_Agua_point<space>Dep_Abast_Agua_point_SHAPE_Index<space>Dep_Saneamento_point<space>Dep_Saneamento_point_SHAPE_Index<space>Dep_Saneamento_polygon<space>Dep_Saneamento_polygon_SHAPE_Index<space>Deposito_Geral_point<space>Deposito_Geral_point_SHAPE_Index<space>Deposito_Geral_polygon<space>Deposito_Geral_polygon_SHAPE_Index<space>Edif_Abast_Agua_point<space>Edif_Abast_Agua_point_SHAPE_Index<space>Edif_Agrop_Ext_Veg_Pesca_point<space>Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index<space>Edif_Comerc_Serv_point<space>Edif_Comerc_Serv_point_SHAPE_Index<space>Edif_Comerc_Serv_polygon<space>Edif_Comerc_Serv_polygon_SHAPE_Index<space>Edif_Comunic_point<space>Edif_Comunic_point_SHAPE_Index<space>Edif_Const_Aeroportuaria_point<space>Edif_Const_Aeroportuaria_point_SHAPE_Index<space>Edif_Const_Lazer_point<space>Edif_Const_Lazer_point_SHAPE_Index<space>Edif_Const_Lazer_polygon<space>Edif_Const_Lazer_polygon_SHAPE_Index<space>Edif_Const_Turistica_point<space>Edif_Const_Turistica_point_SHAPE_Index<space>Edif_Constr_Est_Med_point<space>Edif_Constr_Est_Med_point_SHAPE_Index<space>Edif_Ensino_point<space>Edif_Ensino_point_SHAPE_Index<space>Edif_Ensino_polygon<space>Edif_Ensino_polygon_SHAPE_Index<space>Edif_Ext_Mineral_point<space>Edif_Ext_Mineral_point_SHAPE_Index<space>Edif_Ext_Mineral_polygon<space>Edif_Ext_Mineral_polygon_SHAPE_Index<space>Edif_Habitacional_point<space>Edif_Habitacional_point_SHAPE_Index<space>Edif_Industrial_point<space>Edif_Industrial_point_SHAPE_Index<space>Edif_Industrial_polygon<space>Edif_Industrial_polygon_SHAPE_Index<space>Edif_Pub_Civil_point<space>Edif_Pub_Civil_point_SHAPE_Index<space>Edif_Pub_Civil_polygon<space>Edif_Pub_Civil_polygon_SHAPE_Index<space>Edif_Pub_Militar_point<space>Edif_Pub_Militar_point_SHAPE_Index<space>Edif_Pub_Militar_polygon<space>Edif_Pub_Militar_polygon_SHAPE_Index<space>Edif_Religiosa_point<space>Edif_Religiosa_point_SHAPE_Index<space>Edif_Religiosa_polygon<space>Edif_Religiosa_polygon_SHAPE_Index<space>Edif_Rodoviaria_point<space>Edif_Rodoviaria_point_SHAPE_Index<space>Edif_Rodoviaria_polygon<space>Edif_Rodoviaria_polygon_SHAPE_Index<space>Edif_Saneamento_point<space>Edif_Saneamento_point_SHAPE_Index<space>Edif_Saude_point<space>Edif_Saude_point_SHAPE_Index<space>Edif_Saude_polygon<space>Edif_Saude_polygon_SHAPE_Index<space>Edif_Servico_Social_point<space>Edif_Servico_Social_point_SHAPE_Index<space>Edif_Servico_Social_polygon<space>Edif_Servico_Social_polygon_SHAPE_Index<space>Elemento_Fisiog_Natural_line<space>Elemento_Fisiog_Natural_line_SHAPE_Index<space>Elemento_Fisiog_Natural_point<space>Elemento_Fisiog_Natural_point_SHAPE_Index<space>Entroncamento<space>Entroncamento_SHAPE_Index<space>Est_Gerad_Energia_Eletr_polygon<space>Est_Gerad_Energia_Eletr_polygon_SHAPE_Index<space>Fonte_Dagua<space>Fonte_Dagua_SHAPE_Index<space>Galeria_Bueiro_point<space>Galeria_Bueiro_point_SHAPE_Index<space>GDB_ColumnInfo<space>GDB_DatabaseLocks<space>GDB_GeomColumns<space>GDB_ItemRelationships<space>GDB_ItemRelationshipTypes<space>GDB_Items<space>GDB_Items_Shape_Index<space>GDB_ItemTypes<space>GDB_ReplicaLog<space>GDB_SpatialRefs<space>Grupo_Transform_Energ_point<space>Grupo_Transform_Energ_point_SHAPE_Index<space>Gruta_Caverna_point<space>Gruta_Caverna_point_SHAPE_Index<space>Identific_Trecho_Rod<space>Identific_Trecho_Rod_SHAPE_Index<space>Ilha_polygon<space>Ilha_polygon_SHAPE_Index<space>Limite_Massa_Dagua<space>Limite_Massa_Dagua_SHAPE_Index<space>Massa_Dagua<space>Massa_Dagua_SHAPE_Index<space>Nome_Local<space>Nome_Local_SHAPE_Index<space>Patio_polygon<space>Patio_polygon_SHAPE_Index<space>Pista_Competicao_line<space>Pista_Competicao_line_SHAPE_Index<space>Pista_Ponto_Pouso_polygon<space>Pista_Ponto_Pouso_polygon_SHAPE_Index<space>Ponte_point<space>Ponte_point_SHAPE_Index<space>Ponto_Cotado_Altimetrico<space>Ponto_Cotado_Altimetrico_SHAPE_Index<space>Ponto_Drenagem<space>Ponto_Drenagem_SHAPE_Index<space>Ponto_Duto<space>Ponto_Duto_SHAPE_Index<space>Ponto_Inicio_Drenagem<space>Ponto_Inicio_Drenagem_SHAPE_Index<space>Ponto_Rodoviario_Ferrov<space>Ponto_Rodoviario_Ferrov_SHAPE_Index<space>Ponto_Trecho_Energia<space>Ponto_Trecho_Energia_SHAPE_Index<space>Posto_Combustivel_point<space>Posto_Combustivel_point_SHAPE_Index<space>Pto_Est_Med_Fenomenos<space>Pto_Est_Med_Fenomenos_SHAPE_Index<space>Rocha_polygon<space>Rocha_polygon_SHAPE_Index<space>SelectedObjects<space>Selections<space>Sumidouro_Vertedouro<space>Sumidouro_Vertedouro_SHAPE_Index<space>T_1_DirtyAreas<space>T_1_DirtyAreas_DirtyArea_Index<space>T_1_LineErrors<space>T_1_LineErrors_Shape_Index<space>T_1_PointErrors<space>T_1_PointErrors_Shape_Index<space>T_1_PolyErrors<space>T_1_PolyErrors_Shape_Index<space>Terreno_Exposto<space>Terreno_Exposto_SHAPE_Index<space>Terreno_Suj_Inundacao<space>Terreno_Suj_Inundacao_SHAPE_Index<space>Torre_Comunic<space>Torre_Comunic_SHAPE_Index<space>Travessia_point<space>Travessia_point_SHAPE_Index<space>Trecho_Drenagem<space>Trecho_Drenagem_SHAPE_Index<space>Trecho_Duto<space>Trecho_Duto_SHAPE_Index<space>Trecho_Energia<space>Trecho_Energia_SHAPE_Index<space>Trecho_Massa_Dagua<space>Trecho_Massa_Dagua_SHAPE_Index<space>Trecho_Rodoviario<space>Trecho_Rodoviario_SHAPE_Index<space>Trilha_Picada<space>Trilha_Picada_SHAPE_Index<space>Veg_Cultivada<space>Veg_Cultivada_SHAPE_Index,FME_CONNECTION_GROUP,
MULTI_READER_TYPE{1} NULL
MULTI_READER_FORMAT{1} MDB_ADO
MULTI_READER_KEYWORD{1} MDB_ADO_2
MULTI_READER_GEN_DIRECTIVES{1} EXPOSE_ATTRS_GROUP,FME_DISCLOSURE_CLOSED,QUERY_FEATURE_TYPES_FOR_MERGE_FILTERS,Yes,DYNAMIC_WORKFLOW,yes,WHERE_CLAUSE,,MDB_ADO_EXPOSE_FORMAT_ATTRS,,_MERGE_SCHEMAS,YES,TABLELIST,Aglomerado_Rural<space>Aglomerado_Rural_SHAPE_Index<space>Alter_Fisiog_Antropica_line<space>Alter_Fisiog_Antropica_line_SHAPE_Index<space>Antena_Comunic<space>Antena_Comunic_SHAPE_Index<space>Area_Edificada<space>Area_Edificada_SHAPE_Index<space>Area_Energia_Eletrica<space>Area_Energia_Eletrica_SHAPE_Index<space>Area_Ext_Mineral<space>Area_Ext_Mineral_SHAPE_Index<space>Area_Industrial<space>Area_Industrial_SHAPE_Index<space>Area_Lazer<space>Area_Lazer_SHAPE_Index<space>Area_Uso_Comunitario_point<space>Area_Uso_Comunitario_point_SHAPE_Index<space>Arquibancada_point<space>Arquibancada_point_SHAPE_Index<space>Arruamento<space>Arruamento_SHAPE_Index<space>Atracadouro_point<space>Atracadouro_point_SHAPE_Index<space>Atracadouro_polygon<space>Atracadouro_polygon_SHAPE_Index<space>Banco_Areia_polygon<space>Banco_Areia_polygon_SHAPE_Index<space>Barragem_line<space>Barragem_line_SHAPE_Index<space>Caatinga<space>Caatinga_SHAPE_Index<space>Campo<space>Campo_Quadra_point<space>Campo_Quadra_point_SHAPE_Index<space>Campo_Quadra_polygon<space>Campo_Quadra_polygon_SHAPE_Index<space>Campo_SHAPE_Index<space>Cemiterio_point<space>Cemiterio_point_SHAPE_Index<space>Cemiterio_polygon<space>Cemiterio_polygon_SHAPE_Index<space>Cerrado_Cerradao<space>Cerrado_Cerradao_SHAPE_Index<space>Cidade<space>Cidade_SHAPE_Index<space>Comporta_line<space>Comporta_line_SHAPE_Index<space>Confluencia<space>Confluencia_SHAPE_Index<space>Curva_Nivel<space>Curva_Nivel_SHAPE_Index<space>Delimitacao_Fisica<space>Delimitacao_Fisica_SHAPE_Index<space>Dep_Abast_Agua_point<space>Dep_Abast_Agua_point_SHAPE_Index<space>Dep_Saneamento_point<space>Dep_Saneamento_point_SHAPE_Index<space>Dep_Saneamento_polygon<space>Dep_Saneamento_polygon_SHAPE_Index<space>Deposito_Geral_point<space>Deposito_Geral_point_SHAPE_Index<space>Deposito_Geral_polygon<space>Deposito_Geral_polygon_SHAPE_Index<space>Edif_Abast_Agua_point<space>Edif_Abast_Agua_point_SHAPE_Index<space>Edif_Agrop_Ext_Veg_Pesca_point<space>Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index<space>Edif_Comerc_Serv_point<space>Edif_Comerc_Serv_point_SHAPE_Index<space>Edif_Comerc_Serv_polygon<space>Edif_Comerc_Serv_polygon_SHAPE_Index<space>Edif_Comunic_point<space>Edif_Comunic_point_SHAPE_Index<space>Edif_Const_Aeroportuaria_point<space>Edif_Const_Aeroportuaria_point_SHAPE_Index<space>Edif_Const_Lazer_point<space>Edif_Const_Lazer_point_SHAPE_Index<space>Edif_Const_Lazer_polygon<space>Edif_Const_Lazer_polygon_SHAPE_Index<space>Edif_Const_Turistica_point<space>Edif_Const_Turistica_point_SHAPE_Index<space>Edif_Constr_Est_Med_point<space>Edif_Constr_Est_Med_point_SHAPE_Index<space>Edif_Ensino_point<space>Edif_Ensino_point_SHAPE_Index<space>Edif_Ensino_polygon<space>Edif_Ensino_polygon_SHAPE_Index<space>Edif_Ext_Mineral_point<space>Edif_Ext_Mineral_point_SHAPE_Index<space>Edif_Ext_Mineral_polygon<space>Edif_Ext_Mineral_polygon_SHAPE_Index<space>Edif_Habitacional_point<space>Edif_Habitacional_point_SHAPE_Index<space>Edif_Industrial_point<space>Edif_Industrial_point_SHAPE_Index<space>Edif_Industrial_polygon<space>Edif_Industrial_polygon_SHAPE_Index<space>Edif_Pub_Civil_point<space>Edif_Pub_Civil_point_SHAPE_Index<space>Edif_Pub_Civil_polygon<space>Edif_Pub_Civil_polygon_SHAPE_Index<space>Edif_Pub_Militar_point<space>Edif_Pub_Militar_point_SHAPE_Index<space>Edif_Pub_Militar_polygon<space>Edif_Pub_Militar_polygon_SHAPE_Index<space>Edif_Religiosa_point<space>Edif_Religiosa_point_SHAPE_Index<space>Edif_Religiosa_polygon<space>Edif_Religiosa_polygon_SHAPE_Index<space>Edif_Rodoviaria_point<space>Edif_Rodoviaria_point_SHAPE_Index<space>Edif_Rodoviaria_polygon<space>Edif_Rodoviaria_polygon_SHAPE_Index<space>Edif_Saneamento_point<space>Edif_Saneamento_point_SHAPE_Index<space>Edif_Saude_point<space>Edif_Saude_point_SHAPE_Index<space>Edif_Saude_polygon<space>Edif_Saude_polygon_SHAPE_Index<space>Edif_Servico_Social_point<space>Edif_Servico_Social_point_SHAPE_Index<space>Edif_Servico_Social_polygon<space>Edif_Servico_Social_polygon_SHAPE_Index<space>Elemento_Fisiog_Natural_line<space>Elemento_Fisiog_Natural_line_SHAPE_Index<space>Elemento_Fisiog_Natural_point<space>Elemento_Fisiog_Natural_point_SHAPE_Index<space>Entroncamento<space>Entroncamento_SHAPE_Index<space>Est_Gerad_Energia_Eletr_polygon<space>Est_Gerad_Energia_Eletr_polygon_SHAPE_Index<space>Fonte_Dagua<space>Fonte_Dagua_SHAPE_Index<space>Galeria_Bueiro_point<space>Galeria_Bueiro_point_SHAPE_Index<space>GDB_ColumnInfo<space>GDB_DatabaseLocks<space>GDB_GeomColumns<space>GDB_ItemRelationships<space>GDB_ItemRelationshipTypes<space>GDB_Items<space>GDB_Items_Shape_Index<space>GDB_ItemTypes<space>GDB_ReplicaLog<space>GDB_SpatialRefs<space>Grupo_Transform_Energ_point<space>Grupo_Transform_Energ_point_SHAPE_Index<space>Gruta_Caverna_point<space>Gruta_Caverna_point_SHAPE_Index<space>Identific_Trecho_Rod<space>Identific_Trecho_Rod_SHAPE_Index<space>Ilha_polygon<space>Ilha_polygon_SHAPE_Index<space>Limite_Massa_Dagua<space>Limite_Massa_Dagua_SHAPE_Index<space>Massa_Dagua<space>Massa_Dagua_SHAPE_Index<space>Nome_Local<space>Nome_Local_SHAPE_Index<space>Patio_polygon<space>Patio_polygon_SHAPE_Index<space>Pista_Competicao_line<space>Pista_Competicao_line_SHAPE_Index<space>Pista_Ponto_Pouso_polygon<space>Pista_Ponto_Pouso_polygon_SHAPE_Index<space>Ponte_point<space>Ponte_point_SHAPE_Index<space>Ponto_Cotado_Altimetrico<space>Ponto_Cotado_Altimetrico_SHAPE_Index<space>Ponto_Drenagem<space>Ponto_Drenagem_SHAPE_Index<space>Ponto_Duto<space>Ponto_Duto_SHAPE_Index<space>Ponto_Inicio_Drenagem<space>Ponto_Inicio_Drenagem_SHAPE_Index<space>Ponto_Rodoviario_Ferrov<space>Ponto_Rodoviario_Ferrov_SHAPE_Index<space>Ponto_Trecho_Energia<space>Ponto_Trecho_Energia_SHAPE_Index<space>Posto_Combustivel_point<space>Posto_Combustivel_point_SHAPE_Index<space>Pto_Est_Med_Fenomenos<space>Pto_Est_Med_Fenomenos_SHAPE_Index<space>Rocha_polygon<space>Rocha_polygon_SHAPE_Index<space>SelectedObjects<space>Selections<space>Sumidouro_Vertedouro<space>Sumidouro_Vertedouro_SHAPE_Index<space>T_1_DirtyAreas<space>T_1_DirtyAreas_DirtyArea_Index<space>T_1_LineErrors<space>T_1_LineErrors_Shape_Index<space>T_1_PointErrors<space>T_1_PointErrors_Shape_Index<space>T_1_PolyErrors<space>T_1_PolyErrors_Shape_Index<space>Terreno_Exposto<space>Terreno_Exposto_SHAPE_Index<space>Terreno_Suj_Inundacao<space>Terreno_Suj_Inundacao_SHAPE_Index<space>Torre_Comunic<space>Torre_Comunic_SHAPE_Index<space>Travessia_point<space>Travessia_point_SHAPE_Index<space>Trecho_Drenagem<space>Trecho_Drenagem_SHAPE_Index<space>Trecho_Duto<space>Trecho_Duto_SHAPE_Index<space>Trecho_Energia<space>Trecho_Energia_SHAPE_Index<space>Trecho_Massa_Dagua<space>Trecho_Massa_Dagua_SHAPE_Index<space>Trecho_Rodoviario<space>Trecho_Rodoviario_SHAPE_Index<space>Trilha_Picada<space>Trilha_Picada_SHAPE_Index<space>Veg_Cultivada<space>Veg_Cultivada_SHAPE_Index,FME_CONNECTION_GROUP,
MULTI_READER_TYPE{2} MDB_ADO
MULTI_READER_KEYWORD{2} MDB_ADO_5
MULTI_READER_GEN_DIRECTIVES{2} TABLELIST,Dep_Abast_Agua_point,_MERGE_SCHEMAS,YES,FME_CONNECTION_GROUP,,WHERE_CLAUSE,,QUERY_FEATURE_TYPES_FOR_MERGE_FILTERS,Yes,MDB_ADO_EXPOSE_FORMAT_ATTRS,,EXPOSE_ATTRS_GROUP,
WRITER_TYPE MULTI_WRITER
MULTI_WRITER_DATASET_ORDER BY_ID
MULTI_WRITER_FIRST_WRITER_ID 0
MULTI_WRITER_TYPE{0} MDB_ADO
MULTI_WRITER_KEYWORD{0} MDB_ADO_3
MULTI_WRITER_TYPE{1} MDB_ADO
MULTI_WRITER_KEYWORD{1} MDB_ADO_4
#! END_WB_HEADER
#! START_WB_HEADER
MACRO WB_KEYWORD "MDB_ADO_1"
#! END_WB_HEADER
#! START_SOURCE_HEADER MDB_ADO MDB_ADO_1
# ============================================================================
# First get the dataset for the database. For Access, it's the database file.
# For now we'll use whatever they had when they generated this mapping file,
# and not reprompt
# The dataset this mapping file was generated from was:
#! END_SOURCE_HEADER
#! START_WB_HEADER
DEFAULT_MACRO SourceDataset
INCLUDE [ if {{$(SourceDataset)} != ""} {                        \
 puts {DEFAULT_MACRO SourceDataset_MDB_ADO_1 $(SourceDataset)}     \
 } ]
#! END_WB_HEADER
#! START_SOURCE_HEADER MDB_ADO MDB_ADO_1
DEFAULT_MACRO SourceDataset_MDB_ADO_1 $(SourceDataset_MDB_ADO)
GUI MULTIFILE SourceDataset_MDB_ADO_1 Access_Database_Files(*.mdb;*.accdb)|*.mdb;*.accdb|All_files(*)|* Source Microsoft Access Database File(s):
DEFAULT_MACRO MDB_ADO_IN_QUERY_FEATURE_TYPES_FOR_MERGE_FILTERS_MDB_ADO_1 Yes
MDB_ADO_1_QUERY_FEATURE_TYPES_FOR_MERGE_FILTERS "$(MDB_ADO_IN_QUERY_FEATURE_TYPES_FOR_MERGE_FILTERS_MDB_ADO_1)"
# ===========================================================================
# Optional Password
DEFAULT_MACRO MDB_ADO_IN_PASSWORD_MDB_ADO_1 
MDB_ADO_1_PASSWORD "$(MDB_ADO_IN_PASSWORD_MDB_ADO_1)"
GUI OPTIONAL PASSWORD MDB_ADO_IN_PASSWORD_MDB_ADO_1 Password:
# ===========================================================================
# Optional global WHERE clause
DEFAULT_MACRO MDB_ADO_IN_WHERE_CLAUSE_MDB_ADO_1 
MDB_ADO_1_WHERE_CLAUSE "$(MDB_ADO_IN_WHERE_CLAUSE_MDB_ADO_1)"
GUI OPTIONAL TEXT MDB_ADO_IN_WHERE_CLAUSE_MDB_ADO_1 WHERE Clause:
DEFAULT_MACRO MDB_ADO_IN_EXPOSE_ATTRS_GROUP_MDB_ADO_1 FME_DISCLOSURE_CLOSED
MDB_ADO_1_EXPOSE_ATTRS_GROUP "$(MDB_ADO_IN_EXPOSE_ATTRS_GROUP_MDB_ADO_1)"
GUI DISCLOSUREGROUP MDB_ADO_IN_EXPOSE_ATTRS_GROUP_MDB_ADO_1 MDB_ADO_EXPOSE_FORMAT_ATTRS Schema Attributes
# ===========================================================================
DEFAULT_MACRO MDB_ADO_IN_NETWORK_AUTHENTICATION_MDB_ADO_1 
MDB_ADO_1_NETWORK_AUTHENTICATION "$(MDB_ADO_IN_NETWORK_AUTHENTICATION_MDB_ADO_1)"
GUI OPTIONAL AUTHENTICATOR MDB_ADO_IN_NETWORK_AUTHENTICATION_MDB_ADO_1 CONTAINER%GROUP%CONTAINER_TITLE%"Network Authentication"%PROMPT_TYPE%NETWORK Network Authentication
# ============================================================================
# This keyword controls how many records to retrieve at one time into local
# memory from the provider
DEFAULT_MACRO MDB_ADO_IN_READ_CACHE_SIZE_MDB_ADO_1 10
GUI OPTIONAL TEXT MDB_ADO_IN_READ_CACHE_SIZE_MDB_ADO_1 Number Of Records To Fetch At A Time:
MDB_ADO_1_READ_CACHE_SIZE $(MDB_ADO_IN_READ_CACHE_SIZE_MDB_ADO_1)
MDB_ADO_1_DATASET "$(SourceDataset_MDB_ADO_1)"
#! END_SOURCE_HEADER
#! START_WB_HEADER
MACRO WB_KEYWORD "MDB_ADO_2"
#! END_WB_HEADER
#! START_SOURCE_HEADER MDB_ADO MDB_ADO_2
MDB_ADO_2_DYNAMIC_WORKFLOW YES
# ============================================================================
# First get the dataset for the database. For Access, it's the database file.
# For now we'll use whatever they had when they generated this mapping file,
# and not reprompt
# The dataset this mapping file was generated from was:
#! END_SOURCE_HEADER
#! START_WB_HEADER
DEFAULT_MACRO SourceDataset
INCLUDE [ if {{$(SourceDataset)} != ""} {                        \
 puts {DEFAULT_MACRO SourceDataset_MDB_ADO_2 $(SourceDataset)}     \
 } ]
#! END_WB_HEADER
#! START_SOURCE_HEADER MDB_ADO MDB_ADO_2
DEFAULT_MACRO SourceDataset_MDB_ADO_2 $(SourceDataset_MDB_ADO_3)
GUI MULTIFILE SourceDataset_MDB_ADO_2 Access_Database_Files(*.mdb;*.accdb)|*.mdb;*.accdb|All_files(*)|* Source Microsoft Access Database File(s):
DEFAULT_MACRO MDB_ADO_IN_QUERY_FEATURE_TYPES_FOR_MERGE_FILTERS_MDB_ADO_2 Yes
MDB_ADO_2_QUERY_FEATURE_TYPES_FOR_MERGE_FILTERS "$(MDB_ADO_IN_QUERY_FEATURE_TYPES_FOR_MERGE_FILTERS_MDB_ADO_2)"
# ===========================================================================
# Optional Password
DEFAULT_MACRO MDB_ADO_IN_PASSWORD_MDB_ADO_2 
MDB_ADO_2_PASSWORD "$(MDB_ADO_IN_PASSWORD_MDB_ADO_2)"
GUI OPTIONAL PASSWORD MDB_ADO_IN_PASSWORD_MDB_ADO_2 Password:
# ===========================================================================
# Optional global WHERE clause
DEFAULT_MACRO MDB_ADO_IN_WHERE_CLAUSE_MDB_ADO_2 
MDB_ADO_2_WHERE_CLAUSE "$(MDB_ADO_IN_WHERE_CLAUSE_MDB_ADO_2)"
GUI OPTIONAL TEXT MDB_ADO_IN_WHERE_CLAUSE_MDB_ADO_2 WHERE Clause:
DEFAULT_MACRO MDB_ADO_IN_EXPOSE_ATTRS_GROUP_MDB_ADO_2 FME_DISCLOSURE_CLOSED
MDB_ADO_2_EXPOSE_ATTRS_GROUP "$(MDB_ADO_IN_EXPOSE_ATTRS_GROUP_MDB_ADO_2)"
GUI DISCLOSUREGROUP MDB_ADO_IN_EXPOSE_ATTRS_GROUP_MDB_ADO_2 MDB_ADO_EXPOSE_FORMAT_ATTRS Schema Attributes
# ===========================================================================
DEFAULT_MACRO MDB_ADO_IN_NETWORK_AUTHENTICATION_MDB_ADO_2 
MDB_ADO_2_NETWORK_AUTHENTICATION "$(MDB_ADO_IN_NETWORK_AUTHENTICATION_MDB_ADO_2)"
GUI OPTIONAL AUTHENTICATOR MDB_ADO_IN_NETWORK_AUTHENTICATION_MDB_ADO_2 CONTAINER%GROUP%CONTAINER_TITLE%"Network Authentication"%PROMPT_TYPE%NETWORK Network Authentication
# ============================================================================
# This keyword controls how many records to retrieve at one time into local
# memory from the provider
DEFAULT_MACRO MDB_ADO_IN_READ_CACHE_SIZE_MDB_ADO_2 10
GUI OPTIONAL TEXT MDB_ADO_IN_READ_CACHE_SIZE_MDB_ADO_2 Number Of Records To Fetch At A Time:
MDB_ADO_2_READ_CACHE_SIZE $(MDB_ADO_IN_READ_CACHE_SIZE_MDB_ADO_2)
MDB_ADO_2_DATASET "$(SourceDataset_MDB_ADO_2)"
#! END_SOURCE_HEADER
#! START_WB_HEADER
MACRO WB_KEYWORD "MDB_ADO_5"
#! END_WB_HEADER
#! START_SOURCE_HEADER MDB_ADO MDB_ADO_5
# ============================================================================
# First get the dataset for the database. For Access, it's the database file.
# For now we'll use whatever they had when they generated this mapping file,
# and not reprompt
# The dataset this mapping file was generated from was:
#! END_SOURCE_HEADER
#! START_WB_HEADER
DEFAULT_MACRO SourceDataset
INCLUDE [ if {{$(SourceDataset)} != ""} {                        \
 puts {DEFAULT_MACRO SourceDataset_MDB_ADO_5 $(SourceDataset)}     \
 } ]
#! END_WB_HEADER
#! START_SOURCE_HEADER MDB_ADO MDB_ADO_5
DEFAULT_MACRO SourceDataset_MDB_ADO_5 $(SourceDataset_MDB_ADO_4)
GUI MULTIFILE SourceDataset_MDB_ADO_5 Access_Database_Files(*.mdb;*.accdb)|*.mdb;*.accdb|All_files(*)|* Source Microsoft Access Database File(s):
DEFAULT_MACRO MDB_ADO_IN_QUERY_FEATURE_TYPES_FOR_MERGE_FILTERS_MDB_ADO_5 Yes
MDB_ADO_5_QUERY_FEATURE_TYPES_FOR_MERGE_FILTERS "$(MDB_ADO_IN_QUERY_FEATURE_TYPES_FOR_MERGE_FILTERS_MDB_ADO_5)"
# ===========================================================================
# Optional Password
DEFAULT_MACRO MDB_ADO_IN_PASSWORD_MDB_ADO_5 
MDB_ADO_5_PASSWORD "$(MDB_ADO_IN_PASSWORD_MDB_ADO_5)"
GUI OPTIONAL PASSWORD MDB_ADO_IN_PASSWORD_MDB_ADO_5 Password:
# ===========================================================================
# Optional global WHERE clause
DEFAULT_MACRO MDB_ADO_IN_WHERE_CLAUSE_MDB_ADO_5 
MDB_ADO_5_WHERE_CLAUSE "$(MDB_ADO_IN_WHERE_CLAUSE_MDB_ADO_5)"
GUI OPTIONAL TEXT MDB_ADO_IN_WHERE_CLAUSE_MDB_ADO_5 WHERE Clause:
DEFAULT_MACRO MDB_ADO_IN_EXPOSE_ATTRS_GROUP_MDB_ADO_5 
MDB_ADO_5_EXPOSE_ATTRS_GROUP "$(MDB_ADO_IN_EXPOSE_ATTRS_GROUP_MDB_ADO_5)"
GUI DISCLOSUREGROUP MDB_ADO_IN_EXPOSE_ATTRS_GROUP_MDB_ADO_5 MDB_ADO_EXPOSE_FORMAT_ATTRS Schema Attributes
# ===========================================================================
DEFAULT_MACRO MDB_ADO_IN_NETWORK_AUTHENTICATION_MDB_ADO_5 
MDB_ADO_5_NETWORK_AUTHENTICATION "$(MDB_ADO_IN_NETWORK_AUTHENTICATION_MDB_ADO_5)"
GUI OPTIONAL AUTHENTICATOR MDB_ADO_IN_NETWORK_AUTHENTICATION_MDB_ADO_5 CONTAINER%GROUP%CONTAINER_TITLE%"Network Authentication"%PROMPT_TYPE%NETWORK Network Authentication
# ============================================================================
# This keyword controls how many records to retrieve at one time into local
# memory from the provider
DEFAULT_MACRO MDB_ADO_IN_READ_CACHE_SIZE_MDB_ADO_5 10
GUI OPTIONAL TEXT MDB_ADO_IN_READ_CACHE_SIZE_MDB_ADO_5 Number Of Records To Fetch At A Time:
MDB_ADO_5_READ_CACHE_SIZE $(MDB_ADO_IN_READ_CACHE_SIZE_MDB_ADO_5)
MDB_ADO_5_DATASET "$(SourceDataset_MDB_ADO_5)"
#! END_SOURCE_HEADER
#! START_WB_HEADER
MACRO WB_KEYWORD "MDB_ADO_3"
#! END_WB_HEADER
#! START_DEST_HEADER MDB_ADO MDB_ADO_3
# ============================================================================
# First get the dataset for the database. For Access, it's the database file.
# For now we'll use whatever they had when they generated this mapping file,
# and not reprompt
#! END_DEST_HEADER
#! START_WB_HEADER
DEFAULT_MACRO DestDataset
INCLUDE [ if {"$(DestDataset)" != ""} {                          \
 puts {DEFAULT_MACRO DestDataset_MDB_ADO_3 $(DestDataset)}         \
 } ]
#! END_WB_HEADER
#! START_DEST_HEADER MDB_ADO MDB_ADO_3
DEFAULT_MACRO DestDataset_MDB_ADO_3 $(DestDataset_MDB_ADO)
GUI FILENAME DestDataset_MDB_ADO_3 Access_Database_Files(*.mdb;*.accdb)|*.mdb;*.accdb|All_files(*)|* Destination Microsoft Access Database File:
# ===========================================================================
# Optional Password
DEFAULT_MACRO MDB_ADO_OUT_PASSWORD_MDB_ADO_3 
MDB_ADO_3_PASSWORD "$(MDB_ADO_OUT_PASSWORD_MDB_ADO_3)"
GUI OPTIONAL PASSWORD MDB_ADO_OUT_PASSWORD_MDB_ADO_3 Password:
# ===========================================================================
# Optional Version (defaultsto2000/2002/2003)
DEFAULT_MACRO MDB_ADO_OUT_VERSION_MDB_ADO_3 2000/2002/2003
MDB_ADO_3_VERSION "$(MDB_ADO_OUT_VERSION_MDB_ADO_3)"
GUI CHOICE MDB_ADO_OUT_VERSION_MDB_ADO_3 2007%2000/2002/2003%95/97%2.0 Version:
# ============================================================================
# Whether or not to overwrite the file
DEFAULT_MACRO MDB_ADO_OUT_OVERWRITE_FILE_MDB_ADO_3 No
MDB_ADO_3_OVERWRITE_FILE "$(MDB_ADO_OUT_OVERWRITE_FILE_MDB_ADO_3)"
GUI CHOICE MDB_ADO_OUT_OVERWRITE_FILE_MDB_ADO_3 Yes%No Overwrite Existing Database:
# ============================================================================
# Opt in for destination dataset type vs format type validation
DEFAULT_MACRO MDB_ADO_OUT_DESTINATION_DATASETTYPE_VALIDATION_MDB_ADO_3 Yes
MDB_ADO_3_DESTINATION_DATASETTYPE_VALIDATION "$(MDB_ADO_OUT_DESTINATION_DATASETTYPE_VALIDATION_MDB_ADO_3)"
# ============================================================================
# For database compression
DEFAULT_MACRO MDB_ADO_OUT_COMPRESS_AT_END_MDB_ADO_3 no
GUI CHOICE MDB_ADO_OUT_COMPRESS_AT_END_MDB_ADO_3 yes%no Compress Database When Done:
MDB_ADO_3_COMPRESS_AT_END $(MDB_ADO_OUT_COMPRESS_AT_END_MDB_ADO_3)
# ============================================================================
# This keyword sets the mode of the writer
DEFAULT_MACRO MDB_ADO_OUT_WRITER_MODE_MDB_ADO_3 INSERT
GUI CHOICE MDB_ADO_OUT_WRITER_MODE_MDB_ADO_3 INSERT%UPDATE%DELETE Writer Mode:
MDB_ADO_3_WRITER_MODE $(MDB_ADO_OUT_WRITER_MODE_MDB_ADO_3)
# ============================================================================
# This keyword sets the starting transaction
DEFAULT_MACRO MDB_ADO_OUT_START_TRANSACTION_MDB_ADO_3 0
GUI OPTIONAL TEXT MDB_ADO_OUT_START_TRANSACTION_MDB_ADO_3 Start transaction at:
MDB_ADO_3_START_TRANSACTION $(MDB_ADO_OUT_START_TRANSACTION_MDB_ADO_3)
# ============================================================================
# This keyword sets the number of features between transaction commits
DEFAULT_MACRO MDB_ADO_OUT_TRANSACTION_INTERVAL_MDB_ADO_3 500
GUI OPTIONAL TEXT MDB_ADO_OUT_TRANSACTION_INTERVAL_MDB_ADO_3 Transaction interval:
MDB_ADO_3_TRANSACTION_INTERVAL $(MDB_ADO_OUT_TRANSACTION_INTERVAL_MDB_ADO_3)
# ============================================================================
# The following specifies an SQL command to execute before opening the first
# table.
DEFAULT_MACRO MDB_ADO_OUT_BEGIN_SQL_MDB_ADO_3 
GUI OPTIONAL TEXT_EDIT_SQL MDB_ADO_OUT_BEGIN_SQL_MDB_ADO_3 SQL Statement to Execute Before Translation:
MDB_ADO_3_BEGIN_SQL{0} "$(MDB_ADO_OUT_BEGIN_SQL_MDB_ADO_3)"
# ============================================================================
# The following specifies an SQL command to execute after closing all the
# tables.
DEFAULT_MACRO MDB_ADO_OUT_END_SQL_MDB_ADO_3 
GUI OPTIONAL TEXT_EDIT_SQL MDB_ADO_OUT_END_SQL_MDB_ADO_3 SQL Statement to Execute After Translation:
MDB_ADO_3_END_SQL{0} "$(MDB_ADO_OUT_END_SQL_MDB_ADO_3)"
MDB_ADO_3_DATASET "$(DestDataset_MDB_ADO_3)"
#! END_DEST_HEADER
#! START_WB_HEADER
MACRO WB_KEYWORD "MDB_ADO_4"
#! END_WB_HEADER
#! START_DEST_HEADER MDB_ADO MDB_ADO_4
# ============================================================================
# First get the dataset for the database. For Access, it's the database file.
# For now we'll use whatever they had when they generated this mapping file,
# and not reprompt
#! END_DEST_HEADER
#! START_WB_HEADER
DEFAULT_MACRO DestDataset
INCLUDE [ if {"$(DestDataset)" != ""} {                          \
 puts {DEFAULT_MACRO DestDataset_MDB_ADO_4 $(DestDataset)}         \
 } ]
#! END_WB_HEADER
#! START_DEST_HEADER MDB_ADO MDB_ADO_4
DEFAULT_MACRO DestDataset_MDB_ADO_4 $(DestDataset_MDB_ADO_2)
GUI FILENAME DestDataset_MDB_ADO_4 Access_Database_Files(*.mdb;*.accdb)|*.mdb;*.accdb|All_files(*)|* Destination Microsoft Access Database File:
# ===========================================================================
# Optional Password
DEFAULT_MACRO MDB_ADO_OUT_PASSWORD_MDB_ADO_4 
MDB_ADO_4_PASSWORD "$(MDB_ADO_OUT_PASSWORD_MDB_ADO_4)"
GUI OPTIONAL PASSWORD MDB_ADO_OUT_PASSWORD_MDB_ADO_4 Password:
# ===========================================================================
# Optional Version (defaultsto2000/2002/2003)
DEFAULT_MACRO MDB_ADO_OUT_VERSION_MDB_ADO_4 2000/2002/2003
MDB_ADO_4_VERSION "$(MDB_ADO_OUT_VERSION_MDB_ADO_4)"
GUI CHOICE MDB_ADO_OUT_VERSION_MDB_ADO_4 2007%2000/2002/2003%95/97%2.0 Version:
# ============================================================================
# Whether or not to overwrite the file
DEFAULT_MACRO MDB_ADO_OUT_OVERWRITE_FILE_MDB_ADO_4 Yes
MDB_ADO_4_OVERWRITE_FILE "$(MDB_ADO_OUT_OVERWRITE_FILE_MDB_ADO_4)"
GUI CHOICE MDB_ADO_OUT_OVERWRITE_FILE_MDB_ADO_4 Yes%No Overwrite Existing Database:
# ============================================================================
# Opt in for destination dataset type vs format type validation
DEFAULT_MACRO MDB_ADO_OUT_DESTINATION_DATASETTYPE_VALIDATION_MDB_ADO_4 Yes
MDB_ADO_4_DESTINATION_DATASETTYPE_VALIDATION "$(MDB_ADO_OUT_DESTINATION_DATASETTYPE_VALIDATION_MDB_ADO_4)"
# ============================================================================
# For database compression
DEFAULT_MACRO MDB_ADO_OUT_COMPRESS_AT_END_MDB_ADO_4 no
GUI CHOICE MDB_ADO_OUT_COMPRESS_AT_END_MDB_ADO_4 yes%no Compress Database When Done:
MDB_ADO_4_COMPRESS_AT_END $(MDB_ADO_OUT_COMPRESS_AT_END_MDB_ADO_4)
# ============================================================================
# This keyword sets the mode of the writer
DEFAULT_MACRO MDB_ADO_OUT_WRITER_MODE_MDB_ADO_4 INSERT
GUI CHOICE MDB_ADO_OUT_WRITER_MODE_MDB_ADO_4 INSERT%UPDATE%DELETE Writer Mode:
MDB_ADO_4_WRITER_MODE $(MDB_ADO_OUT_WRITER_MODE_MDB_ADO_4)
# ============================================================================
# This keyword sets the starting transaction
DEFAULT_MACRO MDB_ADO_OUT_START_TRANSACTION_MDB_ADO_4 0
GUI OPTIONAL TEXT MDB_ADO_OUT_START_TRANSACTION_MDB_ADO_4 Start transaction at:
MDB_ADO_4_START_TRANSACTION $(MDB_ADO_OUT_START_TRANSACTION_MDB_ADO_4)
# ============================================================================
# This keyword sets the number of features between transaction commits
DEFAULT_MACRO MDB_ADO_OUT_TRANSACTION_INTERVAL_MDB_ADO_4 500
GUI OPTIONAL TEXT MDB_ADO_OUT_TRANSACTION_INTERVAL_MDB_ADO_4 Transaction interval:
MDB_ADO_4_TRANSACTION_INTERVAL $(MDB_ADO_OUT_TRANSACTION_INTERVAL_MDB_ADO_4)
# ============================================================================
# The following specifies an SQL command to execute before opening the first
# table.
DEFAULT_MACRO MDB_ADO_OUT_BEGIN_SQL_MDB_ADO_4 
GUI OPTIONAL TEXT_EDIT_SQL MDB_ADO_OUT_BEGIN_SQL_MDB_ADO_4 SQL Statement to Execute Before Translation:
MDB_ADO_4_BEGIN_SQL{0} "$(MDB_ADO_OUT_BEGIN_SQL_MDB_ADO_4)"
# ============================================================================
# The following specifies an SQL command to execute after closing all the
# tables.
DEFAULT_MACRO MDB_ADO_OUT_END_SQL_MDB_ADO_4 
GUI OPTIONAL TEXT_EDIT_SQL MDB_ADO_OUT_END_SQL_MDB_ADO_4 SQL Statement to Execute After Translation:
MDB_ADO_4_END_SQL{0} "$(MDB_ADO_OUT_END_SQL_MDB_ADO_4)"
MDB_ADO_4_DATASET "$(DestDataset_MDB_ADO_4)"
#! END_DEST_HEADER
#! END_HEADER

WRITER_TYPE NULL
WRITER_KEYWORD WBROUTER_OUT
WBROUTER_OUT_DATASET null

LOG_END_BANNER 
LOG_END_BANNER *** All writer output has been redirected to the Inspector application ***
LOG_END_BANNER 
LOG_FILENAME "$(FME_MF_DIR)CORRIGIR_NOMEABREV_EDICAO.log"
LOG_APPEND NO
LOG_MAX_FEATURES 200
LOG_MAX_RECORDED_FEATURES 200
LOG_MAX_PRECISION Yes
FME_REPROJECTION_ENGINE FME
FME_IMPLICIT_CSMAP_REPROJECTION_MODE Auto
FME_GEOMETRY_HANDLING Enhanced
FME_STROKE_MAX_DEVIATION 0
LOG_FILTER_MASK -1
DEFAULT_MACRO DATASET_KEYWORD_MDB_ADO_1 MDB_ADO_1
DEFAULT_MACRO DATASET_KEYWORD_MDB_ADO_2 MDB_ADO_2
DEFAULT_MACRO DATASET_KEYWORD_MDB_ADO_5 MDB_ADO_5
DEFAULT_MACRO DATASET_KEYWORD_MDB_ADO_3 MDB_ADO_3
DEFAULT_MACRO DATASET_KEYWORD_MDB_ADO_4 MDB_ADO_4
# -------------------------------------------------------------------------

MDB_ADO_1_READER_META_ATTRIBUTES fme_feature_type

# -------------------------------------------------------------------------

MDB_ADO_2_READER_META_ATTRIBUTES fme_feature_type

# -------------------------------------------------------------------------

MDB_ADO_5_READER_META_ATTRIBUTES fme_feature_type

# -------------------------------------------------------------------------

MDB_ADO_2_FEATURE_TYPES $(FEATURE_TYPES)
MULTI_READER_CONTINUE_ON_READER_FAILURE No

# -------------------------------------------------------------------------

MACRO WORKSPACE_NAME CORRIGIR_NOMEABREV_EDICAO
MACRO FME_VIEWER_APP fmedatainspector
# -------------------------------------------------------------------------

INCLUDE [ if {[info exists env(FME_TEMP)] && [file isdirectory $env(FME_TEMP)]} {set gVisualizerTemp $env(FME_TEMP)}  elseif {[info exists env(TEMP)] && [file isdirectory $env(TEMP)]}  {set gVisualizerTemp $env(TEMP)}  elseif { $tcl_platform(platform) == "unix" } {set gVisualizerTemp "/tmp"} else {set gVisualizerTemp c:};  regsub -all {[ ,&]} {$(WORKSPACE_NAME)} {_} wsname; set gVisualizerTemp $gVisualizerTemp/${wsname}_[clock format [clock seconds] -format %H%M%S];  puts "MACRO WORKSPACE_TEMP_DIR $gVisualizerTemp"; 
MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/inspector.ffs
MACRO VISUALIZER_SCHEMA_FILE $(WORKSPACE_TEMP_DIR)/inspector.fsc
MACRO VISUALIZER_CREATE_SPATIAL_INDEX YES
# -------------------------------------------------------------------------

FACTORY_DEF * RoutingFactory   FACTORY_NAME "Router and Unexpected Input Remover"   INPUT FEATURE_TYPE *    ROUTE MDB_ADO MDB_ADO_5::Dep_Abast_Agua_point multi_reader_keyword,$(DATASET_KEYWORD_MDB_ADO_5) TO FME_GENERIC ::Dep_Abast_Agua_point ALIAS_GEOMETRY    MERGE_INPUT Yes   OUTPUT ROUTED FEATURE_TYPE *
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Massa_Dagua_SHAPE_Index EXACT Massa_Dagua_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::T_1_PolyErrors_Shape_Index EXACT T_1_PolyErrors_Shape_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Campo_SHAPE_Index EXACT Campo_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Religiosa_polygon_SHAPE_Index EXACT Edif_Religiosa_polygon_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Curva_Nivel_SHAPE_Index EXACT Curva_Nivel_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Atracadouro_polygon_SHAPE_Index EXACT Atracadouro_polygon_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Trecho_Rodoviario EXACT Trecho_Rodoviario
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Saude_point EXACT Edif_Saude_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Industrial_point_SHAPE_Index EXACT Edif_Industrial_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Servico_Social_polygon EXACT Edif_Servico_Social_polygon
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Cidade_SHAPE_Index EXACT Cidade_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Pto_Est_Med_Fenomenos_SHAPE_Index EXACT Pto_Est_Med_Fenomenos_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Terreno_Suj_Inundacao_SHAPE_Index EXACT Terreno_Suj_Inundacao_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Const_Aeroportuaria_point EXACT Edif_Const_Aeroportuaria_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Comerc_Serv_point_SHAPE_Index EXACT Edif_Comerc_Serv_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Area_Ext_Mineral EXACT Area_Ext_Mineral
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Saneamento_point_SHAPE_Index EXACT Edif_Saneamento_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Aglomerado_Rural EXACT Aglomerado_Rural
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Ponto_Cotado_Altimetrico_SHAPE_Index EXACT Ponto_Cotado_Altimetrico_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Cemiterio_polygon EXACT Cemiterio_polygon
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Trecho_Massa_Dagua EXACT Trecho_Massa_Dagua
MDB_ADO_1_MERGE_DEF MDB_ADO_1::SelectedObjects EXACT SelectedObjects
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Barragem_line EXACT Barragem_line
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Ensino_polygon EXACT Edif_Ensino_polygon
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Deposito_Geral_polygon EXACT Deposito_Geral_polygon
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Atracadouro_point_SHAPE_Index EXACT Atracadouro_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Dep_Abast_Agua_point EXACT Dep_Abast_Agua_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Const_Aeroportuaria_point_SHAPE_Index EXACT Edif_Const_Aeroportuaria_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Caatinga EXACT Caatinga
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Ext_Mineral_point_SHAPE_Index EXACT Edif_Ext_Mineral_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Ponto_Duto EXACT Ponto_Duto
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Pub_Civil_polygon EXACT Edif_Pub_Civil_polygon
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Campo_Quadra_polygon_SHAPE_Index EXACT Campo_Quadra_polygon_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Arruamento EXACT Arruamento
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Ponto_Rodoviario_Ferrov EXACT Ponto_Rodoviario_Ferrov
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Veg_Cultivada_SHAPE_Index EXACT Veg_Cultivada_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Const_Lazer_point EXACT Edif_Const_Lazer_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Dep_Saneamento_polygon_SHAPE_Index EXACT Dep_Saneamento_polygon_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Ponto_Cotado_Altimetrico EXACT Ponto_Cotado_Altimetrico
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Patio_polygon_SHAPE_Index EXACT Patio_polygon_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::GDB_Items EXACT GDB_Items
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Religiosa_point_SHAPE_Index EXACT Edif_Religiosa_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Ext_Mineral_point EXACT Edif_Ext_Mineral_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Delimitacao_Fisica_SHAPE_Index EXACT Delimitacao_Fisica_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::GDB_ItemTypes EXACT GDB_ItemTypes
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Limite_Massa_Dagua_SHAPE_Index EXACT Limite_Massa_Dagua_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Comunic_point_SHAPE_Index EXACT Edif_Comunic_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::GDB_ItemRelationshipTypes EXACT GDB_ItemRelationshipTypes
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Pub_Civil_point_SHAPE_Index EXACT Edif_Pub_Civil_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Saneamento_point EXACT Edif_Saneamento_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Cidade EXACT Cidade
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Veg_Cultivada EXACT Veg_Cultivada
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Banco_Areia_polygon EXACT Banco_Areia_polygon
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Religiosa_point EXACT Edif_Religiosa_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Limite_Massa_Dagua EXACT Limite_Massa_Dagua
MDB_ADO_1_MERGE_DEF MDB_ADO_1::GDB_DatabaseLocks EXACT GDB_DatabaseLocks
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Ensino_point EXACT Edif_Ensino_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Comporta_line EXACT Comporta_line
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Comerc_Serv_point EXACT Edif_Comerc_Serv_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Agrop_Ext_Veg_Pesca_point EXACT Edif_Agrop_Ext_Veg_Pesca_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Fonte_Dagua_SHAPE_Index EXACT Fonte_Dagua_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Nome_Local_SHAPE_Index EXACT Nome_Local_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Grupo_Transform_Energ_point_SHAPE_Index EXACT Grupo_Transform_Energ_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Atracadouro_polygon EXACT Atracadouro_polygon
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Confluencia_SHAPE_Index EXACT Confluencia_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Campo_Quadra_point EXACT Campo_Quadra_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::GDB_ReplicaLog EXACT GDB_ReplicaLog
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Elemento_Fisiog_Natural_line EXACT Elemento_Fisiog_Natural_line
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Galeria_Bueiro_point_SHAPE_Index EXACT Galeria_Bueiro_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Constr_Est_Med_point EXACT Edif_Constr_Est_Med_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Patio_polygon EXACT Patio_polygon
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Entroncamento EXACT Entroncamento
MDB_ADO_1_MERGE_DEF MDB_ADO_1::T_1_LineErrors EXACT T_1_LineErrors
MDB_ADO_1_MERGE_DEF MDB_ADO_1::GDB_SpatialRefs EXACT GDB_SpatialRefs
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Pub_Civil_polygon_SHAPE_Index EXACT Edif_Pub_Civil_polygon_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Ensino_polygon_SHAPE_Index EXACT Edif_Ensino_polygon_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Terreno_Exposto EXACT Terreno_Exposto
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Comunic_point EXACT Edif_Comunic_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Comerc_Serv_polygon EXACT Edif_Comerc_Serv_polygon
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Torre_Comunic_SHAPE_Index EXACT Torre_Comunic_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Pub_Militar_point EXACT Edif_Pub_Militar_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Elemento_Fisiog_Natural_line_SHAPE_Index EXACT Elemento_Fisiog_Natural_line_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Antena_Comunic_SHAPE_Index EXACT Antena_Comunic_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Saude_polygon EXACT Edif_Saude_polygon
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Travessia_point EXACT Travessia_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Gruta_Caverna_point_SHAPE_Index EXACT Gruta_Caverna_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Trilha_Picada EXACT Trilha_Picada
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Pto_Est_Med_Fenomenos EXACT Pto_Est_Med_Fenomenos
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Pista_Competicao_line EXACT Pista_Competicao_line
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Const_Turistica_point_SHAPE_Index EXACT Edif_Const_Turistica_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Area_Edificada_SHAPE_Index EXACT Area_Edificada_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Aglomerado_Rural_SHAPE_Index EXACT Aglomerado_Rural_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Area_Energia_Eletrica_SHAPE_Index EXACT Area_Energia_Eletrica_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Area_Industrial_SHAPE_Index EXACT Area_Industrial_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Ext_Mineral_polygon EXACT Edif_Ext_Mineral_polygon
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Comerc_Serv_polygon_SHAPE_Index EXACT Edif_Comerc_Serv_polygon_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::T_1_PointErrors EXACT T_1_PointErrors
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Rodoviaria_polygon EXACT Edif_Rodoviaria_polygon
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Pub_Militar_polygon_SHAPE_Index EXACT Edif_Pub_Militar_polygon_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::GDB_ItemRelationships EXACT GDB_ItemRelationships
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Area_Ext_Mineral_SHAPE_Index EXACT Area_Ext_Mineral_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Servico_Social_polygon_SHAPE_Index EXACT Edif_Servico_Social_polygon_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Area_Energia_Eletrica EXACT Area_Energia_Eletrica
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Abast_Agua_point EXACT Edif_Abast_Agua_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Elemento_Fisiog_Natural_point_SHAPE_Index EXACT Elemento_Fisiog_Natural_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Religiosa_polygon EXACT Edif_Religiosa_polygon
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Ext_Mineral_polygon_SHAPE_Index EXACT Edif_Ext_Mineral_polygon_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Trecho_Drenagem EXACT Trecho_Drenagem
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Posto_Combustivel_point_SHAPE_Index EXACT Posto_Combustivel_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Selections EXACT Selections
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Ponto_Drenagem_SHAPE_Index EXACT Ponto_Drenagem_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Pista_Ponto_Pouso_polygon_SHAPE_Index EXACT Pista_Ponto_Pouso_polygon_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Est_Gerad_Energia_Eletr_polygon_SHAPE_Index EXACT Est_Gerad_Energia_Eletr_polygon_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Servico_Social_point_SHAPE_Index EXACT Edif_Servico_Social_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Pista_Competicao_line_SHAPE_Index EXACT Pista_Competicao_line_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Rodoviaria_polygon_SHAPE_Index EXACT Edif_Rodoviaria_polygon_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Pista_Ponto_Pouso_polygon EXACT Pista_Ponto_Pouso_polygon
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Habitacional_point EXACT Edif_Habitacional_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Area_Edificada EXACT Area_Edificada
MDB_ADO_1_MERGE_DEF MDB_ADO_1::GDB_ColumnInfo EXACT GDB_ColumnInfo
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Terreno_Suj_Inundacao EXACT Terreno_Suj_Inundacao
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Cemiterio_point_SHAPE_Index EXACT Cemiterio_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Ponto_Trecho_Energia_SHAPE_Index EXACT Ponto_Trecho_Energia_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Rodoviaria_point EXACT Edif_Rodoviaria_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Trecho_Rodoviario_SHAPE_Index EXACT Trecho_Rodoviario_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Sumidouro_Vertedouro_SHAPE_Index EXACT Sumidouro_Vertedouro_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Habitacional_point_SHAPE_Index EXACT Edif_Habitacional_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Industrial_point EXACT Edif_Industrial_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Est_Gerad_Energia_Eletr_polygon EXACT Est_Gerad_Energia_Eletr_polygon
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Ponto_Rodoviario_Ferrov_SHAPE_Index EXACT Ponto_Rodoviario_Ferrov_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Banco_Areia_polygon_SHAPE_Index EXACT Banco_Areia_polygon_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Servico_Social_point EXACT Edif_Servico_Social_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Atracadouro_point EXACT Atracadouro_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Deposito_Geral_polygon_SHAPE_Index EXACT Deposito_Geral_polygon_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Identific_Trecho_Rod EXACT Identific_Trecho_Rod
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Industrial_polygon_SHAPE_Index EXACT Edif_Industrial_polygon_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Massa_Dagua EXACT Massa_Dagua
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Const_Lazer_polygon_SHAPE_Index EXACT Edif_Const_Lazer_polygon_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Nome_Local EXACT Nome_Local
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Cerrado_Cerradao_SHAPE_Index EXACT Cerrado_Cerradao_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Campo EXACT Campo
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Rodoviaria_point_SHAPE_Index EXACT Edif_Rodoviaria_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Cemiterio_point EXACT Cemiterio_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Identific_Trecho_Rod_SHAPE_Index EXACT Identific_Trecho_Rod_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Const_Lazer_point_SHAPE_Index EXACT Edif_Const_Lazer_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Ponto_Drenagem EXACT Ponto_Drenagem
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Curva_Nivel EXACT Curva_Nivel
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Comporta_line_SHAPE_Index EXACT Comporta_line_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Terreno_Exposto_SHAPE_Index EXACT Terreno_Exposto_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Trecho_Duto_SHAPE_Index EXACT Trecho_Duto_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Campo_Quadra_point_SHAPE_Index EXACT Campo_Quadra_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Trecho_Drenagem_SHAPE_Index EXACT Trecho_Drenagem_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Dep_Abast_Agua_point_SHAPE_Index EXACT Dep_Abast_Agua_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Area_Lazer EXACT Area_Lazer
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Saude_point_SHAPE_Index EXACT Edif_Saude_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Trecho_Massa_Dagua_SHAPE_Index EXACT Trecho_Massa_Dagua_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Caatinga_SHAPE_Index EXACT Caatinga_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::GDB_GeomColumns EXACT GDB_GeomColumns
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Arruamento_SHAPE_Index EXACT Arruamento_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Ponte_point EXACT Ponte_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::T_1_LineErrors_Shape_Index EXACT T_1_LineErrors_Shape_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Arquibancada_point_SHAPE_Index EXACT Arquibancada_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Trecho_Energia_SHAPE_Index EXACT Trecho_Energia_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Abast_Agua_point_SHAPE_Index EXACT Edif_Abast_Agua_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Ilha_polygon_SHAPE_Index EXACT Ilha_polygon_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Arquibancada_point EXACT Arquibancada_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Area_Uso_Comunitario_point EXACT Area_Uso_Comunitario_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Cerrado_Cerradao EXACT Cerrado_Cerradao
MDB_ADO_1_MERGE_DEF MDB_ADO_1::T_1_PointErrors_Shape_Index EXACT T_1_PointErrors_Shape_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Torre_Comunic EXACT Torre_Comunic
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Grupo_Transform_Energ_point EXACT Grupo_Transform_Energ_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Gruta_Caverna_point EXACT Gruta_Caverna_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Deposito_Geral_point_SHAPE_Index EXACT Deposito_Geral_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Alter_Fisiog_Antropica_line_SHAPE_Index EXACT Alter_Fisiog_Antropica_line_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Ponto_Duto_SHAPE_Index EXACT Ponto_Duto_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Const_Lazer_polygon EXACT Edif_Const_Lazer_polygon
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Area_Uso_Comunitario_point_SHAPE_Index EXACT Area_Uso_Comunitario_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Pub_Militar_point_SHAPE_Index EXACT Edif_Pub_Militar_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Const_Turistica_point EXACT Edif_Const_Turistica_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::GDB_Items_Shape_Index EXACT GDB_Items_Shape_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Delimitacao_Fisica EXACT Delimitacao_Fisica
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Area_Lazer_SHAPE_Index EXACT Area_Lazer_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Ponto_Trecho_Energia EXACT Ponto_Trecho_Energia
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Travessia_point_SHAPE_Index EXACT Travessia_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Confluencia EXACT Confluencia
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Area_Industrial EXACT Area_Industrial
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Alter_Fisiog_Antropica_line EXACT Alter_Fisiog_Antropica_line
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Pub_Militar_polygon EXACT Edif_Pub_Militar_polygon
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Dep_Saneamento_point EXACT Dep_Saneamento_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Saude_polygon_SHAPE_Index EXACT Edif_Saude_polygon_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Antena_Comunic EXACT Antena_Comunic
MDB_ADO_1_MERGE_DEF MDB_ADO_1::T_1_PolyErrors EXACT T_1_PolyErrors
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Cemiterio_polygon_SHAPE_Index EXACT Cemiterio_polygon_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Ponto_Inicio_Drenagem EXACT Ponto_Inicio_Drenagem
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Entroncamento_SHAPE_Index EXACT Entroncamento_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Industrial_polygon EXACT Edif_Industrial_polygon
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Constr_Est_Med_point_SHAPE_Index EXACT Edif_Constr_Est_Med_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Trecho_Energia EXACT Trecho_Energia
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Rocha_polygon_SHAPE_Index EXACT Rocha_polygon_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Pub_Civil_point EXACT Edif_Pub_Civil_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Trecho_Duto EXACT Trecho_Duto
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Campo_Quadra_polygon EXACT Campo_Quadra_polygon
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Ensino_point_SHAPE_Index EXACT Edif_Ensino_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Posto_Combustivel_point EXACT Posto_Combustivel_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Ponto_Inicio_Drenagem_SHAPE_Index EXACT Ponto_Inicio_Drenagem_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Fonte_Dagua EXACT Fonte_Dagua
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Ilha_polygon EXACT Ilha_polygon
MDB_ADO_1_MERGE_DEF MDB_ADO_1::T_1_DirtyAreas_DirtyArea_Index EXACT T_1_DirtyAreas_DirtyArea_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Barragem_line_SHAPE_Index EXACT Barragem_line_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Sumidouro_Vertedouro EXACT Sumidouro_Vertedouro
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Galeria_Bueiro_point EXACT Galeria_Bueiro_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Dep_Saneamento_polygon EXACT Dep_Saneamento_polygon
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Rocha_polygon EXACT Rocha_polygon
MDB_ADO_1_MERGE_DEF MDB_ADO_1::T_1_DirtyAreas EXACT T_1_DirtyAreas
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Deposito_Geral_point EXACT Deposito_Geral_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Elemento_Fisiog_Natural_point EXACT Elemento_Fisiog_Natural_point
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Ponte_point_SHAPE_Index EXACT Ponte_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index EXACT Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Trilha_Picada_SHAPE_Index EXACT Trilha_Picada_SHAPE_Index
MDB_ADO_1_MERGE_DEF MDB_ADO_1::Dep_Saneamento_point_SHAPE_Index EXACT Dep_Saneamento_point_SHAPE_Index
MDB_ADO_2_MERGE_DEF MDB_ADO_2::Veg_Cultivada_SHAPE_Index GLOB *
MDB_ADO_5_MERGE_DEF MDB_ADO_5::Dep_Abast_Agua_point EXACT Dep_Abast_Agua_point DEFLINE mdb_sql_statement,,mdb_where_clause,,OBJECTID,autonumber,SHAPE,oleobject,simbolizarCartaMini,long,justTxt,long,offSetY,single,fkComplOrgExtMin,text<openparen>255<closeparen>,fkComplOrgComSv,text<openparen>255<closeparen>,offSetX,single,fkComplIndustria,text<openparen>255<closeparen>,controleId,text<openparen>255<closeparen>,construcao,long,fkComplAbsAgua,text<openparen>255<closeparen>,orientacao,single,nomeAbrev,text<openparen>255<closeparen>,finalidade,long,offSetSimbY,single,fkComplOrgAgrop,text<openparen>255<closeparen>,escalaMaxSimbolizar,long,fkClassificador,text<openparen>255<closeparen>,operacional,long,geometriaAproximada,long,obsAquisicao,text<openparen>255<closeparen>,situacaoFisica,long,situacaoAgua,long,tipoDepAbast,long,nome,text<openparen>255<closeparen>,offSetSimbX,single,matConstr,long,controle_id,text<openparen>200<closeparen>
# -------------------------------------------------------------------------

FACTORY_DEF * TeeFactory    FACTORY_NAME "Dep_Abast_Agua_point (MDB_ADO_1) Splitter"    INPUT FEATURE_TYPE Dep_Abast_Agua_point      multi_reader_keyword $(DATASET_KEYWORD_MDB_ADO_1)    OUTPUT FEATURE_TYPE Dep_Abast_Agua_point_MDB_ADO_1
# -------------------------------------------------------------------------

FACTORY_DEF * TeeFactory    FACTORY_NAME "Veg_Cultivada_SHAPE_Index (MDB_ADO_1) Splitter"    INPUT FEATURE_TYPE Veg_Cultivada_SHAPE_Index      multi_reader_keyword $(DATASET_KEYWORD_MDB_ADO_1)    OUTPUT FEATURE_TYPE Veg_Cultivada_SHAPE_Index_MDB_ADO_1
# -------------------------------------------------------------------------

FACTORY_DEF * TeeFactory    FACTORY_NAME "Veg_Cultivada_SHAPE_Index (MDB_ADO_2) Splitter"    INPUT FEATURE_TYPE Veg_Cultivada_SHAPE_Index      multi_reader_keyword $(DATASET_KEYWORD_MDB_ADO_2)
# -------------------------------------------------------------------------

FACTORY_DEF * TeeFactory    FACTORY_NAME "Dep_Abast_Agua_point (MDB_ADO_5) Splitter"    INPUT FEATURE_TYPE Dep_Abast_Agua_point      multi_reader_keyword $(DATASET_KEYWORD_MDB_ADO_5)    OUTPUT FEATURE_TYPE Dep_Abast_Agua_point_MDB_ADO_5_0_PUY1Dkhy3nU=    OUTPUT FEATURE_TYPE Dep_Abast_Agua_point_MDB_ADO_5_1_PUY1Dkhy3nU=
DEFAULT_MACRO WB_CURRENT_CONTEXT
# -------------------------------------------------------------------------

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Dep_Abast_Agua_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Dep_Abast_Agua_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Abast_Agua_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Dep_Abast_Agua_point_FeatureDirector    INPUT  FEATURE_TYPE Dep_Abast_Agua_point_MDB_ADO_5_0_PUY1Dkhy3nU=    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Dep_Abast_Agua_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Dep_Abast_Agua_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Dep_Abast_Agua_point___FeatureDirector1    INPUT FEATURE_TYPE Dep_Abast_Agua_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Dep_Abast_Agua_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Dep_Abast_Agua_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Abast_Agua_point_VectorSetterUpper    INPUT FEATURE_TYPE Dep_Abast_Agua_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Dep_Abast_Agua_point_a2e34129_1e50_4a11_a323_63db996a6a9d2_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Abast_Agua_point___PointCloudThinner    INPUT FEATURE_TYPE Dep_Abast_Agua_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Dep_Abast_Agua_point_a2e34129_1e50_4a11_a323_63db996a6a9d2_thinPointCloud")
Tcl2 proc Dep_Abast_Agua_point_a2e34129_1e50_4a11_a323_63db996a6a9d2_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Abast_Agua_point_RasterSetterUpper    INPUT FEATURE_TYPE Dep_Abast_Agua_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Dep_Abast_Agua_point_a2e34129_1e50_4a11_a323_63db996a6a9d2_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Dep_Abast_Agua_point_a2e34129_1e50_4a11_a323_63db996a6a9d2_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Dep_Abast_Agua_point_a2e34129_1e50_4a11_a323_63db996a6a9d2_VIS_FEAT_TYPE Dep_Abast_Agua_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Dep_Abast_Agua_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Dep_Abast_Agua_point_a2e34129_1e50_4a11_a323_63db996a6a9d2_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,fkComplOrgExtMin,varchar<openparen>255<closeparen>,fkComplOrgComSv,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,fkComplIndustria,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,construcao,varchar<openparen>255<closeparen>,fkComplAbsAgua,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,finalidade,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,fkComplOrgAgrop,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,situacaoAgua,varchar<openparen>255<closeparen>,tipoDepAbast,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

# -------------------------------------------------------------------------
FACTORY_DEF * AttrSetFactory FACTORY_NAME AttributeCreator ATTRSET_CREATE_DIRECTIVES _PROPAGATE_MISSING_FDIV INPUT  FEATURE_TYPE Dep_Abast_Agua_point_MDB_ADO_5_1_PUY1Dkhy3nU= ATTR nomeAbrev Caixa<space>d<apos><u00e1>gua<space>22    OUTPUT OUTPUT FEATURE_TYPE AttributeCreator_OUTPUT 
# -------------------------------------------------------------------------

FACTORY_DEF * TestFactory    FACTORY_NAME Tester    INPUT  FEATURE_TYPE Dep_Abast_Agua_point_MDB_ADO_1    TEST nomeAbrev ATTRIBUTE_VALUE_NULL "" ENCODED    BOOLEAN_OPERATOR OR
# -------------------------------------------------------------------------
FACTORY_DEF * TeeFactory   FACTORY_NAME "AttributeFilter (Disabled) Nuker"   INPUT FEATURE_TYPE Edif_Const_Lazer_polygon_SHAPE_Index   INPUT FEATURE_TYPE Selections   INPUT FEATURE_TYPE Ponto_Drenagem   INPUT FEATURE_TYPE Arquibancada_point   INPUT FEATURE_TYPE Gruta_Caverna_point_SHAPE_Index   INPUT FEATURE_TYPE Edif_Rodoviaria_polygon   INPUT FEATURE_TYPE Edif_Industrial_polygon_SHAPE_Index   INPUT FEATURE_TYPE Area_Edificada_SHAPE_Index   INPUT FEATURE_TYPE Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index   INPUT FEATURE_TYPE Edif_Servico_Social_point   INPUT FEATURE_TYPE Edif_Constr_Est_Med_point_SHAPE_Index   INPUT FEATURE_TYPE Antena_Comunic   INPUT FEATURE_TYPE Nome_Local   INPUT FEATURE_TYPE Rocha_polygon_SHAPE_Index   INPUT FEATURE_TYPE Atracadouro_polygon   INPUT FEATURE_TYPE Elemento_Fisiog_Natural_point   INPUT FEATURE_TYPE Edif_Ext_Mineral_point_SHAPE_Index   INPUT FEATURE_TYPE Cemiterio_point_SHAPE_Index   INPUT FEATURE_TYPE Ponto_Duto   INPUT FEATURE_TYPE Delimitacao_Fisica_SHAPE_Index   INPUT FEATURE_TYPE Edif_Ensino_polygon   INPUT FEATURE_TYPE Ponto_Inicio_Drenagem   INPUT FEATURE_TYPE Alter_Fisiog_Antropica_line   INPUT FEATURE_TYPE Area_Edificada   INPUT FEATURE_TYPE Cidade   INPUT FEATURE_TYPE Galeria_Bueiro_point   INPUT FEATURE_TYPE T_1_LineErrors_Shape_Index   INPUT FEATURE_TYPE Edif_Pub_Civil_polygon   INPUT FEATURE_TYPE Pista_Competicao_line_SHAPE_Index   INPUT FEATURE_TYPE Dep_Saneamento_point_SHAPE_Index   INPUT FEATURE_TYPE Area_Uso_Comunitario_point_SHAPE_Index   INPUT FEATURE_TYPE Banco_Areia_polygon   INPUT FEATURE_TYPE Dep_Abast_Agua_point_SHAPE_Index   INPUT FEATURE_TYPE Grupo_Transform_Energ_point_SHAPE_Index   INPUT FEATURE_TYPE Edif_Rodoviaria_point   INPUT FEATURE_TYPE Aglomerado_Rural   INPUT FEATURE_TYPE Trecho_Drenagem_SHAPE_Index   INPUT FEATURE_TYPE Elemento_Fisiog_Natural_point_SHAPE_Index   INPUT FEATURE_TYPE Pto_Est_Med_Fenomenos_SHAPE_Index   INPUT FEATURE_TYPE Edif_Pub_Civil_point_SHAPE_Index   INPUT FEATURE_TYPE Posto_Combustivel_point_SHAPE_Index   INPUT FEATURE_TYPE T_1_PolyErrors_Shape_Index   INPUT FEATURE_TYPE Area_Industrial_SHAPE_Index   INPUT FEATURE_TYPE Comporta_line_SHAPE_Index   INPUT FEATURE_TYPE Entroncamento   INPUT FEATURE_TYPE Edif_Pub_Civil_point   INPUT FEATURE_TYPE Atracadouro_point_SHAPE_Index   INPUT FEATURE_TYPE Pista_Competicao_line   INPUT FEATURE_TYPE Confluencia   INPUT FEATURE_TYPE Massa_Dagua   INPUT FEATURE_TYPE Edif_Saude_polygon   INPUT FEATURE_TYPE SelectedObjects   INPUT FEATURE_TYPE Edif_Comunic_point   INPUT FEATURE_TYPE Edif_Religiosa_polygon   INPUT FEATURE_TYPE Massa_Dagua_SHAPE_Index   INPUT FEATURE_TYPE Arruamento_SHAPE_Index   INPUT FEATURE_TYPE Comporta_line   INPUT FEATURE_TYPE Edif_Industrial_polygon   INPUT FEATURE_TYPE Area_Uso_Comunitario_point   INPUT FEATURE_TYPE GDB_ColumnInfo   INPUT FEATURE_TYPE T_1_PointErrors   INPUT FEATURE_TYPE Identific_Trecho_Rod   INPUT FEATURE_TYPE Campo_Quadra_polygon_SHAPE_Index   INPUT FEATURE_TYPE Atracadouro_point   INPUT FEATURE_TYPE Aglomerado_Rural_SHAPE_Index   INPUT FEATURE_TYPE Edif_Abast_Agua_point_SHAPE_Index   INPUT FEATURE_TYPE Edif_Ext_Mineral_polygon   INPUT FEATURE_TYPE Area_Industrial   INPUT FEATURE_TYPE GDB_ItemRelationshipTypes   INPUT FEATURE_TYPE T_1_LineErrors   INPUT FEATURE_TYPE Ponto_Cotado_Altimetrico_SHAPE_Index   INPUT FEATURE_TYPE GDB_Items   INPUT FEATURE_TYPE Trecho_Massa_Dagua   INPUT FEATURE_TYPE Edif_Comunic_point_SHAPE_Index   INPUT FEATURE_TYPE Edif_Saude_point   INPUT FEATURE_TYPE Edif_Pub_Militar_polygon_SHAPE_Index   INPUT FEATURE_TYPE Deposito_Geral_polygon   INPUT FEATURE_TYPE Elemento_Fisiog_Natural_line_SHAPE_Index   INPUT FEATURE_TYPE Barragem_line   INPUT FEATURE_TYPE Ponto_Trecho_Energia   INPUT FEATURE_TYPE Campo   INPUT FEATURE_TYPE Trilha_Picada_SHAPE_Index   INPUT FEATURE_TYPE Elemento_Fisiog_Natural_line   INPUT FEATURE_TYPE Trecho_Duto   INPUT FEATURE_TYPE Limite_Massa_Dagua_SHAPE_Index   INPUT FEATURE_TYPE Confluencia_SHAPE_Index   INPUT FEATURE_TYPE Edif_Habitacional_point_SHAPE_Index   INPUT FEATURE_TYPE Area_Lazer   INPUT FEATURE_TYPE Edif_Ensino_point   INPUT FEATURE_TYPE Ponto_Duto_SHAPE_Index   INPUT FEATURE_TYPE Edif_Const_Aeroportuaria_point_SHAPE_Index   INPUT FEATURE_TYPE Fonte_Dagua_SHAPE_Index   INPUT FEATURE_TYPE Arruamento   INPUT FEATURE_TYPE Trecho_Massa_Dagua_SHAPE_Index   INPUT FEATURE_TYPE Ponto_Rodoviario_Ferrov_SHAPE_Index   INPUT FEATURE_TYPE Caatinga_SHAPE_Index   INPUT FEATURE_TYPE Edif_Pub_Militar_point_SHAPE_Index   INPUT FEATURE_TYPE Antena_Comunic_SHAPE_Index   INPUT FEATURE_TYPE T_1_PointErrors_Shape_Index   INPUT FEATURE_TYPE Area_Lazer_SHAPE_Index   INPUT FEATURE_TYPE Edif_Industrial_point   INPUT FEATURE_TYPE GDB_ItemRelationships   INPUT FEATURE_TYPE Travessia_point_SHAPE_Index   INPUT FEATURE_TYPE Cidade_SHAPE_Index   INPUT FEATURE_TYPE Edif_Const_Lazer_polygon   INPUT FEATURE_TYPE Ponto_Cotado_Altimetrico   INPUT FEATURE_TYPE Est_Gerad_Energia_Eletr_polygon_SHAPE_Index   INPUT FEATURE_TYPE Area_Energia_Eletrica_SHAPE_Index   INPUT FEATURE_TYPE Deposito_Geral_point   INPUT FEATURE_TYPE Edif_Ensino_point_SHAPE_Index   INPUT FEATURE_TYPE Trilha_Picada   INPUT FEATURE_TYPE Ponte_point   INPUT FEATURE_TYPE Atracadouro_polygon_SHAPE_Index   INPUT FEATURE_TYPE Deposito_Geral_point_SHAPE_Index   INPUT FEATURE_TYPE Edif_Pub_Militar_point   INPUT FEATURE_TYPE GDB_DatabaseLocks   INPUT FEATURE_TYPE Sumidouro_Vertedouro_SHAPE_Index   INPUT FEATURE_TYPE Ponto_Inicio_Drenagem_SHAPE_Index   INPUT FEATURE_TYPE T_1_PolyErrors   INPUT FEATURE_TYPE Dep_Saneamento_polygon   INPUT FEATURE_TYPE Edif_Pub_Militar_polygon   INPUT FEATURE_TYPE Veg_Cultivada_SHAPE_Index_MDB_ADO_1   INPUT FEATURE_TYPE Barragem_line_SHAPE_Index   INPUT FEATURE_TYPE Edif_Abast_Agua_point   INPUT FEATURE_TYPE Edif_Habitacional_point   INPUT FEATURE_TYPE Galeria_Bueiro_point_SHAPE_Index   INPUT FEATURE_TYPE Patio_polygon   INPUT FEATURE_TYPE Terreno_Suj_Inundacao_SHAPE_Index   INPUT FEATURE_TYPE Gruta_Caverna_point   INPUT FEATURE_TYPE T_1_DirtyAreas_DirtyArea_Index   INPUT FEATURE_TYPE Edif_Ensino_polygon_SHAPE_Index   INPUT FEATURE_TYPE Edif_Rodoviaria_polygon_SHAPE_Index   INPUT FEATURE_TYPE Cemiterio_polygon   INPUT FEATURE_TYPE Curva_Nivel   INPUT FEATURE_TYPE Edif_Religiosa_polygon_SHAPE_Index   INPUT FEATURE_TYPE Torre_Comunic_SHAPE_Index   INPUT FEATURE_TYPE Est_Gerad_Energia_Eletr_polygon   INPUT FEATURE_TYPE Alter_Fisiog_Antropica_line_SHAPE_Index   INPUT FEATURE_TYPE Cemiterio_point   INPUT FEATURE_TYPE Ilha_polygon_SHAPE_Index   INPUT FEATURE_TYPE Torre_Comunic   INPUT FEATURE_TYPE T_1_DirtyAreas   INPUT FEATURE_TYPE Edif_Servico_Social_point_SHAPE_Index   INPUT FEATURE_TYPE Ponte_point_SHAPE_Index   INPUT FEATURE_TYPE Edif_Pub_Civil_polygon_SHAPE_Index   INPUT FEATURE_TYPE Curva_Nivel_SHAPE_Index   INPUT FEATURE_TYPE Cerrado_Cerradao   INPUT FEATURE_TYPE Identific_Trecho_Rod_SHAPE_Index   INPUT FEATURE_TYPE Edif_Const_Lazer_point_SHAPE_Index   INPUT FEATURE_TYPE Rocha_polygon   INPUT FEATURE_TYPE GDB_ReplicaLog   INPUT FEATURE_TYPE Patio_polygon_SHAPE_Index   INPUT FEATURE_TYPE Edif_Ext_Mineral_point   INPUT FEATURE_TYPE Delimitacao_Fisica   INPUT FEATURE_TYPE Edif_Rodoviaria_point_SHAPE_Index   INPUT FEATURE_TYPE Trecho_Rodoviario_SHAPE_Index   INPUT FEATURE_TYPE Grupo_Transform_Energ_point   INPUT FEATURE_TYPE Trecho_Energia_SHAPE_Index   INPUT FEATURE_TYPE Terreno_Suj_Inundacao   INPUT FEATURE_TYPE Banco_Areia_polygon_SHAPE_Index   INPUT FEATURE_TYPE Posto_Combustivel_point   INPUT FEATURE_TYPE GDB_SpatialRefs   INPUT FEATURE_TYPE Edif_Comerc_Serv_point   INPUT FEATURE_TYPE Edif_Constr_Est_Med_point   INPUT FEATURE_TYPE Area_Ext_Mineral_SHAPE_Index   INPUT FEATURE_TYPE Pto_Est_Med_Fenomenos   INPUT FEATURE_TYPE Arquibancada_point_SHAPE_Index   INPUT FEATURE_TYPE GDB_Items_Shape_Index   INPUT FEATURE_TYPE Ponto_Drenagem_SHAPE_Index   INPUT FEATURE_TYPE Edif_Const_Aeroportuaria_point   INPUT FEATURE_TYPE Edif_Saude_point_SHAPE_Index   INPUT FEATURE_TYPE Campo_Quadra_point   INPUT FEATURE_TYPE Edif_Servico_Social_polygon_SHAPE_Index   INPUT FEATURE_TYPE Campo_SHAPE_Index   INPUT FEATURE_TYPE Edif_Religiosa_point_SHAPE_Index   INPUT FEATURE_TYPE Edif_Const_Lazer_point   INPUT FEATURE_TYPE Ponto_Trecho_Energia_SHAPE_Index   INPUT FEATURE_TYPE Trecho_Rodoviario   INPUT FEATURE_TYPE Veg_Cultivada   INPUT FEATURE_TYPE Edif_Servico_Social_polygon   INPUT FEATURE_TYPE Edif_Comerc_Serv_polygon   INPUT FEATURE_TYPE Edif_Industrial_point_SHAPE_Index   INPUT FEATURE_TYPE Nome_Local_SHAPE_Index   INPUT FEATURE_TYPE Terreno_Exposto   INPUT FEATURE_TYPE Campo_Quadra_polygon   INPUT FEATURE_TYPE Pista_Ponto_Pouso_polygon_SHAPE_Index   INPUT FEATURE_TYPE GDB_GeomColumns   INPUT FEATURE_TYPE Dep_Saneamento_polygon_SHAPE_Index   INPUT FEATURE_TYPE Edif_Const_Turistica_point   INPUT FEATURE_TYPE Sumidouro_Vertedouro   INPUT FEATURE_TYPE Limite_Massa_Dagua   INPUT FEATURE_TYPE Cerrado_Cerradao_SHAPE_Index   INPUT FEATURE_TYPE Travessia_point   INPUT FEATURE_TYPE Area_Energia_Eletrica   INPUT FEATURE_TYPE GDB_ItemTypes   INPUT FEATURE_TYPE Edif_Comerc_Serv_polygon_SHAPE_Index   INPUT FEATURE_TYPE Edif_Saneamento_point   INPUT FEATURE_TYPE Trecho_Energia   INPUT FEATURE_TYPE Edif_Const_Turistica_point_SHAPE_Index   INPUT FEATURE_TYPE Ponto_Rodoviario_Ferrov   INPUT FEATURE_TYPE Trecho_Drenagem   INPUT FEATURE_TYPE Dep_Saneamento_point   INPUT FEATURE_TYPE Fonte_Dagua   INPUT FEATURE_TYPE Edif_Ext_Mineral_polygon_SHAPE_Index   INPUT FEATURE_TYPE Ilha_polygon   INPUT FEATURE_TYPE Deposito_Geral_polygon_SHAPE_Index   INPUT FEATURE_TYPE Edif_Saude_polygon_SHAPE_Index   INPUT FEATURE_TYPE Edif_Saneamento_point_SHAPE_Index   INPUT FEATURE_TYPE Terreno_Exposto_SHAPE_Index   INPUT FEATURE_TYPE Edif_Religiosa_point   INPUT FEATURE_TYPE Trecho_Duto_SHAPE_Index   INPUT FEATURE_TYPE Edif_Agrop_Ext_Veg_Pesca_point   INPUT FEATURE_TYPE Cemiterio_polygon_SHAPE_Index   INPUT FEATURE_TYPE Campo_Quadra_point_SHAPE_Index   INPUT FEATURE_TYPE Caatinga   INPUT FEATURE_TYPE Pista_Ponto_Pouso_polygon   INPUT FEATURE_TYPE Area_Ext_Mineral   INPUT FEATURE_TYPE Edif_Comerc_Serv_point_SHAPE_Index   INPUT FEATURE_TYPE Entroncamento_SHAPE_Index
# -------------------------------------------------------------------------

FACTORY_DEF * RoutingFactory FACTORY_NAME "Destination Feature Type Routing Correlator"   INPUT FEATURE_TYPE *    ROUTE FME_GENERIC AttributeCreator_OUTPUT TO MDB_ADO __GO_TO_FINAL_OUTPUT_ROUTER__ multi_writer_id,1,<at>SupplyAttributes<openparen>ENCODED<comma>__wb_out_feat_type__<comma>Dep_Abast_Agua_point<closeparen> GEOMETRY   OUTPUT ROUTED FEATURE_TYPE * @FeatureType(ENCODED,@Value(__wb_out_feat_type__)) @RemoveAttributes(__wb_out_feat_type__)   OUTPUT NOT_ROUTED FEATURE_TYPE __nuke_me__ @Tcl2("FME_StatMessage 818059 [FME_GetAttribute fme_template_feature_type] 818060 818061 fme_warn")
# -------------------------------------------------------------------------

FACTORY_DEF * TeeFactory   FACTORY_NAME "Final Output Nuker"   INPUT FEATURE_TYPE __nuke_me__


# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Massa_Dagua_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Massa_Dagua_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Massa_Dagua_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Massa_Dagua_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Massa_Dagua_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Massa_Dagua_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Massa_Dagua_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Massa_Dagua_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Massa_Dagua_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Massa_Dagua_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Massa_Dagua_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Massa_Dagua_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Massa_Dagua_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Massa_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c80_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Massa_Dagua_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Massa_Dagua_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Massa_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c80_thinPointCloud")
Tcl2 proc Massa_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c80_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Massa_Dagua_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Massa_Dagua_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Massa_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c80_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Massa_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c80_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Massa_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c80_VIS_FEAT_TYPE Massa_Dagua_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Massa_Dagua_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Massa_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c80_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Massa_Dagua_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Massa_Dagua_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {T_1_PolyErrors_Shape_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME T_1_PolyErrors_Shape_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_PolyErrors_Shape_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME T_1_PolyErrors_Shape_Index_FeatureDirector    INPUT  FEATURE_TYPE T_1_PolyErrors_Shape_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE T_1_PolyErrors_Shape_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE T_1_PolyErrors_Shape_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME T_1_PolyErrors_Shape_Index___FeatureDirector1    INPUT FEATURE_TYPE T_1_PolyErrors_Shape_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE T_1_PolyErrors_Shape_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE T_1_PolyErrors_Shape_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_PolyErrors_Shape_Index_VectorSetterUpper    INPUT FEATURE_TYPE T_1_PolyErrors_Shape_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc T_1_PolyErrors_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c81_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_PolyErrors_Shape_Index___PointCloudThinner    INPUT FEATURE_TYPE T_1_PolyErrors_Shape_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("T_1_PolyErrors_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c81_thinPointCloud")
Tcl2 proc T_1_PolyErrors_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c81_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_PolyErrors_Shape_Index_RasterSetterUpper    INPUT FEATURE_TYPE T_1_PolyErrors_Shape_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("T_1_PolyErrors_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c81_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# T_1_PolyErrors_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c81_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO T_1_PolyErrors_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c81_VIS_FEAT_TYPE T_1_PolyErrors_Shape_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME T_1_PolyErrors_Shape_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(T_1_PolyErrors_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c81_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "T_1_PolyErrors_Shape_Index Output Nuker"   INPUT FEATURE_TYPE T_1_PolyErrors_Shape_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Campo_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Campo_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Campo_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Campo_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Campo_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Campo_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Campo_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Campo_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Campo_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Campo_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Campo_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Campo_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c82_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Campo_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Campo_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c82_thinPointCloud")
Tcl2 proc Campo_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c82_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Campo_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Campo_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c82_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Campo_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c82_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Campo_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c82_VIS_FEAT_TYPE Campo_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Campo_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Campo_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c82_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Campo_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Campo_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Religiosa_polygon_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Religiosa_polygon_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Religiosa_polygon_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Religiosa_polygon_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Religiosa_polygon_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Religiosa_polygon_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Religiosa_polygon_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Religiosa_polygon_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Religiosa_polygon_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Religiosa_polygon_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Religiosa_polygon_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Religiosa_polygon_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Religiosa_polygon_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Religiosa_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c83_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Religiosa_polygon_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Religiosa_polygon_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Religiosa_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c83_thinPointCloud")
Tcl2 proc Edif_Religiosa_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c83_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Religiosa_polygon_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Religiosa_polygon_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Religiosa_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c83_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Religiosa_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c83_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Religiosa_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c83_VIS_FEAT_TYPE Edif_Religiosa_polygon_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Religiosa_polygon_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Religiosa_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c83_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Religiosa_polygon_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Religiosa_polygon_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Curva_Nivel_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Curva_Nivel_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Curva_Nivel_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Curva_Nivel_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Curva_Nivel_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Curva_Nivel_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Curva_Nivel_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Curva_Nivel_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Curva_Nivel_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Curva_Nivel_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Curva_Nivel_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Curva_Nivel_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Curva_Nivel_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Curva_Nivel_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c84_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Curva_Nivel_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Curva_Nivel_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Curva_Nivel_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c84_thinPointCloud")
Tcl2 proc Curva_Nivel_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c84_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Curva_Nivel_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Curva_Nivel_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Curva_Nivel_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c84_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Curva_Nivel_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c84_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Curva_Nivel_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c84_VIS_FEAT_TYPE Curva_Nivel_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Curva_Nivel_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Curva_Nivel_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c84_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Curva_Nivel_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Curva_Nivel_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Atracadouro_polygon_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Atracadouro_polygon_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Atracadouro_polygon_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Atracadouro_polygon_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Atracadouro_polygon_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Atracadouro_polygon_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Atracadouro_polygon_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Atracadouro_polygon_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Atracadouro_polygon_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Atracadouro_polygon_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Atracadouro_polygon_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Atracadouro_polygon_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Atracadouro_polygon_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Atracadouro_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c85_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Atracadouro_polygon_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Atracadouro_polygon_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Atracadouro_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c85_thinPointCloud")
Tcl2 proc Atracadouro_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c85_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Atracadouro_polygon_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Atracadouro_polygon_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Atracadouro_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c85_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Atracadouro_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c85_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Atracadouro_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c85_VIS_FEAT_TYPE Atracadouro_polygon_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Atracadouro_polygon_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Atracadouro_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c85_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Atracadouro_polygon_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Atracadouro_polygon_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Trecho_Rodoviario} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Trecho_Rodoviario_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Rodoviario_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Trecho_Rodoviario_FeatureDirector    INPUT  FEATURE_TYPE Trecho_Rodoviario    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Trecho_Rodoviario___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Trecho_Rodoviario___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Trecho_Rodoviario___FeatureDirector1    INPUT FEATURE_TYPE Trecho_Rodoviario___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Trecho_Rodoviario___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Trecho_Rodoviario___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Rodoviario_VectorSetterUpper    INPUT FEATURE_TYPE Trecho_Rodoviario___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Trecho_Rodoviario_02ece63d_469a_493c_80f3_1629478a34c86_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Rodoviario___PointCloudThinner    INPUT FEATURE_TYPE Trecho_Rodoviario___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trecho_Rodoviario_02ece63d_469a_493c_80f3_1629478a34c86_thinPointCloud")
Tcl2 proc Trecho_Rodoviario_02ece63d_469a_493c_80f3_1629478a34c86_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Rodoviario_RasterSetterUpper    INPUT FEATURE_TYPE Trecho_Rodoviario___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trecho_Rodoviario_02ece63d_469a_493c_80f3_1629478a34c86_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Trecho_Rodoviario_02ece63d_469a_493c_80f3_1629478a34c86_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Trecho_Rodoviario_02ece63d_469a_493c_80f3_1629478a34c86_VIS_FEAT_TYPE Trecho_Rodoviario$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Trecho_Rodoviario_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Trecho_Rodoviario_02ece63d_469a_493c_80f3_1629478a34c86_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,revestimento,varchar<openparen>255<closeparen>,nrPistas,varchar<openparen>255<closeparen>,trafego,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSet,varchar<openparen>255<closeparen>,sigla,varchar<openparen>255<closeparen>,administracao,varchar<openparen>255<closeparen>,velocidadeMedia,varchar<openparen>255<closeparen>,nrFaixas,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,codTrechoRodov,varchar<openparen>255<closeparen>,concessionaria,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,canteiroDivisorio,varchar<openparen>255<closeparen>,fkComplRodovia,varchar<openparen>255<closeparen>,tipoTrechoRod,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,pesoMaxSuportTon,varchar<openparen>255<closeparen>,jurisdicao,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Trecho_Rodoviario Output Nuker"   INPUT FEATURE_TYPE Trecho_Rodoviario

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Saude_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Saude_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saude_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Saude_point_FeatureDirector    INPUT  FEATURE_TYPE Edif_Saude_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Saude_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Saude_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Saude_point___FeatureDirector1    INPUT FEATURE_TYPE Edif_Saude_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Saude_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Saude_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saude_point_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Saude_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Saude_point_02ece63d_469a_493c_80f3_1629478a34c87_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saude_point___PointCloudThinner    INPUT FEATURE_TYPE Edif_Saude_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Saude_point_02ece63d_469a_493c_80f3_1629478a34c87_thinPointCloud")
Tcl2 proc Edif_Saude_point_02ece63d_469a_493c_80f3_1629478a34c87_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saude_point_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Saude_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Saude_point_02ece63d_469a_493c_80f3_1629478a34c87_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Saude_point_02ece63d_469a_493c_80f3_1629478a34c87_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Saude_point_02ece63d_469a_493c_80f3_1629478a34c87_VIS_FEAT_TYPE Edif_Saude_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Saude_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Saude_point_02ece63d_469a_493c_80f3_1629478a34c87_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,fkComplSaude,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,tipoClasseCnae,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,nivelAtencao,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Saude_point Output Nuker"   INPUT FEATURE_TYPE Edif_Saude_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Industrial_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Industrial_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Industrial_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Industrial_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Industrial_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Industrial_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Industrial_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Industrial_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Industrial_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Industrial_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Industrial_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Industrial_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Industrial_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Industrial_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c88_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Industrial_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Industrial_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Industrial_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c88_thinPointCloud")
Tcl2 proc Edif_Industrial_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c88_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Industrial_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Industrial_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Industrial_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c88_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Industrial_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c88_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Industrial_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c88_VIS_FEAT_TYPE Edif_Industrial_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Industrial_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Industrial_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c88_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Industrial_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Industrial_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Cidade_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Cidade_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Cidade_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Cidade_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Cidade_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Cidade_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Cidade_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Cidade_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Cidade_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Cidade_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Cidade_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Cidade_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Cidade_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Cidade_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c89_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Cidade_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Cidade_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Cidade_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c89_thinPointCloud")
Tcl2 proc Cidade_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c89_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Cidade_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Cidade_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Cidade_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c89_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Cidade_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c89_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Cidade_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c89_VIS_FEAT_TYPE Cidade_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Cidade_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Cidade_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c89_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Cidade_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Cidade_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Servico_Social_polygon} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Servico_Social_polygon_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Servico_Social_polygon_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Servico_Social_polygon_FeatureDirector    INPUT  FEATURE_TYPE Edif_Servico_Social_polygon    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Servico_Social_polygon___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Servico_Social_polygon___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Servico_Social_polygon___FeatureDirector1    INPUT FEATURE_TYPE Edif_Servico_Social_polygon___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Servico_Social_polygon___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Servico_Social_polygon___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Servico_Social_polygon_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Servico_Social_polygon___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Servico_Social_polygon_02ece63d_469a_493c_80f3_1629478a34c810_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Servico_Social_polygon___PointCloudThinner    INPUT FEATURE_TYPE Edif_Servico_Social_polygon___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Servico_Social_polygon_02ece63d_469a_493c_80f3_1629478a34c810_thinPointCloud")
Tcl2 proc Edif_Servico_Social_polygon_02ece63d_469a_493c_80f3_1629478a34c810_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Servico_Social_polygon_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Servico_Social_polygon___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Servico_Social_polygon_02ece63d_469a_493c_80f3_1629478a34c810_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Servico_Social_polygon_02ece63d_469a_493c_80f3_1629478a34c810_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Servico_Social_polygon_02ece63d_469a_493c_80f3_1629478a34c810_VIS_FEAT_TYPE Edif_Servico_Social_polygon$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Servico_Social_polygon_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Servico_Social_polygon_02ece63d_469a_493c_80f3_1629478a34c810_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,tipoClasseCnae,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,fkComplSvSoc,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Servico_Social_polygon Output Nuker"   INPUT FEATURE_TYPE Edif_Servico_Social_polygon

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Pto_Est_Med_Fenomenos_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Pto_Est_Med_Fenomenos_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Pto_Est_Med_Fenomenos_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Pto_Est_Med_Fenomenos_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Pto_Est_Med_Fenomenos_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Pto_Est_Med_Fenomenos_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Pto_Est_Med_Fenomenos_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Pto_Est_Med_Fenomenos_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Pto_Est_Med_Fenomenos_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Pto_Est_Med_Fenomenos_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Pto_Est_Med_Fenomenos_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Pto_Est_Med_Fenomenos_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Pto_Est_Med_Fenomenos_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Pto_Est_Med_Fenomenos_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c811_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Pto_Est_Med_Fenomenos_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Pto_Est_Med_Fenomenos_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Pto_Est_Med_Fenomenos_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c811_thinPointCloud")
Tcl2 proc Pto_Est_Med_Fenomenos_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c811_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Pto_Est_Med_Fenomenos_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Pto_Est_Med_Fenomenos_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Pto_Est_Med_Fenomenos_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c811_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Pto_Est_Med_Fenomenos_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c811_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Pto_Est_Med_Fenomenos_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c811_VIS_FEAT_TYPE Pto_Est_Med_Fenomenos_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Pto_Est_Med_Fenomenos_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Pto_Est_Med_Fenomenos_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c811_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Pto_Est_Med_Fenomenos_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Pto_Est_Med_Fenomenos_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Terreno_Suj_Inundacao_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Terreno_Suj_Inundacao_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Terreno_Suj_Inundacao_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Terreno_Suj_Inundacao_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Terreno_Suj_Inundacao_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Terreno_Suj_Inundacao_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Terreno_Suj_Inundacao_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Terreno_Suj_Inundacao_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Terreno_Suj_Inundacao_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Terreno_Suj_Inundacao_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Terreno_Suj_Inundacao_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Terreno_Suj_Inundacao_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Terreno_Suj_Inundacao_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Terreno_Suj_Inundacao_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c812_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Terreno_Suj_Inundacao_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Terreno_Suj_Inundacao_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Terreno_Suj_Inundacao_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c812_thinPointCloud")
Tcl2 proc Terreno_Suj_Inundacao_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c812_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Terreno_Suj_Inundacao_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Terreno_Suj_Inundacao_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Terreno_Suj_Inundacao_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c812_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Terreno_Suj_Inundacao_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c812_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Terreno_Suj_Inundacao_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c812_VIS_FEAT_TYPE Terreno_Suj_Inundacao_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Terreno_Suj_Inundacao_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Terreno_Suj_Inundacao_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c812_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Terreno_Suj_Inundacao_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Terreno_Suj_Inundacao_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Const_Aeroportuaria_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Const_Aeroportuaria_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Aeroportuaria_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Const_Aeroportuaria_point_FeatureDirector    INPUT  FEATURE_TYPE Edif_Const_Aeroportuaria_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Const_Aeroportuaria_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Const_Aeroportuaria_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Const_Aeroportuaria_point___FeatureDirector1    INPUT FEATURE_TYPE Edif_Const_Aeroportuaria_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Const_Aeroportuaria_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Const_Aeroportuaria_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Aeroportuaria_point_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Const_Aeroportuaria_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Const_Aeroportuaria_point_02ece63d_469a_493c_80f3_1629478a34c813_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Aeroportuaria_point___PointCloudThinner    INPUT FEATURE_TYPE Edif_Const_Aeroportuaria_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Const_Aeroportuaria_point_02ece63d_469a_493c_80f3_1629478a34c813_thinPointCloud")
Tcl2 proc Edif_Const_Aeroportuaria_point_02ece63d_469a_493c_80f3_1629478a34c813_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Aeroportuaria_point_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Const_Aeroportuaria_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Const_Aeroportuaria_point_02ece63d_469a_493c_80f3_1629478a34c813_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Const_Aeroportuaria_point_02ece63d_469a_493c_80f3_1629478a34c813_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Const_Aeroportuaria_point_02ece63d_469a_493c_80f3_1629478a34c813_VIS_FEAT_TYPE Edif_Const_Aeroportuaria_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Const_Aeroportuaria_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Const_Aeroportuaria_point_02ece63d_469a_493c_80f3_1629478a34c813_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,fkComplAeroport,varchar<openparen>255<closeparen>,tipoEdifAero,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,administracao,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Const_Aeroportuaria_point Output Nuker"   INPUT FEATURE_TYPE Edif_Const_Aeroportuaria_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Comerc_Serv_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Comerc_Serv_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comerc_Serv_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Comerc_Serv_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Comerc_Serv_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Comerc_Serv_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Comerc_Serv_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Comerc_Serv_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Comerc_Serv_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Comerc_Serv_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Comerc_Serv_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comerc_Serv_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Comerc_Serv_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Comerc_Serv_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c814_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comerc_Serv_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Comerc_Serv_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Comerc_Serv_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c814_thinPointCloud")
Tcl2 proc Edif_Comerc_Serv_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c814_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comerc_Serv_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Comerc_Serv_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Comerc_Serv_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c814_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Comerc_Serv_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c814_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Comerc_Serv_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c814_VIS_FEAT_TYPE Edif_Comerc_Serv_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Comerc_Serv_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Comerc_Serv_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c814_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Comerc_Serv_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Comerc_Serv_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Area_Ext_Mineral} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Area_Ext_Mineral_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Ext_Mineral_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Area_Ext_Mineral_FeatureDirector    INPUT  FEATURE_TYPE Area_Ext_Mineral    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Area_Ext_Mineral___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Ext_Mineral___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Area_Ext_Mineral___FeatureDirector1    INPUT FEATURE_TYPE Area_Ext_Mineral___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Area_Ext_Mineral___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Ext_Mineral___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Ext_Mineral_VectorSetterUpper    INPUT FEATURE_TYPE Area_Ext_Mineral___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Area_Ext_Mineral_02ece63d_469a_493c_80f3_1629478a34c815_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Ext_Mineral___PointCloudThinner    INPUT FEATURE_TYPE Area_Ext_Mineral___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Ext_Mineral_02ece63d_469a_493c_80f3_1629478a34c815_thinPointCloud")
Tcl2 proc Area_Ext_Mineral_02ece63d_469a_493c_80f3_1629478a34c815_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Ext_Mineral_RasterSetterUpper    INPUT FEATURE_TYPE Area_Ext_Mineral___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Ext_Mineral_02ece63d_469a_493c_80f3_1629478a34c815_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Area_Ext_Mineral_02ece63d_469a_493c_80f3_1629478a34c815_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Area_Ext_Mineral_02ece63d_469a_493c_80f3_1629478a34c815_VIS_FEAT_TYPE Area_Ext_Mineral$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Area_Ext_Mineral_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Area_Ext_Mineral_02ece63d_469a_493c_80f3_1629478a34c815_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkComplOrgExtMin,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Area_Ext_Mineral Output Nuker"   INPUT FEATURE_TYPE Area_Ext_Mineral

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Aglomerado_Rural} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Aglomerado_Rural_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Aglomerado_Rural_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Aglomerado_Rural_FeatureDirector    INPUT  FEATURE_TYPE Aglomerado_Rural    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Aglomerado_Rural___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Aglomerado_Rural___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Aglomerado_Rural___FeatureDirector1    INPUT FEATURE_TYPE Aglomerado_Rural___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Aglomerado_Rural___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Aglomerado_Rural___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Aglomerado_Rural_VectorSetterUpper    INPUT FEATURE_TYPE Aglomerado_Rural___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Aglomerado_Rural_02ece63d_469a_493c_80f3_1629478a34c816_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Aglomerado_Rural___PointCloudThinner    INPUT FEATURE_TYPE Aglomerado_Rural___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Aglomerado_Rural_02ece63d_469a_493c_80f3_1629478a34c816_thinPointCloud")
Tcl2 proc Aglomerado_Rural_02ece63d_469a_493c_80f3_1629478a34c816_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Aglomerado_Rural_RasterSetterUpper    INPUT FEATURE_TYPE Aglomerado_Rural___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Aglomerado_Rural_02ece63d_469a_493c_80f3_1629478a34c816_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Aglomerado_Rural_02ece63d_469a_493c_80f3_1629478a34c816_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Aglomerado_Rural_02ece63d_469a_493c_80f3_1629478a34c816_VIS_FEAT_TYPE Aglomerado_Rural$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Aglomerado_Rural_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Aglomerado_Rural_02ece63d_469a_493c_80f3_1629478a34c816_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,tipoAglomerado,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,identificadorPosicGeo,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,simbolizar,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,longitude,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,latitude,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,longitude_txt,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,tamanhoTxt,varchar<openparen>255<closeparen>,latitude_txt,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Aglomerado_Rural Output Nuker"   INPUT FEATURE_TYPE Aglomerado_Rural

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Saneamento_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Saneamento_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saneamento_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Saneamento_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Saneamento_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Saneamento_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Saneamento_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Saneamento_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Saneamento_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Saneamento_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Saneamento_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saneamento_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Saneamento_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Saneamento_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c817_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saneamento_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Saneamento_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Saneamento_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c817_thinPointCloud")
Tcl2 proc Edif_Saneamento_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c817_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saneamento_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Saneamento_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Saneamento_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c817_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Saneamento_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c817_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Saneamento_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c817_VIS_FEAT_TYPE Edif_Saneamento_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Saneamento_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Saneamento_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c817_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Saneamento_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Saneamento_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Ponto_Cotado_Altimetrico_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Ponto_Cotado_Altimetrico_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Cotado_Altimetrico_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Cotado_Altimetrico_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Ponto_Cotado_Altimetrico_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Ponto_Cotado_Altimetrico_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Cotado_Altimetrico_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Cotado_Altimetrico_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Ponto_Cotado_Altimetrico_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Ponto_Cotado_Altimetrico_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Cotado_Altimetrico_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Cotado_Altimetrico_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Ponto_Cotado_Altimetrico_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Ponto_Cotado_Altimetrico_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c818_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Cotado_Altimetrico_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Ponto_Cotado_Altimetrico_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Cotado_Altimetrico_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c818_thinPointCloud")
Tcl2 proc Ponto_Cotado_Altimetrico_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c818_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Cotado_Altimetrico_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Ponto_Cotado_Altimetrico_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Cotado_Altimetrico_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c818_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Ponto_Cotado_Altimetrico_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c818_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Ponto_Cotado_Altimetrico_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c818_VIS_FEAT_TYPE Ponto_Cotado_Altimetrico_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Ponto_Cotado_Altimetrico_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Ponto_Cotado_Altimetrico_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c818_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Ponto_Cotado_Altimetrico_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Ponto_Cotado_Altimetrico_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Cemiterio_polygon} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Cemiterio_polygon_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Cemiterio_polygon_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Cemiterio_polygon_FeatureDirector    INPUT  FEATURE_TYPE Cemiterio_polygon    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Cemiterio_polygon___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Cemiterio_polygon___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Cemiterio_polygon___FeatureDirector1    INPUT FEATURE_TYPE Cemiterio_polygon___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Cemiterio_polygon___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Cemiterio_polygon___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Cemiterio_polygon_VectorSetterUpper    INPUT FEATURE_TYPE Cemiterio_polygon___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Cemiterio_polygon_02ece63d_469a_493c_80f3_1629478a34c819_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Cemiterio_polygon___PointCloudThinner    INPUT FEATURE_TYPE Cemiterio_polygon___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Cemiterio_polygon_02ece63d_469a_493c_80f3_1629478a34c819_thinPointCloud")
Tcl2 proc Cemiterio_polygon_02ece63d_469a_493c_80f3_1629478a34c819_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Cemiterio_polygon_RasterSetterUpper    INPUT FEATURE_TYPE Cemiterio_polygon___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Cemiterio_polygon_02ece63d_469a_493c_80f3_1629478a34c819_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Cemiterio_polygon_02ece63d_469a_493c_80f3_1629478a34c819_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Cemiterio_polygon_02ece63d_469a_493c_80f3_1629478a34c819_VIS_FEAT_TYPE Cemiterio_polygon$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Cemiterio_polygon_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Cemiterio_polygon_02ece63d_469a_493c_80f3_1629478a34c819_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,denominacaoAssociada,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,tipoCemiterio,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Cemiterio_polygon Output Nuker"   INPUT FEATURE_TYPE Cemiterio_polygon

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Trecho_Massa_Dagua} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Trecho_Massa_Dagua_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Massa_Dagua_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Trecho_Massa_Dagua_FeatureDirector    INPUT  FEATURE_TYPE Trecho_Massa_Dagua    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Trecho_Massa_Dagua___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Trecho_Massa_Dagua___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Trecho_Massa_Dagua___FeatureDirector1    INPUT FEATURE_TYPE Trecho_Massa_Dagua___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Trecho_Massa_Dagua___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Trecho_Massa_Dagua___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Massa_Dagua_VectorSetterUpper    INPUT FEATURE_TYPE Trecho_Massa_Dagua___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Trecho_Massa_Dagua_02ece63d_469a_493c_80f3_1629478a34c820_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Massa_Dagua___PointCloudThinner    INPUT FEATURE_TYPE Trecho_Massa_Dagua___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trecho_Massa_Dagua_02ece63d_469a_493c_80f3_1629478a34c820_thinPointCloud")
Tcl2 proc Trecho_Massa_Dagua_02ece63d_469a_493c_80f3_1629478a34c820_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Massa_Dagua_RasterSetterUpper    INPUT FEATURE_TYPE Trecho_Massa_Dagua___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trecho_Massa_Dagua_02ece63d_469a_493c_80f3_1629478a34c820_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Trecho_Massa_Dagua_02ece63d_469a_493c_80f3_1629478a34c820_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Trecho_Massa_Dagua_02ece63d_469a_493c_80f3_1629478a34c820_VIS_FEAT_TYPE Trecho_Massa_Dagua$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Trecho_Massa_Dagua_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Trecho_Massa_Dagua_02ece63d_469a_493c_80f3_1629478a34c820_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,salinidade,varchar<openparen>255<closeparen>,regime,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,fkComplTrCurDagua,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,tipoMassaDagua,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Trecho_Massa_Dagua Output Nuker"   INPUT FEATURE_TYPE Trecho_Massa_Dagua

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {SelectedObjects} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME SelectedObjects_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME SelectedObjects_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME SelectedObjects_FeatureDirector    INPUT  FEATURE_TYPE SelectedObjects    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE SelectedObjects___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE SelectedObjects___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME SelectedObjects___FeatureDirector1    INPUT FEATURE_TYPE SelectedObjects___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE SelectedObjects___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE SelectedObjects___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME SelectedObjects_VectorSetterUpper    INPUT FEATURE_TYPE SelectedObjects___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc SelectedObjects_02ece63d_469a_493c_80f3_1629478a34c821_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME SelectedObjects___PointCloudThinner    INPUT FEATURE_TYPE SelectedObjects___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("SelectedObjects_02ece63d_469a_493c_80f3_1629478a34c821_thinPointCloud")
Tcl2 proc SelectedObjects_02ece63d_469a_493c_80f3_1629478a34c821_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME SelectedObjects_RasterSetterUpper    INPUT FEATURE_TYPE SelectedObjects___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("SelectedObjects_02ece63d_469a_493c_80f3_1629478a34c821_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# SelectedObjects_02ece63d_469a_493c_80f3_1629478a34c821_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO SelectedObjects_02ece63d_469a_493c_80f3_1629478a34c821_VIS_FEAT_TYPE SelectedObjects$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME SelectedObjects_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(SelectedObjects_02ece63d_469a_493c_80f3_1629478a34c821_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA SelectionID,varchar<openparen>255<closeparen>,ObjectID,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "SelectedObjects Output Nuker"   INPUT FEATURE_TYPE SelectedObjects

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Barragem_line} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Barragem_line_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Barragem_line_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Barragem_line_FeatureDirector    INPUT  FEATURE_TYPE Barragem_line    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Barragem_line___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Barragem_line___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Barragem_line___FeatureDirector1    INPUT FEATURE_TYPE Barragem_line___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Barragem_line___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Barragem_line___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Barragem_line_VectorSetterUpper    INPUT FEATURE_TYPE Barragem_line___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Barragem_line_02ece63d_469a_493c_80f3_1629478a34c822_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Barragem_line___PointCloudThinner    INPUT FEATURE_TYPE Barragem_line___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Barragem_line_02ece63d_469a_493c_80f3_1629478a34c822_thinPointCloud")
Tcl2 proc Barragem_line_02ece63d_469a_493c_80f3_1629478a34c822_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Barragem_line_RasterSetterUpper    INPUT FEATURE_TYPE Barragem_line___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Barragem_line_02ece63d_469a_493c_80f3_1629478a34c822_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Barragem_line_02ece63d_469a_493c_80f3_1629478a34c822_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Barragem_line_02ece63d_469a_493c_80f3_1629478a34c822_VIS_FEAT_TYPE Barragem_line$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Barragem_line_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Barragem_line_02ece63d_469a_493c_80f3_1629478a34c822_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,fkComplGerEnEletr,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,usoPrincipal,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,tamanhoTxt,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Barragem_line Output Nuker"   INPUT FEATURE_TYPE Barragem_line

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Ensino_polygon} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Ensino_polygon_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ensino_polygon_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Ensino_polygon_FeatureDirector    INPUT  FEATURE_TYPE Edif_Ensino_polygon    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Ensino_polygon___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Ensino_polygon___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Ensino_polygon___FeatureDirector1    INPUT FEATURE_TYPE Edif_Ensino_polygon___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Ensino_polygon___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Ensino_polygon___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ensino_polygon_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Ensino_polygon___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Ensino_polygon_02ece63d_469a_493c_80f3_1629478a34c823_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ensino_polygon___PointCloudThinner    INPUT FEATURE_TYPE Edif_Ensino_polygon___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Ensino_polygon_02ece63d_469a_493c_80f3_1629478a34c823_thinPointCloud")
Tcl2 proc Edif_Ensino_polygon_02ece63d_469a_493c_80f3_1629478a34c823_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ensino_polygon_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Ensino_polygon___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Ensino_polygon_02ece63d_469a_493c_80f3_1629478a34c823_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Ensino_polygon_02ece63d_469a_493c_80f3_1629478a34c823_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Ensino_polygon_02ece63d_469a_493c_80f3_1629478a34c823_VIS_FEAT_TYPE Edif_Ensino_polygon$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Ensino_polygon_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Ensino_polygon_02ece63d_469a_493c_80f3_1629478a34c823_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,tipoClasseCnae,varchar<openparen>255<closeparen>,fkComplOrgEnsino,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Ensino_polygon Output Nuker"   INPUT FEATURE_TYPE Edif_Ensino_polygon

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Deposito_Geral_polygon} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Deposito_Geral_polygon_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Deposito_Geral_polygon_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Deposito_Geral_polygon_FeatureDirector    INPUT  FEATURE_TYPE Deposito_Geral_polygon    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Deposito_Geral_polygon___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Deposito_Geral_polygon___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Deposito_Geral_polygon___FeatureDirector1    INPUT FEATURE_TYPE Deposito_Geral_polygon___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Deposito_Geral_polygon___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Deposito_Geral_polygon___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Deposito_Geral_polygon_VectorSetterUpper    INPUT FEATURE_TYPE Deposito_Geral_polygon___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Deposito_Geral_polygon_02ece63d_469a_493c_80f3_1629478a34c824_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Deposito_Geral_polygon___PointCloudThinner    INPUT FEATURE_TYPE Deposito_Geral_polygon___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Deposito_Geral_polygon_02ece63d_469a_493c_80f3_1629478a34c824_thinPointCloud")
Tcl2 proc Deposito_Geral_polygon_02ece63d_469a_493c_80f3_1629478a34c824_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Deposito_Geral_polygon_RasterSetterUpper    INPUT FEATURE_TYPE Deposito_Geral_polygon___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Deposito_Geral_polygon_02ece63d_469a_493c_80f3_1629478a34c824_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Deposito_Geral_polygon_02ece63d_469a_493c_80f3_1629478a34c824_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Deposito_Geral_polygon_02ece63d_469a_493c_80f3_1629478a34c824_VIS_FEAT_TYPE Deposito_Geral_polygon$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Deposito_Geral_polygon_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Deposito_Geral_polygon_02ece63d_469a_493c_80f3_1629478a34c824_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,tipoExposicao,varchar<openparen>255<closeparen>,fkComplOrgExtMin,varchar<openparen>255<closeparen>,fkComplAeroport,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,tipoProdutoResiduo,varchar<openparen>255<closeparen>,tipoConteudo,varchar<openparen>255<closeparen>,valorVolume,varchar<openparen>255<closeparen>,fkComplOrgComSv,varchar<openparen>255<closeparen>,tratamento,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,fkComplIndustria,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,fkComplPortuario,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,fkComplGerEnEletr,varchar<openparen>255<closeparen>,fkComplOrgAgrop,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,tipoDepGeral,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,fkComplEstrApoio,varchar<openparen>255<closeparen>,unidadeVolume,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Deposito_Geral_polygon Output Nuker"   INPUT FEATURE_TYPE Deposito_Geral_polygon

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Atracadouro_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Atracadouro_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Atracadouro_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Atracadouro_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Atracadouro_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Atracadouro_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Atracadouro_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Atracadouro_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Atracadouro_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Atracadouro_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Atracadouro_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Atracadouro_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Atracadouro_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Atracadouro_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c825_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Atracadouro_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Atracadouro_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Atracadouro_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c825_thinPointCloud")
Tcl2 proc Atracadouro_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c825_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Atracadouro_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Atracadouro_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Atracadouro_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c825_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Atracadouro_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c825_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Atracadouro_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c825_VIS_FEAT_TYPE Atracadouro_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Atracadouro_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Atracadouro_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c825_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Atracadouro_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Atracadouro_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Dep_Abast_Agua_point__Redirect_to_Inspection_Application_} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Dep_Abast_Agua_point__Redirect_to_Inspection_Application__DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Abast_Agua_point__Redirect_to_Inspection_Application__DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Dep_Abast_Agua_point__Redirect_to_Inspection_Application__FeatureDirector    INPUT  FEATURE_TYPE Dep_Abast_Agua_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Dep_Abast_Agua_point__Redirect_to_Inspection_Application____NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Dep_Abast_Agua_point__Redirect_to_Inspection_Application____RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Dep_Abast_Agua_point__Redirect_to_Inspection_Application____FeatureDirector1    INPUT FEATURE_TYPE Dep_Abast_Agua_point__Redirect_to_Inspection_Application____NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Dep_Abast_Agua_point__Redirect_to_Inspection_Application____VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Dep_Abast_Agua_point__Redirect_to_Inspection_Application____PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Abast_Agua_point__Redirect_to_Inspection_Application__VectorSetterUpper    INPUT FEATURE_TYPE Dep_Abast_Agua_point__Redirect_to_Inspection_Application____VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Dep_Abast_Agua_point__Redirect_to_Inspection_Application__02ece63d_469a_493c_80f3_1629478a34c826_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Abast_Agua_point__Redirect_to_Inspection_Application____PointCloudThinner    INPUT FEATURE_TYPE Dep_Abast_Agua_point__Redirect_to_Inspection_Application____PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Dep_Abast_Agua_point__Redirect_to_Inspection_Application__02ece63d_469a_493c_80f3_1629478a34c826_thinPointCloud")
Tcl2 proc Dep_Abast_Agua_point__Redirect_to_Inspection_Application__02ece63d_469a_493c_80f3_1629478a34c826_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Abast_Agua_point__Redirect_to_Inspection_Application__RasterSetterUpper    INPUT FEATURE_TYPE Dep_Abast_Agua_point__Redirect_to_Inspection_Application____RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Dep_Abast_Agua_point__Redirect_to_Inspection_Application__02ece63d_469a_493c_80f3_1629478a34c826_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Dep_Abast_Agua_point__Redirect_to_Inspection_Application__02ece63d_469a_493c_80f3_1629478a34c826_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Dep_Abast_Agua_point__Redirect_to_Inspection_Application__02ece63d_469a_493c_80f3_1629478a34c826_VIS_FEAT_TYPE Dep_Abast_Agua_point__Redirect_to_Inspection_Application_$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Dep_Abast_Agua_point__Redirect_to_Inspection_Application__Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Dep_Abast_Agua_point__Redirect_to_Inspection_Application__02ece63d_469a_493c_80f3_1629478a34c826_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,fkComplOrgExtMin,varchar<openparen>255<closeparen>,fkComplOrgComSv,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,fkComplIndustria,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,construcao,varchar<openparen>255<closeparen>,fkComplAbsAgua,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,finalidade,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,fkComplOrgAgrop,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,situacaoAgua,varchar<openparen>255<closeparen>,tipoDepAbast,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Dep_Abast_Agua_point_(Redirect_to_Inspection_Application) Output Nuker"   INPUT FEATURE_TYPE Dep_Abast_Agua_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Const_Aeroportuaria_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Const_Aeroportuaria_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Aeroportuaria_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Const_Aeroportuaria_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Const_Aeroportuaria_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Const_Aeroportuaria_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Const_Aeroportuaria_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Const_Aeroportuaria_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Const_Aeroportuaria_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Const_Aeroportuaria_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Const_Aeroportuaria_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Aeroportuaria_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Const_Aeroportuaria_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Const_Aeroportuaria_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c827_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Aeroportuaria_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Const_Aeroportuaria_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Const_Aeroportuaria_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c827_thinPointCloud")
Tcl2 proc Edif_Const_Aeroportuaria_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c827_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Aeroportuaria_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Const_Aeroportuaria_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Const_Aeroportuaria_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c827_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Const_Aeroportuaria_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c827_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Const_Aeroportuaria_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c827_VIS_FEAT_TYPE Edif_Const_Aeroportuaria_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Const_Aeroportuaria_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Const_Aeroportuaria_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c827_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Const_Aeroportuaria_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Const_Aeroportuaria_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Caatinga} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Caatinga_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Caatinga_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Caatinga_FeatureDirector    INPUT  FEATURE_TYPE Caatinga    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Caatinga___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Caatinga___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Caatinga___FeatureDirector1    INPUT FEATURE_TYPE Caatinga___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Caatinga___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Caatinga___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Caatinga_VectorSetterUpper    INPUT FEATURE_TYPE Caatinga___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Caatinga_02ece63d_469a_493c_80f3_1629478a34c828_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Caatinga___PointCloudThinner    INPUT FEATURE_TYPE Caatinga___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Caatinga_02ece63d_469a_493c_80f3_1629478a34c828_thinPointCloud")
Tcl2 proc Caatinga_02ece63d_469a_493c_80f3_1629478a34c828_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Caatinga_RasterSetterUpper    INPUT FEATURE_TYPE Caatinga___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Caatinga_02ece63d_469a_493c_80f3_1629478a34c828_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Caatinga_02ece63d_469a_493c_80f3_1629478a34c828_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Caatinga_02ece63d_469a_493c_80f3_1629478a34c828_VIS_FEAT_TYPE Caatinga$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Caatinga_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Caatinga_02ece63d_469a_493c_80f3_1629478a34c828_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,alturaMediaIndividuos,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,classificacaoPorte,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,denso,varchar<openparen>255<closeparen>,antropizada,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Caatinga Output Nuker"   INPUT FEATURE_TYPE Caatinga

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Veg_Cultivada_SHAPE_Index00} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Veg_Cultivada_SHAPE_Index00_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Veg_Cultivada_SHAPE_Index00_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Veg_Cultivada_SHAPE_Index00_FeatureDirector    INPUT  FEATURE_TYPE Veg_Cultivada_SHAPE_Index00    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Veg_Cultivada_SHAPE_Index00___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Veg_Cultivada_SHAPE_Index00___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Veg_Cultivada_SHAPE_Index00___FeatureDirector1    INPUT FEATURE_TYPE Veg_Cultivada_SHAPE_Index00___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Veg_Cultivada_SHAPE_Index00___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Veg_Cultivada_SHAPE_Index00___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Veg_Cultivada_SHAPE_Index00_VectorSetterUpper    INPUT FEATURE_TYPE Veg_Cultivada_SHAPE_Index00___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Veg_Cultivada_SHAPE_Index00_02ece63d_469a_493c_80f3_1629478a34c829_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Veg_Cultivada_SHAPE_Index00___PointCloudThinner    INPUT FEATURE_TYPE Veg_Cultivada_SHAPE_Index00___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Veg_Cultivada_SHAPE_Index00_02ece63d_469a_493c_80f3_1629478a34c829_thinPointCloud")
Tcl2 proc Veg_Cultivada_SHAPE_Index00_02ece63d_469a_493c_80f3_1629478a34c829_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Veg_Cultivada_SHAPE_Index00_RasterSetterUpper    INPUT FEATURE_TYPE Veg_Cultivada_SHAPE_Index00___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Veg_Cultivada_SHAPE_Index00_02ece63d_469a_493c_80f3_1629478a34c829_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Veg_Cultivada_SHAPE_Index00_02ece63d_469a_493c_80f3_1629478a34c829_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Veg_Cultivada_SHAPE_Index00_02ece63d_469a_493c_80f3_1629478a34c829_VIS_FEAT_TYPE Veg_Cultivada_SHAPE_Index00$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Veg_Cultivada_SHAPE_Index00_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Veg_Cultivada_SHAPE_Index00_02ece63d_469a_493c_80f3_1629478a34c829_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>,ExtentRight,varchar<openparen>255<closeparen>,OriginClassID,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,tipoEdifAero,varchar<openparen>255<closeparen>,nrPistas,varchar<openparen>255<closeparen>,tipoCemiterio,varchar<openparen>255<closeparen>,FieldName,varchar<openparen>255<closeparen>,IsRetired,varchar<openparen>255<closeparen>,MUnits,varchar<openparen>255<closeparen>,MLow,varchar<openparen>255<closeparen>,fkComplDuto,varchar<openparen>255<closeparen>,DirtyArea,varchar<openparen>255<closeparen>,SRTEXT,varchar<openparen>255<closeparen>,TargetGen,varchar<openparen>255<closeparen>,tipoResiduo,varchar<openparen>255<closeparen>,tipoAglomerado,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,LockID,varchar<openparen>255<closeparen>,nrDutos,varchar<openparen>255<closeparen>,ZUnits,varchar<openparen>255<closeparen>,ExtentTop,varchar<openparen>255<closeparen>,tipoDivisaoCnae,varchar<openparen>255<closeparen>,relacionado,varchar<openparen>255<closeparen>,ZLow,varchar<openparen>255<closeparen>,fkComplEstrApoio,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,classificacaoPorte,varchar<openparen>255<closeparen>,tipoEdifAgropec,varchar<openparen>255<closeparen>,salinidade,varchar<openparen>255<closeparen>,posicaoPista,varchar<openparen>255<closeparen>,causa,varchar<openparen>255<closeparen>,denominacaoAssociada,varchar<openparen>255<closeparen>,longitude_txt,varchar<openparen>255<closeparen>,nrFaixas,varchar<openparen>255<closeparen>,tamanhoTxt,varchar<openparen>255<closeparen>,tipoConteudo,varchar<openparen>255<closeparen>,IdxOriginY,varchar<openparen>255<closeparen>,situacaoEspacial,varchar<openparen>255<closeparen>,tipoEdifRod,varchar<openparen>255<closeparen>,tipoTrechoRod,varchar<openparen>255<closeparen>,situacaoEmAgua,varchar<openparen>255<closeparen>,tensaoEletrica,varchar<openparen>255<closeparen>,tipoTerrExp,varchar<openparen>255<closeparen>,tipoEdifTurist,varchar<openparen>255<closeparen>,vaoLivreHoriz,varchar<openparen>255<closeparen>,fkComplOrgEnsino,varchar<openparen>255<closeparen>,DatasetSubtype1,varchar<openparen>255<closeparen>,velocidadeMedCorrente,varchar<openparen>255<closeparen>,XYTolerance,varchar<openparen>255<closeparen>,jurisdicao,varchar<openparen>255<closeparen>,SourceBeginGen,varchar<openparen>255<closeparen>,tipoUsoEdif,varchar<openparen>255<closeparen>,Type,varchar<openparen>255<closeparen>,tipoEstGerad,varchar<openparen>255<closeparen>,DirtyArea_Length,varchar<openparen>255<closeparen>,repTipoTxt,varchar<openparen>255<closeparen>,fkComplRodovia,varchar<openparen>255<closeparen>,DatasetSubtype2,varchar<openparen>255<closeparen>,pesoMaxSuportTon,varchar<openparen>255<closeparen>,causaExposicao,varchar<openparen>255<closeparen>,HasM,varchar<openparen>255<closeparen>,FalseM,varchar<openparen>255<closeparen>,tipoDepAbast,varchar<openparen>255<closeparen>,potenciaFiscalizadaKW,varchar<openparen>255<closeparen>,DestID,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,IdxOriginX,varchar<openparen>255<closeparen>,OrigItemTypeID,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizar,varchar<openparen>255<closeparen>,Defaults,varchar<openparen>255<closeparen>,matTransp,varchar<openparen>255<closeparen>,tipoEdif,varchar<openparen>255<closeparen>,tipoExposicao,varchar<openparen>255<closeparen>,DatasetInfo1,varchar<openparen>255<closeparen>,destEnergElet,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,indice,varchar<openparen>255<closeparen>,tipoAreaUsoComun,varchar<openparen>255<closeparen>,Shape,varchar<openparen>255<closeparen>,emDuto,varchar<openparen>255<closeparen>,ReplicaID,varchar<openparen>255<closeparen>,terreno,varchar<openparen>255<closeparen>,fkComplIndustria,varchar<openparen>255<closeparen>,denso,varchar<openparen>255<closeparen>,canteiroDivisorio,varchar<openparen>255<closeparen>,tipoEdifLazer,varchar<openparen>255<closeparen>,coincideComDentroDe,varchar<openparen>255<closeparen>,dentroDePoligono,varchar<openparen>255<closeparen>,ShapeType,varchar<openparen>255<closeparen>,tipoCampo,varchar<openparen>255<closeparen>,tipoBanco,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>,tipoLimMassa,varchar<openparen>255<closeparen>,homologacao,varchar<openparen>255<closeparen>,especie,varchar<openparen>255<closeparen>,fkComplOrgAgrop,varchar<openparen>255<closeparen>,alturaEstimada,varchar<openparen>255<closeparen>,latitude,varchar<openparen>255<closeparen>,tipoPonte,varchar<openparen>255<closeparen>,larguraMedia,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,BackwardLabel,varchar<openparen>255<closeparen>,codigoEstacao,varchar<openparen>255<closeparen>,modalidade,varchar<openparen>255<closeparen>,IsContainment,varchar<openparen>255<closeparen>,situacaoAgua,varchar<openparen>255<closeparen>,tipoPtoEnergia,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,ExtentBottom,varchar<openparen>255<closeparen>,setor,varchar<openparen>255<closeparen>,qualidAgua,varchar<openparen>255<closeparen>,tipoEdifComunic,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,fkComplEstMedFen,varchar<openparen>255<closeparen>,MachineName,varchar<openparen>255<closeparen>,latitude_txt,varchar<openparen>255<closeparen>,tipoElemNat,varchar<openparen>255<closeparen>,tipoDelimFis,varchar<openparen>255<closeparen>,ZHigh,varchar<openparen>255<closeparen>,fkComplPubCivil,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,SelectionID,varchar<openparen>255<closeparen>,TableName,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,valorVolume,varchar<openparen>255<closeparen>,construcao,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,tipoPista,varchar<openparen>255<closeparen>,profundidadeMedia,varchar<openparen>255<closeparen>,revestimento,varchar<openparen>255<closeparen>,ovgd,varchar<openparen>255<closeparen>,DirtyArea_Area,varchar<openparen>255<closeparen>,tipoCampoQuadra,varchar<openparen>255<closeparen>,ParentTypeID,varchar<openparen>255<closeparen>,XYUnits,varchar<openparen>255<closeparen>,OriginID,varchar<openparen>255<closeparen>,tipoAtracad,varchar<openparen>255<closeparen>,tipoDepSaneam,varchar<openparen>255<closeparen>,cota,varchar<openparen>255<closeparen>,fkComplSvSoc,varchar<openparen>255<closeparen>,tipoCerr,varchar<openparen>255<closeparen>,largura,varchar<openparen>255<closeparen>,fkComplOrgRel,varchar<openparen>255<closeparen>,modalUso,varchar<openparen>255<closeparen>,periodicidadeInunda,varchar<openparen>255<closeparen>,Name,varchar<openparen>255<closeparen>,tipoLavoura,varchar<openparen>255<closeparen>,Attributes,varchar<openparen>255<closeparen>,ordemTickDepressao,varchar<openparen>255<closeparen>,necessidadeManutencao,varchar<openparen>255<closeparen>,religiao,varchar<openparen>255<closeparen>,espacamentoIndividuos,varchar<openparen>255<closeparen>,tipoPtoEstMed,varchar<openparen>255<closeparen>,espessuraDAP,varchar<openparen>255<closeparen>,tipoEdifRelig,varchar<openparen>255<closeparen>,tipoTravessia,varchar<openparen>255<closeparen>,FalseZ,varchar<openparen>255<closeparen>,tipoDepGeral,varchar<openparen>255<closeparen>,Shape_Area,varchar<openparen>255<closeparen>,ID,varchar<openparen>255<closeparen>,ExtentLeft,varchar<openparen>255<closeparen>,tipoSumVert,varchar<openparen>255<closeparen>,Properties,varchar<openparen>255<closeparen>,fkComplComunic,varchar<openparen>255<closeparen>,unidadeVolume,varchar<openparen>255<closeparen>,fkComplAbsAgua,varchar<openparen>255<closeparen>,emMassaDagua,varchar<openparen>255<closeparen>,IdxGridSize,varchar<openparen>255<closeparen>,ErrorCode,varchar<openparen>255<closeparen>,UserName,varchar<openparen>255<closeparen>,fkComplTrCurDagua,varchar<openparen>255<closeparen>,orgaoEnteResp,varchar<openparen>255<closeparen>,MTolerance,varchar<openparen>255<closeparen>,fkComplPortuario,varchar<openparen>255<closeparen>,eixoPrincipal,varchar<openparen>255<closeparen>,fkComplHabit,varchar<openparen>255<closeparen>,tipoTrechoDuto,varchar<openparen>255<closeparen>,IsHighPrecision,varchar<openparen>255<closeparen>,tipoFonteDagua,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,tipoProdutoResiduo,varchar<openparen>255<closeparen>,tipoEntroncamento,varchar<openparen>255<closeparen>,ocorrenciaEm,varchar<openparen>255<closeparen>,velocidadeMedia,varchar<openparen>255<closeparen>,sigla,varchar<openparen>255<closeparen>,Shape_Length,varchar<openparen>255<closeparen>,PhysicalName,varchar<openparen>255<closeparen>,eletrificada,varchar<openparen>255<closeparen>,OBJECTID,varchar<openparen>255<closeparen>,regime,varchar<openparen>255<closeparen>,fkComplLazer,varchar<openparen>255<closeparen>,administracao,varchar<openparen>255<closeparen>,TargetName,varchar<openparen>255<closeparen>,ZTolerance,varchar<openparen>255<closeparen>,tipoEdifSaneam,varchar<openparen>255<closeparen>,cultivoPredominante,varchar<openparen>255<closeparen>,Event,varchar<openparen>255<closeparen>,caladoMax,varchar<openparen>255<closeparen>,tipoEdifAbast,varchar<openparen>255<closeparen>,ForwardLabel,varchar<openparen>255<closeparen>,FalseY,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,codEstacao,varchar<openparen>255<closeparen>,fkComplSubEnEletr,varchar<openparen>255<closeparen>,FalseX,varchar<openparen>255<closeparen>,Documentation,varchar<openparen>255<closeparen>,cotaComprovada,varchar<openparen>255<closeparen>,offSet,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,chamine,varchar<openparen>255<closeparen>,compartilhado,varchar<openparen>255<closeparen>,DestClassID,varchar<openparen>255<closeparen>,extensao,varchar<openparen>255<closeparen>,Path,varchar<openparen>255<closeparen>,antropizada,varchar<openparen>255<closeparen>,HasZ,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nascente,varchar<openparen>255<closeparen>,fkComplAeroport,varchar<openparen>255<closeparen>,posicaoRelativa,varchar<openparen>255<closeparen>,longitude,varchar<openparen>255<closeparen>,alturaMediaMargem,varchar<openparen>255<closeparen>,fkComplMilitar,varchar<openparen>255<closeparen>,usoPista,varchar<openparen>255<closeparen>,IsException,varchar<openparen>255<closeparen>,LogDate,varchar<openparen>255<closeparen>,fkComplOrgExtMin,varchar<openparen>255<closeparen>,tipoClasseCnae,varchar<openparen>255<closeparen>,navegabilidade,varchar<openparen>255<closeparen>,LockType,varchar<openparen>255<closeparen>,vaoVertical,varchar<openparen>255<closeparen>,fkComplGerEnEletr,varchar<openparen>255<closeparen>,fkComplOrgComSv,varchar<openparen>255<closeparen>,UUID,varchar<openparen>255<closeparen>,tipoAlterAntrop,varchar<openparen>255<closeparen>,TopoRuleID,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,cotadaPorProcesso,varchar<openparen>255<closeparen>,columnFlags,varchar<openparen>255<closeparen>,usoPrincipal,varchar<openparen>255<closeparen>,depressao,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,nivelAtencao,varchar<openparen>255<closeparen>,SRID,varchar<openparen>255<closeparen>,identificadorPosicGeo,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,ObjectID,varchar<openparen>255<closeparen>,trafego,varchar<openparen>255<closeparen>,DestItemTypeID,varchar<openparen>255<closeparen>,URL,varchar<openparen>255<closeparen>,codTrechoRodov,varchar<openparen>255<closeparen>,tipoEdifComercServ,varchar<openparen>255<closeparen>,materialPredominante,varchar<openparen>255<closeparen>,Definition,varchar<openparen>255<closeparen>,fkComplSaneam,varchar<openparen>255<closeparen>,tratamento,varchar<openparen>255<closeparen>,fkComplSaude,varchar<openparen>255<closeparen>,residuo,varchar<openparen>255<closeparen>,posicaoRelEdific,varchar<openparen>255<closeparen>,ensino,varchar<openparen>255<closeparen>,alturaMediaIndividuos,varchar<openparen>255<closeparen>,MHigh,varchar<openparen>255<closeparen>,potenciaOutorgadaKW,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,tipoMassaDagua,varchar<openparen>255<closeparen>,TopoRuleType,varchar<openparen>255<closeparen>,numCircuitos,varchar<openparen>255<closeparen>,SourceEndGen,varchar<openparen>255<closeparen>,tipoCidade,varchar<openparen>255<closeparen>,visivel,varchar<openparen>255<closeparen>,concessionaria,varchar<openparen>255<closeparen>,finalidade,varchar<openparen>255<closeparen>,ItemInfo,varchar<openparen>255<closeparen>,DatasetInfo2,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Veg_Cultivada_SHAPE_Index00 Output Nuker"   INPUT FEATURE_TYPE Veg_Cultivada_SHAPE_Index00

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Ponto_Duto} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Ponto_Duto_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Duto_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Duto_FeatureDirector    INPUT  FEATURE_TYPE Ponto_Duto    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Ponto_Duto___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Duto___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Duto___FeatureDirector1    INPUT FEATURE_TYPE Ponto_Duto___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Ponto_Duto___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Duto___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Duto_VectorSetterUpper    INPUT FEATURE_TYPE Ponto_Duto___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Ponto_Duto_02ece63d_469a_493c_80f3_1629478a34c830_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Duto___PointCloudThinner    INPUT FEATURE_TYPE Ponto_Duto___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Duto_02ece63d_469a_493c_80f3_1629478a34c830_thinPointCloud")
Tcl2 proc Ponto_Duto_02ece63d_469a_493c_80f3_1629478a34c830_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Duto_RasterSetterUpper    INPUT FEATURE_TYPE Ponto_Duto___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Duto_02ece63d_469a_493c_80f3_1629478a34c830_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Ponto_Duto_02ece63d_469a_493c_80f3_1629478a34c830_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Ponto_Duto_02ece63d_469a_493c_80f3_1629478a34c830_VIS_FEAT_TYPE Ponto_Duto$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Ponto_Duto_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Ponto_Duto_02ece63d_469a_493c_80f3_1629478a34c830_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,relacionado,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Ponto_Duto Output Nuker"   INPUT FEATURE_TYPE Ponto_Duto

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Pub_Civil_polygon} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Pub_Civil_polygon_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Civil_polygon_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Pub_Civil_polygon_FeatureDirector    INPUT  FEATURE_TYPE Edif_Pub_Civil_polygon    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Pub_Civil_polygon___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Pub_Civil_polygon___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Pub_Civil_polygon___FeatureDirector1    INPUT FEATURE_TYPE Edif_Pub_Civil_polygon___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Pub_Civil_polygon___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Pub_Civil_polygon___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Civil_polygon_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Pub_Civil_polygon___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Pub_Civil_polygon_02ece63d_469a_493c_80f3_1629478a34c831_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Civil_polygon___PointCloudThinner    INPUT FEATURE_TYPE Edif_Pub_Civil_polygon___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Pub_Civil_polygon_02ece63d_469a_493c_80f3_1629478a34c831_thinPointCloud")
Tcl2 proc Edif_Pub_Civil_polygon_02ece63d_469a_493c_80f3_1629478a34c831_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Civil_polygon_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Pub_Civil_polygon___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Pub_Civil_polygon_02ece63d_469a_493c_80f3_1629478a34c831_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Pub_Civil_polygon_02ece63d_469a_493c_80f3_1629478a34c831_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Pub_Civil_polygon_02ece63d_469a_493c_80f3_1629478a34c831_VIS_FEAT_TYPE Edif_Pub_Civil_polygon$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Pub_Civil_polygon_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Pub_Civil_polygon_02ece63d_469a_493c_80f3_1629478a34c831_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,fkComplPubCivil,varchar<openparen>255<closeparen>,tipoEdif,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,tipoUsoEdif,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Pub_Civil_polygon Output Nuker"   INPUT FEATURE_TYPE Edif_Pub_Civil_polygon

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Ext_Mineral_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Ext_Mineral_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ext_Mineral_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Ext_Mineral_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Ext_Mineral_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Ext_Mineral_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Ext_Mineral_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Ext_Mineral_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Ext_Mineral_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Ext_Mineral_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Ext_Mineral_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ext_Mineral_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Ext_Mineral_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Ext_Mineral_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c832_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ext_Mineral_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Ext_Mineral_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Ext_Mineral_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c832_thinPointCloud")
Tcl2 proc Edif_Ext_Mineral_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c832_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ext_Mineral_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Ext_Mineral_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Ext_Mineral_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c832_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Ext_Mineral_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c832_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Ext_Mineral_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c832_VIS_FEAT_TYPE Edif_Ext_Mineral_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Ext_Mineral_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Ext_Mineral_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c832_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Ext_Mineral_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Ext_Mineral_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Campo_Quadra_polygon_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Campo_Quadra_polygon_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_Quadra_polygon_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Campo_Quadra_polygon_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Campo_Quadra_polygon_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Campo_Quadra_polygon_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Campo_Quadra_polygon_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Campo_Quadra_polygon_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Campo_Quadra_polygon_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Campo_Quadra_polygon_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Campo_Quadra_polygon_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_Quadra_polygon_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Campo_Quadra_polygon_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Campo_Quadra_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c833_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_Quadra_polygon_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Campo_Quadra_polygon_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Campo_Quadra_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c833_thinPointCloud")
Tcl2 proc Campo_Quadra_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c833_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_Quadra_polygon_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Campo_Quadra_polygon_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Campo_Quadra_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c833_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Campo_Quadra_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c833_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Campo_Quadra_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c833_VIS_FEAT_TYPE Campo_Quadra_polygon_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Campo_Quadra_polygon_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Campo_Quadra_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c833_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Campo_Quadra_polygon_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Campo_Quadra_polygon_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Arruamento} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Arruamento_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Arruamento_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Arruamento_FeatureDirector    INPUT  FEATURE_TYPE Arruamento    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Arruamento___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Arruamento___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Arruamento___FeatureDirector1    INPUT FEATURE_TYPE Arruamento___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Arruamento___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Arruamento___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Arruamento_VectorSetterUpper    INPUT FEATURE_TYPE Arruamento___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Arruamento_02ece63d_469a_493c_80f3_1629478a34c834_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Arruamento___PointCloudThinner    INPUT FEATURE_TYPE Arruamento___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Arruamento_02ece63d_469a_493c_80f3_1629478a34c834_thinPointCloud")
Tcl2 proc Arruamento_02ece63d_469a_493c_80f3_1629478a34c834_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Arruamento_RasterSetterUpper    INPUT FEATURE_TYPE Arruamento___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Arruamento_02ece63d_469a_493c_80f3_1629478a34c834_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Arruamento_02ece63d_469a_493c_80f3_1629478a34c834_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Arruamento_02ece63d_469a_493c_80f3_1629478a34c834_VIS_FEAT_TYPE Arruamento$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Arruamento_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Arruamento_02ece63d_469a_493c_80f3_1629478a34c834_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,revestimento,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,nrFaixas,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,trafego,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,canteiroDivisorio,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Arruamento Output Nuker"   INPUT FEATURE_TYPE Arruamento

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Ponto_Rodoviario_Ferrov} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Ponto_Rodoviario_Ferrov_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Rodoviario_Ferrov_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Rodoviario_Ferrov_FeatureDirector    INPUT  FEATURE_TYPE Ponto_Rodoviario_Ferrov    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Ponto_Rodoviario_Ferrov___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Rodoviario_Ferrov___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Rodoviario_Ferrov___FeatureDirector1    INPUT FEATURE_TYPE Ponto_Rodoviario_Ferrov___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Ponto_Rodoviario_Ferrov___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Rodoviario_Ferrov___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Rodoviario_Ferrov_VectorSetterUpper    INPUT FEATURE_TYPE Ponto_Rodoviario_Ferrov___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Ponto_Rodoviario_Ferrov_02ece63d_469a_493c_80f3_1629478a34c835_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Rodoviario_Ferrov___PointCloudThinner    INPUT FEATURE_TYPE Ponto_Rodoviario_Ferrov___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Rodoviario_Ferrov_02ece63d_469a_493c_80f3_1629478a34c835_thinPointCloud")
Tcl2 proc Ponto_Rodoviario_Ferrov_02ece63d_469a_493c_80f3_1629478a34c835_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Rodoviario_Ferrov_RasterSetterUpper    INPUT FEATURE_TYPE Ponto_Rodoviario_Ferrov___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Rodoviario_Ferrov_02ece63d_469a_493c_80f3_1629478a34c835_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Ponto_Rodoviario_Ferrov_02ece63d_469a_493c_80f3_1629478a34c835_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Ponto_Rodoviario_Ferrov_02ece63d_469a_493c_80f3_1629478a34c835_VIS_FEAT_TYPE Ponto_Rodoviario_Ferrov$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Ponto_Rodoviario_Ferrov_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Ponto_Rodoviario_Ferrov_02ece63d_469a_493c_80f3_1629478a34c835_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,relacionado,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,modalUso,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Ponto_Rodoviario_Ferrov Output Nuker"   INPUT FEATURE_TYPE Ponto_Rodoviario_Ferrov

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Dep_Saneamento_polygon_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Dep_Saneamento_polygon_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Saneamento_polygon_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Dep_Saneamento_polygon_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Dep_Saneamento_polygon_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Dep_Saneamento_polygon_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Dep_Saneamento_polygon_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Dep_Saneamento_polygon_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Dep_Saneamento_polygon_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Dep_Saneamento_polygon_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Dep_Saneamento_polygon_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Saneamento_polygon_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Dep_Saneamento_polygon_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Dep_Saneamento_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c836_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Saneamento_polygon_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Dep_Saneamento_polygon_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Dep_Saneamento_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c836_thinPointCloud")
Tcl2 proc Dep_Saneamento_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c836_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Saneamento_polygon_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Dep_Saneamento_polygon_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Dep_Saneamento_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c836_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Dep_Saneamento_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c836_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Dep_Saneamento_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c836_VIS_FEAT_TYPE Dep_Saneamento_polygon_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Dep_Saneamento_polygon_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Dep_Saneamento_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c836_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Dep_Saneamento_polygon_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Dep_Saneamento_polygon_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Const_Lazer_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Const_Lazer_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Lazer_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Const_Lazer_point_FeatureDirector    INPUT  FEATURE_TYPE Edif_Const_Lazer_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Const_Lazer_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Const_Lazer_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Const_Lazer_point___FeatureDirector1    INPUT FEATURE_TYPE Edif_Const_Lazer_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Const_Lazer_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Const_Lazer_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Lazer_point_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Const_Lazer_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Const_Lazer_point_02ece63d_469a_493c_80f3_1629478a34c837_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Lazer_point___PointCloudThinner    INPUT FEATURE_TYPE Edif_Const_Lazer_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Const_Lazer_point_02ece63d_469a_493c_80f3_1629478a34c837_thinPointCloud")
Tcl2 proc Edif_Const_Lazer_point_02ece63d_469a_493c_80f3_1629478a34c837_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Lazer_point_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Const_Lazer_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Const_Lazer_point_02ece63d_469a_493c_80f3_1629478a34c837_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Const_Lazer_point_02ece63d_469a_493c_80f3_1629478a34c837_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Const_Lazer_point_02ece63d_469a_493c_80f3_1629478a34c837_VIS_FEAT_TYPE Edif_Const_Lazer_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Const_Lazer_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Const_Lazer_point_02ece63d_469a_493c_80f3_1629478a34c837_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,tipoEdifLazer,varchar<openparen>255<closeparen>,fkComplLazer,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Const_Lazer_point Output Nuker"   INPUT FEATURE_TYPE Edif_Const_Lazer_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Veg_Cultivada_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Veg_Cultivada_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Veg_Cultivada_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Veg_Cultivada_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Veg_Cultivada_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Veg_Cultivada_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Veg_Cultivada_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Veg_Cultivada_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Veg_Cultivada_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Veg_Cultivada_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Veg_Cultivada_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Veg_Cultivada_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Veg_Cultivada_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Veg_Cultivada_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c838_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Veg_Cultivada_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Veg_Cultivada_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Veg_Cultivada_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c838_thinPointCloud")
Tcl2 proc Veg_Cultivada_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c838_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Veg_Cultivada_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Veg_Cultivada_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Veg_Cultivada_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c838_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Veg_Cultivada_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c838_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Veg_Cultivada_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c838_VIS_FEAT_TYPE Veg_Cultivada_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Veg_Cultivada_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Veg_Cultivada_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c838_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Veg_Cultivada_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Veg_Cultivada_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Ponto_Cotado_Altimetrico} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Ponto_Cotado_Altimetrico_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Cotado_Altimetrico_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Cotado_Altimetrico_FeatureDirector    INPUT  FEATURE_TYPE Ponto_Cotado_Altimetrico    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Ponto_Cotado_Altimetrico___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Cotado_Altimetrico___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Cotado_Altimetrico___FeatureDirector1    INPUT FEATURE_TYPE Ponto_Cotado_Altimetrico___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Ponto_Cotado_Altimetrico___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Cotado_Altimetrico___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Cotado_Altimetrico_VectorSetterUpper    INPUT FEATURE_TYPE Ponto_Cotado_Altimetrico___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Ponto_Cotado_Altimetrico_02ece63d_469a_493c_80f3_1629478a34c839_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Cotado_Altimetrico___PointCloudThinner    INPUT FEATURE_TYPE Ponto_Cotado_Altimetrico___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Cotado_Altimetrico_02ece63d_469a_493c_80f3_1629478a34c839_thinPointCloud")
Tcl2 proc Ponto_Cotado_Altimetrico_02ece63d_469a_493c_80f3_1629478a34c839_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Cotado_Altimetrico_RasterSetterUpper    INPUT FEATURE_TYPE Ponto_Cotado_Altimetrico___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Cotado_Altimetrico_02ece63d_469a_493c_80f3_1629478a34c839_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Ponto_Cotado_Altimetrico_02ece63d_469a_493c_80f3_1629478a34c839_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Ponto_Cotado_Altimetrico_02ece63d_469a_493c_80f3_1629478a34c839_VIS_FEAT_TYPE Ponto_Cotado_Altimetrico$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Ponto_Cotado_Altimetrico_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Ponto_Cotado_Altimetrico_02ece63d_469a_493c_80f3_1629478a34c839_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,cota,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,cotaComprovada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,visivel,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Ponto_Cotado_Altimetrico Output Nuker"   INPUT FEATURE_TYPE Ponto_Cotado_Altimetrico

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Patio_polygon_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Patio_polygon_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Patio_polygon_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Patio_polygon_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Patio_polygon_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Patio_polygon_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Patio_polygon_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Patio_polygon_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Patio_polygon_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Patio_polygon_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Patio_polygon_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Patio_polygon_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Patio_polygon_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Patio_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c840_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Patio_polygon_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Patio_polygon_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Patio_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c840_thinPointCloud")
Tcl2 proc Patio_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c840_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Patio_polygon_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Patio_polygon_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Patio_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c840_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Patio_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c840_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Patio_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c840_VIS_FEAT_TYPE Patio_polygon_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Patio_polygon_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Patio_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c840_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Patio_polygon_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Patio_polygon_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {GDB_Items} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME GDB_Items_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_Items_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME GDB_Items_FeatureDirector    INPUT  FEATURE_TYPE GDB_Items    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE GDB_Items___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE GDB_Items___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME GDB_Items___FeatureDirector1    INPUT FEATURE_TYPE GDB_Items___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE GDB_Items___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE GDB_Items___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_Items_VectorSetterUpper    INPUT FEATURE_TYPE GDB_Items___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc GDB_Items_02ece63d_469a_493c_80f3_1629478a34c841_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_Items___PointCloudThinner    INPUT FEATURE_TYPE GDB_Items___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("GDB_Items_02ece63d_469a_493c_80f3_1629478a34c841_thinPointCloud")
Tcl2 proc GDB_Items_02ece63d_469a_493c_80f3_1629478a34c841_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_Items_RasterSetterUpper    INPUT FEATURE_TYPE GDB_Items___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("GDB_Items_02ece63d_469a_493c_80f3_1629478a34c841_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# GDB_Items_02ece63d_469a_493c_80f3_1629478a34c841_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO GDB_Items_02ece63d_469a_493c_80f3_1629478a34c841_VIS_FEAT_TYPE GDB_Items$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME GDB_Items_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(GDB_Items_02ece63d_469a_493c_80f3_1629478a34c841_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA ObjectID,varchar<openparen>255<closeparen>,UUID,varchar<openparen>255<closeparen>,Type,varchar<openparen>255<closeparen>,Name,varchar<openparen>255<closeparen>,PhysicalName,varchar<openparen>255<closeparen>,Path,varchar<openparen>255<closeparen>,DatasetSubtype1,varchar<openparen>255<closeparen>,DatasetSubtype2,varchar<openparen>255<closeparen>,DatasetInfo1,varchar<openparen>255<closeparen>,DatasetInfo2,varchar<openparen>255<closeparen>,URL,varchar<openparen>255<closeparen>,Definition,varchar<openparen>255<closeparen>,Documentation,varchar<openparen>255<closeparen>,ItemInfo,varchar<openparen>255<closeparen>,Properties,varchar<openparen>255<closeparen>,Defaults,varchar<openparen>255<closeparen>,Shape,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "GDB_Items Output Nuker"   INPUT FEATURE_TYPE GDB_Items

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Religiosa_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Religiosa_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Religiosa_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Religiosa_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Religiosa_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Religiosa_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Religiosa_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Religiosa_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Religiosa_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Religiosa_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Religiosa_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Religiosa_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Religiosa_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Religiosa_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c842_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Religiosa_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Religiosa_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Religiosa_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c842_thinPointCloud")
Tcl2 proc Edif_Religiosa_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c842_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Religiosa_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Religiosa_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Religiosa_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c842_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Religiosa_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c842_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Religiosa_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c842_VIS_FEAT_TYPE Edif_Religiosa_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Religiosa_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Religiosa_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c842_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Religiosa_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Religiosa_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Ext_Mineral_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Ext_Mineral_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ext_Mineral_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Ext_Mineral_point_FeatureDirector    INPUT  FEATURE_TYPE Edif_Ext_Mineral_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Ext_Mineral_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Ext_Mineral_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Ext_Mineral_point___FeatureDirector1    INPUT FEATURE_TYPE Edif_Ext_Mineral_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Ext_Mineral_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Ext_Mineral_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ext_Mineral_point_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Ext_Mineral_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Ext_Mineral_point_02ece63d_469a_493c_80f3_1629478a34c843_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ext_Mineral_point___PointCloudThinner    INPUT FEATURE_TYPE Edif_Ext_Mineral_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Ext_Mineral_point_02ece63d_469a_493c_80f3_1629478a34c843_thinPointCloud")
Tcl2 proc Edif_Ext_Mineral_point_02ece63d_469a_493c_80f3_1629478a34c843_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ext_Mineral_point_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Ext_Mineral_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Ext_Mineral_point_02ece63d_469a_493c_80f3_1629478a34c843_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Ext_Mineral_point_02ece63d_469a_493c_80f3_1629478a34c843_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Ext_Mineral_point_02ece63d_469a_493c_80f3_1629478a34c843_VIS_FEAT_TYPE Edif_Ext_Mineral_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Ext_Mineral_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Ext_Mineral_point_02ece63d_469a_493c_80f3_1629478a34c843_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,fkComplOrgExtMin,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,tipoDivisaoCnae,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Ext_Mineral_point Output Nuker"   INPUT FEATURE_TYPE Edif_Ext_Mineral_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Delimitacao_Fisica_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Delimitacao_Fisica_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Delimitacao_Fisica_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Delimitacao_Fisica_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Delimitacao_Fisica_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Delimitacao_Fisica_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Delimitacao_Fisica_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Delimitacao_Fisica_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Delimitacao_Fisica_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Delimitacao_Fisica_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Delimitacao_Fisica_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Delimitacao_Fisica_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Delimitacao_Fisica_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Delimitacao_Fisica_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c844_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Delimitacao_Fisica_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Delimitacao_Fisica_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Delimitacao_Fisica_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c844_thinPointCloud")
Tcl2 proc Delimitacao_Fisica_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c844_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Delimitacao_Fisica_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Delimitacao_Fisica_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Delimitacao_Fisica_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c844_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Delimitacao_Fisica_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c844_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Delimitacao_Fisica_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c844_VIS_FEAT_TYPE Delimitacao_Fisica_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Delimitacao_Fisica_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Delimitacao_Fisica_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c844_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Delimitacao_Fisica_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Delimitacao_Fisica_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {GDB_ItemTypes} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME GDB_ItemTypes_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_ItemTypes_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME GDB_ItemTypes_FeatureDirector    INPUT  FEATURE_TYPE GDB_ItemTypes    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE GDB_ItemTypes___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE GDB_ItemTypes___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME GDB_ItemTypes___FeatureDirector1    INPUT FEATURE_TYPE GDB_ItemTypes___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE GDB_ItemTypes___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE GDB_ItemTypes___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_ItemTypes_VectorSetterUpper    INPUT FEATURE_TYPE GDB_ItemTypes___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc GDB_ItemTypes_02ece63d_469a_493c_80f3_1629478a34c845_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_ItemTypes___PointCloudThinner    INPUT FEATURE_TYPE GDB_ItemTypes___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("GDB_ItemTypes_02ece63d_469a_493c_80f3_1629478a34c845_thinPointCloud")
Tcl2 proc GDB_ItemTypes_02ece63d_469a_493c_80f3_1629478a34c845_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_ItemTypes_RasterSetterUpper    INPUT FEATURE_TYPE GDB_ItemTypes___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("GDB_ItemTypes_02ece63d_469a_493c_80f3_1629478a34c845_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# GDB_ItemTypes_02ece63d_469a_493c_80f3_1629478a34c845_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO GDB_ItemTypes_02ece63d_469a_493c_80f3_1629478a34c845_VIS_FEAT_TYPE GDB_ItemTypes$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME GDB_ItemTypes_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(GDB_ItemTypes_02ece63d_469a_493c_80f3_1629478a34c845_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA ObjectID,varchar<openparen>255<closeparen>,UUID,varchar<openparen>255<closeparen>,ParentTypeID,varchar<openparen>255<closeparen>,Name,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "GDB_ItemTypes Output Nuker"   INPUT FEATURE_TYPE GDB_ItemTypes

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Limite_Massa_Dagua_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Limite_Massa_Dagua_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Limite_Massa_Dagua_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Limite_Massa_Dagua_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Limite_Massa_Dagua_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Limite_Massa_Dagua_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Limite_Massa_Dagua_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Limite_Massa_Dagua_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Limite_Massa_Dagua_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Limite_Massa_Dagua_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Limite_Massa_Dagua_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Limite_Massa_Dagua_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Limite_Massa_Dagua_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Limite_Massa_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c846_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Limite_Massa_Dagua_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Limite_Massa_Dagua_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Limite_Massa_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c846_thinPointCloud")
Tcl2 proc Limite_Massa_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c846_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Limite_Massa_Dagua_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Limite_Massa_Dagua_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Limite_Massa_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c846_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Limite_Massa_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c846_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Limite_Massa_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c846_VIS_FEAT_TYPE Limite_Massa_Dagua_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Limite_Massa_Dagua_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Limite_Massa_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c846_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Limite_Massa_Dagua_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Limite_Massa_Dagua_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Comunic_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Comunic_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comunic_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Comunic_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Comunic_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Comunic_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Comunic_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Comunic_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Comunic_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Comunic_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Comunic_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comunic_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Comunic_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Comunic_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c847_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comunic_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Comunic_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Comunic_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c847_thinPointCloud")
Tcl2 proc Edif_Comunic_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c847_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comunic_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Comunic_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Comunic_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c847_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Comunic_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c847_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Comunic_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c847_VIS_FEAT_TYPE Edif_Comunic_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Comunic_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Comunic_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c847_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Comunic_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Comunic_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {GDB_ItemRelationshipTypes} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME GDB_ItemRelationshipTypes_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_ItemRelationshipTypes_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME GDB_ItemRelationshipTypes_FeatureDirector    INPUT  FEATURE_TYPE GDB_ItemRelationshipTypes    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE GDB_ItemRelationshipTypes___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE GDB_ItemRelationshipTypes___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME GDB_ItemRelationshipTypes___FeatureDirector1    INPUT FEATURE_TYPE GDB_ItemRelationshipTypes___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE GDB_ItemRelationshipTypes___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE GDB_ItemRelationshipTypes___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_ItemRelationshipTypes_VectorSetterUpper    INPUT FEATURE_TYPE GDB_ItemRelationshipTypes___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc GDB_ItemRelationshipTypes_02ece63d_469a_493c_80f3_1629478a34c848_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_ItemRelationshipTypes___PointCloudThinner    INPUT FEATURE_TYPE GDB_ItemRelationshipTypes___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("GDB_ItemRelationshipTypes_02ece63d_469a_493c_80f3_1629478a34c848_thinPointCloud")
Tcl2 proc GDB_ItemRelationshipTypes_02ece63d_469a_493c_80f3_1629478a34c848_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_ItemRelationshipTypes_RasterSetterUpper    INPUT FEATURE_TYPE GDB_ItemRelationshipTypes___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("GDB_ItemRelationshipTypes_02ece63d_469a_493c_80f3_1629478a34c848_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# GDB_ItemRelationshipTypes_02ece63d_469a_493c_80f3_1629478a34c848_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO GDB_ItemRelationshipTypes_02ece63d_469a_493c_80f3_1629478a34c848_VIS_FEAT_TYPE GDB_ItemRelationshipTypes$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME GDB_ItemRelationshipTypes_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(GDB_ItemRelationshipTypes_02ece63d_469a_493c_80f3_1629478a34c848_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA ObjectID,varchar<openparen>255<closeparen>,UUID,varchar<openparen>255<closeparen>,OrigItemTypeID,varchar<openparen>255<closeparen>,DestItemTypeID,varchar<openparen>255<closeparen>,Name,varchar<openparen>255<closeparen>,ForwardLabel,varchar<openparen>255<closeparen>,BackwardLabel,varchar<openparen>255<closeparen>,IsContainment,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "GDB_ItemRelationshipTypes Output Nuker"   INPUT FEATURE_TYPE GDB_ItemRelationshipTypes

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Pub_Civil_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Pub_Civil_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Civil_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Pub_Civil_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Pub_Civil_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Pub_Civil_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Pub_Civil_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Pub_Civil_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Pub_Civil_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Pub_Civil_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Pub_Civil_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Civil_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Pub_Civil_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Pub_Civil_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c849_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Civil_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Pub_Civil_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Pub_Civil_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c849_thinPointCloud")
Tcl2 proc Edif_Pub_Civil_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c849_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Civil_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Pub_Civil_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Pub_Civil_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c849_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Pub_Civil_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c849_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Pub_Civil_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c849_VIS_FEAT_TYPE Edif_Pub_Civil_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Pub_Civil_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Pub_Civil_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c849_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Pub_Civil_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Pub_Civil_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Saneamento_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Saneamento_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saneamento_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Saneamento_point_FeatureDirector    INPUT  FEATURE_TYPE Edif_Saneamento_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Saneamento_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Saneamento_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Saneamento_point___FeatureDirector1    INPUT FEATURE_TYPE Edif_Saneamento_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Saneamento_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Saneamento_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saneamento_point_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Saneamento_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Saneamento_point_02ece63d_469a_493c_80f3_1629478a34c850_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saneamento_point___PointCloudThinner    INPUT FEATURE_TYPE Edif_Saneamento_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Saneamento_point_02ece63d_469a_493c_80f3_1629478a34c850_thinPointCloud")
Tcl2 proc Edif_Saneamento_point_02ece63d_469a_493c_80f3_1629478a34c850_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saneamento_point_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Saneamento_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Saneamento_point_02ece63d_469a_493c_80f3_1629478a34c850_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Saneamento_point_02ece63d_469a_493c_80f3_1629478a34c850_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Saneamento_point_02ece63d_469a_493c_80f3_1629478a34c850_VIS_FEAT_TYPE Edif_Saneamento_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Saneamento_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Saneamento_point_02ece63d_469a_493c_80f3_1629478a34c850_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,fkComplSaneam,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,tipoEdifSaneam,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Saneamento_point Output Nuker"   INPUT FEATURE_TYPE Edif_Saneamento_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Cidade} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Cidade_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Cidade_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Cidade_FeatureDirector    INPUT  FEATURE_TYPE Cidade    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Cidade___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Cidade___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Cidade___FeatureDirector1    INPUT FEATURE_TYPE Cidade___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Cidade___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Cidade___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Cidade_VectorSetterUpper    INPUT FEATURE_TYPE Cidade___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Cidade_02ece63d_469a_493c_80f3_1629478a34c851_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Cidade___PointCloudThinner    INPUT FEATURE_TYPE Cidade___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Cidade_02ece63d_469a_493c_80f3_1629478a34c851_thinPointCloud")
Tcl2 proc Cidade_02ece63d_469a_493c_80f3_1629478a34c851_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Cidade_RasterSetterUpper    INPUT FEATURE_TYPE Cidade___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Cidade_02ece63d_469a_493c_80f3_1629478a34c851_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Cidade_02ece63d_469a_493c_80f3_1629478a34c851_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Cidade_02ece63d_469a_493c_80f3_1629478a34c851_VIS_FEAT_TYPE Cidade$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Cidade_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Cidade_02ece63d_469a_493c_80f3_1629478a34c851_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,identificadorPosicGeo,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,simbolizar,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,longitude,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,latitude,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,longitude_txt,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,tamanhoTxt,varchar<openparen>255<closeparen>,latitude_txt,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,tipoCidade,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Cidade Output Nuker"   INPUT FEATURE_TYPE Cidade

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Banco_Areia_polygon} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Banco_Areia_polygon_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Banco_Areia_polygon_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Banco_Areia_polygon_FeatureDirector    INPUT  FEATURE_TYPE Banco_Areia_polygon    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Banco_Areia_polygon___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Banco_Areia_polygon___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Banco_Areia_polygon___FeatureDirector1    INPUT FEATURE_TYPE Banco_Areia_polygon___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Banco_Areia_polygon___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Banco_Areia_polygon___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Banco_Areia_polygon_VectorSetterUpper    INPUT FEATURE_TYPE Banco_Areia_polygon___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Banco_Areia_polygon_02ece63d_469a_493c_80f3_1629478a34c852_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Banco_Areia_polygon___PointCloudThinner    INPUT FEATURE_TYPE Banco_Areia_polygon___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Banco_Areia_polygon_02ece63d_469a_493c_80f3_1629478a34c852_thinPointCloud")
Tcl2 proc Banco_Areia_polygon_02ece63d_469a_493c_80f3_1629478a34c852_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Banco_Areia_polygon_RasterSetterUpper    INPUT FEATURE_TYPE Banco_Areia_polygon___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Banco_Areia_polygon_02ece63d_469a_493c_80f3_1629478a34c852_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Banco_Areia_polygon_02ece63d_469a_493c_80f3_1629478a34c852_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Banco_Areia_polygon_02ece63d_469a_493c_80f3_1629478a34c852_VIS_FEAT_TYPE Banco_Areia_polygon$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Banco_Areia_polygon_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Banco_Areia_polygon_02ece63d_469a_493c_80f3_1629478a34c852_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,materialPredominante,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoEmAgua,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,tipoBanco,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Banco_Areia_polygon Output Nuker"   INPUT FEATURE_TYPE Banco_Areia_polygon

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Veg_Cultivada} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Veg_Cultivada_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Veg_Cultivada_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Veg_Cultivada_FeatureDirector    INPUT  FEATURE_TYPE Veg_Cultivada    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Veg_Cultivada___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Veg_Cultivada___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Veg_Cultivada___FeatureDirector1    INPUT FEATURE_TYPE Veg_Cultivada___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Veg_Cultivada___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Veg_Cultivada___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Veg_Cultivada_VectorSetterUpper    INPUT FEATURE_TYPE Veg_Cultivada___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Veg_Cultivada_02ece63d_469a_493c_80f3_1629478a34c853_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Veg_Cultivada___PointCloudThinner    INPUT FEATURE_TYPE Veg_Cultivada___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Veg_Cultivada_02ece63d_469a_493c_80f3_1629478a34c853_thinPointCloud")
Tcl2 proc Veg_Cultivada_02ece63d_469a_493c_80f3_1629478a34c853_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Veg_Cultivada_RasterSetterUpper    INPUT FEATURE_TYPE Veg_Cultivada___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Veg_Cultivada_02ece63d_469a_493c_80f3_1629478a34c853_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Veg_Cultivada_02ece63d_469a_493c_80f3_1629478a34c853_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Veg_Cultivada_02ece63d_469a_493c_80f3_1629478a34c853_VIS_FEAT_TYPE Veg_Cultivada$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Veg_Cultivada_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Veg_Cultivada_02ece63d_469a_493c_80f3_1629478a34c853_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,tipoLavoura,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,denso,varchar<openparen>255<closeparen>,espessuraDAP,varchar<openparen>255<closeparen>,classificacaoPorte,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,cultivoPredominante,varchar<openparen>255<closeparen>,alturaMediaIndividuos,varchar<openparen>255<closeparen>,terreno,varchar<openparen>255<closeparen>,espacamentoIndividuos,varchar<openparen>255<closeparen>,finalidade,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Veg_Cultivada Output Nuker"   INPUT FEATURE_TYPE Veg_Cultivada

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Religiosa_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Religiosa_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Religiosa_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Religiosa_point_FeatureDirector    INPUT  FEATURE_TYPE Edif_Religiosa_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Religiosa_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Religiosa_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Religiosa_point___FeatureDirector1    INPUT FEATURE_TYPE Edif_Religiosa_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Religiosa_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Religiosa_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Religiosa_point_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Religiosa_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Religiosa_point_02ece63d_469a_493c_80f3_1629478a34c854_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Religiosa_point___PointCloudThinner    INPUT FEATURE_TYPE Edif_Religiosa_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Religiosa_point_02ece63d_469a_493c_80f3_1629478a34c854_thinPointCloud")
Tcl2 proc Edif_Religiosa_point_02ece63d_469a_493c_80f3_1629478a34c854_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Religiosa_point_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Religiosa_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Religiosa_point_02ece63d_469a_493c_80f3_1629478a34c854_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Religiosa_point_02ece63d_469a_493c_80f3_1629478a34c854_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Religiosa_point_02ece63d_469a_493c_80f3_1629478a34c854_VIS_FEAT_TYPE Edif_Religiosa_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Religiosa_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Religiosa_point_02ece63d_469a_493c_80f3_1629478a34c854_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,religiao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,fkComplOrgRel,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,tipoEdifRelig,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,ensino,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Religiosa_point Output Nuker"   INPUT FEATURE_TYPE Edif_Religiosa_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Limite_Massa_Dagua} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Limite_Massa_Dagua_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Limite_Massa_Dagua_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Limite_Massa_Dagua_FeatureDirector    INPUT  FEATURE_TYPE Limite_Massa_Dagua    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Limite_Massa_Dagua___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Limite_Massa_Dagua___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Limite_Massa_Dagua___FeatureDirector1    INPUT FEATURE_TYPE Limite_Massa_Dagua___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Limite_Massa_Dagua___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Limite_Massa_Dagua___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Limite_Massa_Dagua_VectorSetterUpper    INPUT FEATURE_TYPE Limite_Massa_Dagua___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Limite_Massa_Dagua_02ece63d_469a_493c_80f3_1629478a34c855_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Limite_Massa_Dagua___PointCloudThinner    INPUT FEATURE_TYPE Limite_Massa_Dagua___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Limite_Massa_Dagua_02ece63d_469a_493c_80f3_1629478a34c855_thinPointCloud")
Tcl2 proc Limite_Massa_Dagua_02ece63d_469a_493c_80f3_1629478a34c855_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Limite_Massa_Dagua_RasterSetterUpper    INPUT FEATURE_TYPE Limite_Massa_Dagua___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Limite_Massa_Dagua_02ece63d_469a_493c_80f3_1629478a34c855_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Limite_Massa_Dagua_02ece63d_469a_493c_80f3_1629478a34c855_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Limite_Massa_Dagua_02ece63d_469a_493c_80f3_1629478a34c855_VIS_FEAT_TYPE Limite_Massa_Dagua$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Limite_Massa_Dagua_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Limite_Massa_Dagua_02ece63d_469a_493c_80f3_1629478a34c855_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,materialPredominante,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,tipoLimMassa,varchar<openparen>255<closeparen>,alturaMediaMargem,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Limite_Massa_Dagua Output Nuker"   INPUT FEATURE_TYPE Limite_Massa_Dagua

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {GDB_DatabaseLocks} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME GDB_DatabaseLocks_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_DatabaseLocks_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME GDB_DatabaseLocks_FeatureDirector    INPUT  FEATURE_TYPE GDB_DatabaseLocks    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE GDB_DatabaseLocks___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE GDB_DatabaseLocks___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME GDB_DatabaseLocks___FeatureDirector1    INPUT FEATURE_TYPE GDB_DatabaseLocks___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE GDB_DatabaseLocks___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE GDB_DatabaseLocks___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_DatabaseLocks_VectorSetterUpper    INPUT FEATURE_TYPE GDB_DatabaseLocks___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc GDB_DatabaseLocks_02ece63d_469a_493c_80f3_1629478a34c856_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_DatabaseLocks___PointCloudThinner    INPUT FEATURE_TYPE GDB_DatabaseLocks___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("GDB_DatabaseLocks_02ece63d_469a_493c_80f3_1629478a34c856_thinPointCloud")
Tcl2 proc GDB_DatabaseLocks_02ece63d_469a_493c_80f3_1629478a34c856_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_DatabaseLocks_RasterSetterUpper    INPUT FEATURE_TYPE GDB_DatabaseLocks___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("GDB_DatabaseLocks_02ece63d_469a_493c_80f3_1629478a34c856_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# GDB_DatabaseLocks_02ece63d_469a_493c_80f3_1629478a34c856_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO GDB_DatabaseLocks_02ece63d_469a_493c_80f3_1629478a34c856_VIS_FEAT_TYPE GDB_DatabaseLocks$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME GDB_DatabaseLocks_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(GDB_DatabaseLocks_02ece63d_469a_493c_80f3_1629478a34c856_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA LockID,varchar<openparen>255<closeparen>,LockType,varchar<openparen>255<closeparen>,UserName,varchar<openparen>255<closeparen>,MachineName,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "GDB_DatabaseLocks Output Nuker"   INPUT FEATURE_TYPE GDB_DatabaseLocks

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Ensino_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Ensino_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ensino_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Ensino_point_FeatureDirector    INPUT  FEATURE_TYPE Edif_Ensino_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Ensino_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Ensino_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Ensino_point___FeatureDirector1    INPUT FEATURE_TYPE Edif_Ensino_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Ensino_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Ensino_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ensino_point_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Ensino_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Ensino_point_02ece63d_469a_493c_80f3_1629478a34c857_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ensino_point___PointCloudThinner    INPUT FEATURE_TYPE Edif_Ensino_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Ensino_point_02ece63d_469a_493c_80f3_1629478a34c857_thinPointCloud")
Tcl2 proc Edif_Ensino_point_02ece63d_469a_493c_80f3_1629478a34c857_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ensino_point_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Ensino_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Ensino_point_02ece63d_469a_493c_80f3_1629478a34c857_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Ensino_point_02ece63d_469a_493c_80f3_1629478a34c857_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Ensino_point_02ece63d_469a_493c_80f3_1629478a34c857_VIS_FEAT_TYPE Edif_Ensino_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Ensino_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Ensino_point_02ece63d_469a_493c_80f3_1629478a34c857_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,tipoClasseCnae,varchar<openparen>255<closeparen>,fkComplOrgEnsino,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Ensino_point Output Nuker"   INPUT FEATURE_TYPE Edif_Ensino_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Comporta_line} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Comporta_line_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Comporta_line_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Comporta_line_FeatureDirector    INPUT  FEATURE_TYPE Comporta_line    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Comporta_line___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Comporta_line___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Comporta_line___FeatureDirector1    INPUT FEATURE_TYPE Comporta_line___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Comporta_line___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Comporta_line___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Comporta_line_VectorSetterUpper    INPUT FEATURE_TYPE Comporta_line___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Comporta_line_02ece63d_469a_493c_80f3_1629478a34c858_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Comporta_line___PointCloudThinner    INPUT FEATURE_TYPE Comporta_line___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Comporta_line_02ece63d_469a_493c_80f3_1629478a34c858_thinPointCloud")
Tcl2 proc Comporta_line_02ece63d_469a_493c_80f3_1629478a34c858_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Comporta_line_RasterSetterUpper    INPUT FEATURE_TYPE Comporta_line___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Comporta_line_02ece63d_469a_493c_80f3_1629478a34c858_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Comporta_line_02ece63d_469a_493c_80f3_1629478a34c858_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Comporta_line_02ece63d_469a_493c_80f3_1629478a34c858_VIS_FEAT_TYPE Comporta_line$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Comporta_line_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Comporta_line_02ece63d_469a_493c_80f3_1629478a34c858_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Comporta_line Output Nuker"   INPUT FEATURE_TYPE Comporta_line

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Comerc_Serv_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Comerc_Serv_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comerc_Serv_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Comerc_Serv_point_FeatureDirector    INPUT  FEATURE_TYPE Edif_Comerc_Serv_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Comerc_Serv_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Comerc_Serv_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Comerc_Serv_point___FeatureDirector1    INPUT FEATURE_TYPE Edif_Comerc_Serv_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Comerc_Serv_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Comerc_Serv_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comerc_Serv_point_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Comerc_Serv_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Comerc_Serv_point_02ece63d_469a_493c_80f3_1629478a34c859_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comerc_Serv_point___PointCloudThinner    INPUT FEATURE_TYPE Edif_Comerc_Serv_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Comerc_Serv_point_02ece63d_469a_493c_80f3_1629478a34c859_thinPointCloud")
Tcl2 proc Edif_Comerc_Serv_point_02ece63d_469a_493c_80f3_1629478a34c859_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comerc_Serv_point_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Comerc_Serv_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Comerc_Serv_point_02ece63d_469a_493c_80f3_1629478a34c859_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Comerc_Serv_point_02ece63d_469a_493c_80f3_1629478a34c859_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Comerc_Serv_point_02ece63d_469a_493c_80f3_1629478a34c859_VIS_FEAT_TYPE Edif_Comerc_Serv_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Comerc_Serv_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Comerc_Serv_point_02ece63d_469a_493c_80f3_1629478a34c859_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,fkComplOrgComSv,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,finalidade,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,tipoEdifComercServ,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Comerc_Serv_point Output Nuker"   INPUT FEATURE_TYPE Edif_Comerc_Serv_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Agrop_Ext_Veg_Pesca_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Agrop_Ext_Veg_Pesca_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Agrop_Ext_Veg_Pesca_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Agrop_Ext_Veg_Pesca_point_FeatureDirector    INPUT  FEATURE_TYPE Edif_Agrop_Ext_Veg_Pesca_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Agrop_Ext_Veg_Pesca_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Agrop_Ext_Veg_Pesca_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Agrop_Ext_Veg_Pesca_point___FeatureDirector1    INPUT FEATURE_TYPE Edif_Agrop_Ext_Veg_Pesca_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Agrop_Ext_Veg_Pesca_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Agrop_Ext_Veg_Pesca_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Agrop_Ext_Veg_Pesca_point_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Agrop_Ext_Veg_Pesca_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Agrop_Ext_Veg_Pesca_point_02ece63d_469a_493c_80f3_1629478a34c860_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Agrop_Ext_Veg_Pesca_point___PointCloudThinner    INPUT FEATURE_TYPE Edif_Agrop_Ext_Veg_Pesca_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Agrop_Ext_Veg_Pesca_point_02ece63d_469a_493c_80f3_1629478a34c860_thinPointCloud")
Tcl2 proc Edif_Agrop_Ext_Veg_Pesca_point_02ece63d_469a_493c_80f3_1629478a34c860_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Agrop_Ext_Veg_Pesca_point_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Agrop_Ext_Veg_Pesca_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Agrop_Ext_Veg_Pesca_point_02ece63d_469a_493c_80f3_1629478a34c860_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Agrop_Ext_Veg_Pesca_point_02ece63d_469a_493c_80f3_1629478a34c860_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Agrop_Ext_Veg_Pesca_point_02ece63d_469a_493c_80f3_1629478a34c860_VIS_FEAT_TYPE Edif_Agrop_Ext_Veg_Pesca_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Agrop_Ext_Veg_Pesca_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Agrop_Ext_Veg_Pesca_point_02ece63d_469a_493c_80f3_1629478a34c860_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,fkComplOrgAgrop,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,tipoEdifAgropec,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,tamanhoTxt,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Agrop_Ext_Veg_Pesca_point Output Nuker"   INPUT FEATURE_TYPE Edif_Agrop_Ext_Veg_Pesca_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Fonte_Dagua_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Fonte_Dagua_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Fonte_Dagua_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Fonte_Dagua_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Fonte_Dagua_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Fonte_Dagua_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Fonte_Dagua_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Fonte_Dagua_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Fonte_Dagua_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Fonte_Dagua_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Fonte_Dagua_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Fonte_Dagua_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Fonte_Dagua_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Fonte_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c861_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Fonte_Dagua_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Fonte_Dagua_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Fonte_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c861_thinPointCloud")
Tcl2 proc Fonte_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c861_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Fonte_Dagua_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Fonte_Dagua_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Fonte_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c861_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Fonte_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c861_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Fonte_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c861_VIS_FEAT_TYPE Fonte_Dagua_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Fonte_Dagua_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Fonte_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c861_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Fonte_Dagua_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Fonte_Dagua_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Nome_Local_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Nome_Local_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Nome_Local_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Nome_Local_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Nome_Local_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Nome_Local_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Nome_Local_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Nome_Local_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Nome_Local_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Nome_Local_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Nome_Local_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Nome_Local_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Nome_Local_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Nome_Local_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c862_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Nome_Local_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Nome_Local_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Nome_Local_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c862_thinPointCloud")
Tcl2 proc Nome_Local_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c862_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Nome_Local_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Nome_Local_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Nome_Local_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c862_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Nome_Local_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c862_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Nome_Local_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c862_VIS_FEAT_TYPE Nome_Local_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Nome_Local_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Nome_Local_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c862_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Nome_Local_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Nome_Local_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Grupo_Transform_Energ_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Grupo_Transform_Energ_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Grupo_Transform_Energ_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Grupo_Transform_Energ_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Grupo_Transform_Energ_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Grupo_Transform_Energ_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Grupo_Transform_Energ_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Grupo_Transform_Energ_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Grupo_Transform_Energ_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Grupo_Transform_Energ_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Grupo_Transform_Energ_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Grupo_Transform_Energ_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Grupo_Transform_Energ_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Grupo_Transform_Energ_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c863_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Grupo_Transform_Energ_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Grupo_Transform_Energ_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Grupo_Transform_Energ_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c863_thinPointCloud")
Tcl2 proc Grupo_Transform_Energ_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c863_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Grupo_Transform_Energ_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Grupo_Transform_Energ_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Grupo_Transform_Energ_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c863_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Grupo_Transform_Energ_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c863_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Grupo_Transform_Energ_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c863_VIS_FEAT_TYPE Grupo_Transform_Energ_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Grupo_Transform_Energ_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Grupo_Transform_Energ_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c863_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Grupo_Transform_Energ_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Grupo_Transform_Energ_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Atracadouro_polygon} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Atracadouro_polygon_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Atracadouro_polygon_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Atracadouro_polygon_FeatureDirector    INPUT  FEATURE_TYPE Atracadouro_polygon    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Atracadouro_polygon___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Atracadouro_polygon___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Atracadouro_polygon___FeatureDirector1    INPUT FEATURE_TYPE Atracadouro_polygon___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Atracadouro_polygon___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Atracadouro_polygon___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Atracadouro_polygon_VectorSetterUpper    INPUT FEATURE_TYPE Atracadouro_polygon___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Atracadouro_polygon_02ece63d_469a_493c_80f3_1629478a34c864_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Atracadouro_polygon___PointCloudThinner    INPUT FEATURE_TYPE Atracadouro_polygon___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Atracadouro_polygon_02ece63d_469a_493c_80f3_1629478a34c864_thinPointCloud")
Tcl2 proc Atracadouro_polygon_02ece63d_469a_493c_80f3_1629478a34c864_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Atracadouro_polygon_RasterSetterUpper    INPUT FEATURE_TYPE Atracadouro_polygon___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Atracadouro_polygon_02ece63d_469a_493c_80f3_1629478a34c864_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Atracadouro_polygon_02ece63d_469a_493c_80f3_1629478a34c864_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Atracadouro_polygon_02ece63d_469a_493c_80f3_1629478a34c864_VIS_FEAT_TYPE Atracadouro_polygon$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Atracadouro_polygon_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Atracadouro_polygon_02ece63d_469a_493c_80f3_1629478a34c864_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,fkComplPortuario,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,administracao,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,tipoAtracad,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Atracadouro_polygon Output Nuker"   INPUT FEATURE_TYPE Atracadouro_polygon

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Confluencia_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Confluencia_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Confluencia_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Confluencia_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Confluencia_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Confluencia_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Confluencia_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Confluencia_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Confluencia_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Confluencia_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Confluencia_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Confluencia_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Confluencia_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Confluencia_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c865_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Confluencia_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Confluencia_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Confluencia_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c865_thinPointCloud")
Tcl2 proc Confluencia_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c865_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Confluencia_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Confluencia_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Confluencia_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c865_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Confluencia_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c865_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Confluencia_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c865_VIS_FEAT_TYPE Confluencia_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Confluencia_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Confluencia_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c865_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Confluencia_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Confluencia_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Campo_Quadra_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Campo_Quadra_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_Quadra_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Campo_Quadra_point_FeatureDirector    INPUT  FEATURE_TYPE Campo_Quadra_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Campo_Quadra_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Campo_Quadra_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Campo_Quadra_point___FeatureDirector1    INPUT FEATURE_TYPE Campo_Quadra_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Campo_Quadra_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Campo_Quadra_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_Quadra_point_VectorSetterUpper    INPUT FEATURE_TYPE Campo_Quadra_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Campo_Quadra_point_02ece63d_469a_493c_80f3_1629478a34c866_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_Quadra_point___PointCloudThinner    INPUT FEATURE_TYPE Campo_Quadra_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Campo_Quadra_point_02ece63d_469a_493c_80f3_1629478a34c866_thinPointCloud")
Tcl2 proc Campo_Quadra_point_02ece63d_469a_493c_80f3_1629478a34c866_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_Quadra_point_RasterSetterUpper    INPUT FEATURE_TYPE Campo_Quadra_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Campo_Quadra_point_02ece63d_469a_493c_80f3_1629478a34c866_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Campo_Quadra_point_02ece63d_469a_493c_80f3_1629478a34c866_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Campo_Quadra_point_02ece63d_469a_493c_80f3_1629478a34c866_VIS_FEAT_TYPE Campo_Quadra_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Campo_Quadra_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Campo_Quadra_point_02ece63d_469a_493c_80f3_1629478a34c866_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,fkComplLazer,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,tipoCampoQuadra,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Campo_Quadra_point Output Nuker"   INPUT FEATURE_TYPE Campo_Quadra_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {GDB_ReplicaLog} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME GDB_ReplicaLog_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_ReplicaLog_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME GDB_ReplicaLog_FeatureDirector    INPUT  FEATURE_TYPE GDB_ReplicaLog    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE GDB_ReplicaLog___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE GDB_ReplicaLog___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME GDB_ReplicaLog___FeatureDirector1    INPUT FEATURE_TYPE GDB_ReplicaLog___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE GDB_ReplicaLog___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE GDB_ReplicaLog___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_ReplicaLog_VectorSetterUpper    INPUT FEATURE_TYPE GDB_ReplicaLog___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc GDB_ReplicaLog_02ece63d_469a_493c_80f3_1629478a34c867_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_ReplicaLog___PointCloudThinner    INPUT FEATURE_TYPE GDB_ReplicaLog___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("GDB_ReplicaLog_02ece63d_469a_493c_80f3_1629478a34c867_thinPointCloud")
Tcl2 proc GDB_ReplicaLog_02ece63d_469a_493c_80f3_1629478a34c867_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_ReplicaLog_RasterSetterUpper    INPUT FEATURE_TYPE GDB_ReplicaLog___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("GDB_ReplicaLog_02ece63d_469a_493c_80f3_1629478a34c867_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# GDB_ReplicaLog_02ece63d_469a_493c_80f3_1629478a34c867_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO GDB_ReplicaLog_02ece63d_469a_493c_80f3_1629478a34c867_VIS_FEAT_TYPE GDB_ReplicaLog$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME GDB_ReplicaLog_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(GDB_ReplicaLog_02ece63d_469a_493c_80f3_1629478a34c867_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA ID,varchar<openparen>255<closeparen>,ReplicaID,varchar<openparen>255<closeparen>,Event,varchar<openparen>255<closeparen>,ErrorCode,varchar<openparen>255<closeparen>,LogDate,varchar<openparen>255<closeparen>,SourceBeginGen,varchar<openparen>255<closeparen>,SourceEndGen,varchar<openparen>255<closeparen>,TargetGen,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "GDB_ReplicaLog Output Nuker"   INPUT FEATURE_TYPE GDB_ReplicaLog

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Elemento_Fisiog_Natural_line} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Elemento_Fisiog_Natural_line_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Elemento_Fisiog_Natural_line_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Elemento_Fisiog_Natural_line_FeatureDirector    INPUT  FEATURE_TYPE Elemento_Fisiog_Natural_line    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Elemento_Fisiog_Natural_line___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Elemento_Fisiog_Natural_line___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Elemento_Fisiog_Natural_line___FeatureDirector1    INPUT FEATURE_TYPE Elemento_Fisiog_Natural_line___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Elemento_Fisiog_Natural_line___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Elemento_Fisiog_Natural_line___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Elemento_Fisiog_Natural_line_VectorSetterUpper    INPUT FEATURE_TYPE Elemento_Fisiog_Natural_line___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Elemento_Fisiog_Natural_line_02ece63d_469a_493c_80f3_1629478a34c868_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Elemento_Fisiog_Natural_line___PointCloudThinner    INPUT FEATURE_TYPE Elemento_Fisiog_Natural_line___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Elemento_Fisiog_Natural_line_02ece63d_469a_493c_80f3_1629478a34c868_thinPointCloud")
Tcl2 proc Elemento_Fisiog_Natural_line_02ece63d_469a_493c_80f3_1629478a34c868_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Elemento_Fisiog_Natural_line_RasterSetterUpper    INPUT FEATURE_TYPE Elemento_Fisiog_Natural_line___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Elemento_Fisiog_Natural_line_02ece63d_469a_493c_80f3_1629478a34c868_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Elemento_Fisiog_Natural_line_02ece63d_469a_493c_80f3_1629478a34c868_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Elemento_Fisiog_Natural_line_02ece63d_469a_493c_80f3_1629478a34c868_VIS_FEAT_TYPE Elemento_Fisiog_Natural_line$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Elemento_Fisiog_Natural_line_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Elemento_Fisiog_Natural_line_02ece63d_469a_493c_80f3_1629478a34c868_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,tamanhoTxt,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,tipoElemNat,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Elemento_Fisiog_Natural_line Output Nuker"   INPUT FEATURE_TYPE Elemento_Fisiog_Natural_line

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Galeria_Bueiro_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Galeria_Bueiro_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Galeria_Bueiro_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Galeria_Bueiro_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Galeria_Bueiro_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Galeria_Bueiro_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Galeria_Bueiro_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Galeria_Bueiro_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Galeria_Bueiro_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Galeria_Bueiro_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Galeria_Bueiro_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Galeria_Bueiro_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Galeria_Bueiro_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Galeria_Bueiro_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c869_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Galeria_Bueiro_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Galeria_Bueiro_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Galeria_Bueiro_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c869_thinPointCloud")
Tcl2 proc Galeria_Bueiro_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c869_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Galeria_Bueiro_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Galeria_Bueiro_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Galeria_Bueiro_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c869_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Galeria_Bueiro_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c869_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Galeria_Bueiro_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c869_VIS_FEAT_TYPE Galeria_Bueiro_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Galeria_Bueiro_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Galeria_Bueiro_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c869_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Galeria_Bueiro_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Galeria_Bueiro_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Constr_Est_Med_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Constr_Est_Med_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Constr_Est_Med_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Constr_Est_Med_point_FeatureDirector    INPUT  FEATURE_TYPE Edif_Constr_Est_Med_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Constr_Est_Med_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Constr_Est_Med_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Constr_Est_Med_point___FeatureDirector1    INPUT FEATURE_TYPE Edif_Constr_Est_Med_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Constr_Est_Med_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Constr_Est_Med_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Constr_Est_Med_point_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Constr_Est_Med_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Constr_Est_Med_point_02ece63d_469a_493c_80f3_1629478a34c870_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Constr_Est_Med_point___PointCloudThinner    INPUT FEATURE_TYPE Edif_Constr_Est_Med_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Constr_Est_Med_point_02ece63d_469a_493c_80f3_1629478a34c870_thinPointCloud")
Tcl2 proc Edif_Constr_Est_Med_point_02ece63d_469a_493c_80f3_1629478a34c870_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Constr_Est_Med_point_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Constr_Est_Med_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Constr_Est_Med_point_02ece63d_469a_493c_80f3_1629478a34c870_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Constr_Est_Med_point_02ece63d_469a_493c_80f3_1629478a34c870_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Constr_Est_Med_point_02ece63d_469a_493c_80f3_1629478a34c870_VIS_FEAT_TYPE Edif_Constr_Est_Med_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Constr_Est_Med_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Constr_Est_Med_point_02ece63d_469a_493c_80f3_1629478a34c870_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,fkComplEstMedFen,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Constr_Est_Med_point Output Nuker"   INPUT FEATURE_TYPE Edif_Constr_Est_Med_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Patio_polygon} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Patio_polygon_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Patio_polygon_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Patio_polygon_FeatureDirector    INPUT  FEATURE_TYPE Patio_polygon    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Patio_polygon___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Patio_polygon___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Patio_polygon___FeatureDirector1    INPUT FEATURE_TYPE Patio_polygon___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Patio_polygon___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Patio_polygon___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Patio_polygon_VectorSetterUpper    INPUT FEATURE_TYPE Patio_polygon___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Patio_polygon_02ece63d_469a_493c_80f3_1629478a34c871_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Patio_polygon___PointCloudThinner    INPUT FEATURE_TYPE Patio_polygon___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Patio_polygon_02ece63d_469a_493c_80f3_1629478a34c871_thinPointCloud")
Tcl2 proc Patio_polygon_02ece63d_469a_493c_80f3_1629478a34c871_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Patio_polygon_RasterSetterUpper    INPUT FEATURE_TYPE Patio_polygon___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Patio_polygon_02ece63d_469a_493c_80f3_1629478a34c871_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Patio_polygon_02ece63d_469a_493c_80f3_1629478a34c871_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Patio_polygon_02ece63d_469a_493c_80f3_1629478a34c871_VIS_FEAT_TYPE Patio_polygon$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Patio_polygon_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Patio_polygon_02ece63d_469a_493c_80f3_1629478a34c871_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,fkComplAeroport,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,fkComplPortuario,varchar<openparen>255<closeparen>,fkComplOrgRel,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,fkComplIndustria,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,fkComplOrgEnsino,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,administracao,varchar<openparen>255<closeparen>,fkComplOrgComSv,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,fkComplOrgExtMin,varchar<openparen>255<closeparen>,modalUso,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,fkComplLazer,varchar<openparen>255<closeparen>,fkComplOrgAgrop,varchar<openparen>255<closeparen>,fkComplEstrApoio,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Patio_polygon Output Nuker"   INPUT FEATURE_TYPE Patio_polygon

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Entroncamento} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Entroncamento_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Entroncamento_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Entroncamento_FeatureDirector    INPUT  FEATURE_TYPE Entroncamento    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Entroncamento___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Entroncamento___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Entroncamento___FeatureDirector1    INPUT FEATURE_TYPE Entroncamento___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Entroncamento___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Entroncamento___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Entroncamento_VectorSetterUpper    INPUT FEATURE_TYPE Entroncamento___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Entroncamento_02ece63d_469a_493c_80f3_1629478a34c872_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Entroncamento___PointCloudThinner    INPUT FEATURE_TYPE Entroncamento___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Entroncamento_02ece63d_469a_493c_80f3_1629478a34c872_thinPointCloud")
Tcl2 proc Entroncamento_02ece63d_469a_493c_80f3_1629478a34c872_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Entroncamento_RasterSetterUpper    INPUT FEATURE_TYPE Entroncamento___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Entroncamento_02ece63d_469a_493c_80f3_1629478a34c872_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Entroncamento_02ece63d_469a_493c_80f3_1629478a34c872_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Entroncamento_02ece63d_469a_493c_80f3_1629478a34c872_VIS_FEAT_TYPE Entroncamento$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Entroncamento_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Entroncamento_02ece63d_469a_493c_80f3_1629478a34c872_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,tipoEntroncamento,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Entroncamento Output Nuker"   INPUT FEATURE_TYPE Entroncamento

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {T_1_LineErrors} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME T_1_LineErrors_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_LineErrors_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME T_1_LineErrors_FeatureDirector    INPUT  FEATURE_TYPE T_1_LineErrors    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE T_1_LineErrors___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE T_1_LineErrors___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME T_1_LineErrors___FeatureDirector1    INPUT FEATURE_TYPE T_1_LineErrors___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE T_1_LineErrors___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE T_1_LineErrors___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_LineErrors_VectorSetterUpper    INPUT FEATURE_TYPE T_1_LineErrors___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc T_1_LineErrors_02ece63d_469a_493c_80f3_1629478a34c873_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_LineErrors___PointCloudThinner    INPUT FEATURE_TYPE T_1_LineErrors___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("T_1_LineErrors_02ece63d_469a_493c_80f3_1629478a34c873_thinPointCloud")
Tcl2 proc T_1_LineErrors_02ece63d_469a_493c_80f3_1629478a34c873_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_LineErrors_RasterSetterUpper    INPUT FEATURE_TYPE T_1_LineErrors___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("T_1_LineErrors_02ece63d_469a_493c_80f3_1629478a34c873_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# T_1_LineErrors_02ece63d_469a_493c_80f3_1629478a34c873_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO T_1_LineErrors_02ece63d_469a_493c_80f3_1629478a34c873_VIS_FEAT_TYPE T_1_LineErrors$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME T_1_LineErrors_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(T_1_LineErrors_02ece63d_469a_493c_80f3_1629478a34c873_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA ObjectID,varchar<openparen>255<closeparen>,OriginClassID,varchar<openparen>255<closeparen>,OriginID,varchar<openparen>255<closeparen>,DestClassID,varchar<openparen>255<closeparen>,DestID,varchar<openparen>255<closeparen>,TopoRuleType,varchar<openparen>255<closeparen>,TopoRuleID,varchar<openparen>255<closeparen>,Shape,varchar<openparen>255<closeparen>,IsException,varchar<openparen>255<closeparen>,Shape_Length,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "T_1_LineErrors Output Nuker"   INPUT FEATURE_TYPE T_1_LineErrors

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {GDB_SpatialRefs} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME GDB_SpatialRefs_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_SpatialRefs_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME GDB_SpatialRefs_FeatureDirector    INPUT  FEATURE_TYPE GDB_SpatialRefs    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE GDB_SpatialRefs___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE GDB_SpatialRefs___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME GDB_SpatialRefs___FeatureDirector1    INPUT FEATURE_TYPE GDB_SpatialRefs___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE GDB_SpatialRefs___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE GDB_SpatialRefs___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_SpatialRefs_VectorSetterUpper    INPUT FEATURE_TYPE GDB_SpatialRefs___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc GDB_SpatialRefs_02ece63d_469a_493c_80f3_1629478a34c874_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_SpatialRefs___PointCloudThinner    INPUT FEATURE_TYPE GDB_SpatialRefs___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("GDB_SpatialRefs_02ece63d_469a_493c_80f3_1629478a34c874_thinPointCloud")
Tcl2 proc GDB_SpatialRefs_02ece63d_469a_493c_80f3_1629478a34c874_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_SpatialRefs_RasterSetterUpper    INPUT FEATURE_TYPE GDB_SpatialRefs___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("GDB_SpatialRefs_02ece63d_469a_493c_80f3_1629478a34c874_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# GDB_SpatialRefs_02ece63d_469a_493c_80f3_1629478a34c874_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO GDB_SpatialRefs_02ece63d_469a_493c_80f3_1629478a34c874_VIS_FEAT_TYPE GDB_SpatialRefs$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME GDB_SpatialRefs_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(GDB_SpatialRefs_02ece63d_469a_493c_80f3_1629478a34c874_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA SRID,varchar<openparen>255<closeparen>,SRTEXT,varchar<openparen>255<closeparen>,FalseX,varchar<openparen>255<closeparen>,FalseY,varchar<openparen>255<closeparen>,XYUnits,varchar<openparen>255<closeparen>,FalseZ,varchar<openparen>255<closeparen>,ZUnits,varchar<openparen>255<closeparen>,FalseM,varchar<openparen>255<closeparen>,MUnits,varchar<openparen>255<closeparen>,IsHighPrecision,varchar<openparen>255<closeparen>,XYTolerance,varchar<openparen>255<closeparen>,ZTolerance,varchar<openparen>255<closeparen>,MTolerance,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "GDB_SpatialRefs Output Nuker"   INPUT FEATURE_TYPE GDB_SpatialRefs

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Ensino_polygon_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Ensino_polygon_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ensino_polygon_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Ensino_polygon_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Ensino_polygon_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Ensino_polygon_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Ensino_polygon_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Ensino_polygon_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Ensino_polygon_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Ensino_polygon_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Ensino_polygon_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ensino_polygon_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Ensino_polygon_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Ensino_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c875_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ensino_polygon_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Ensino_polygon_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Ensino_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c875_thinPointCloud")
Tcl2 proc Edif_Ensino_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c875_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ensino_polygon_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Ensino_polygon_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Ensino_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c875_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Ensino_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c875_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Ensino_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c875_VIS_FEAT_TYPE Edif_Ensino_polygon_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Ensino_polygon_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Ensino_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c875_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Ensino_polygon_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Ensino_polygon_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Pub_Civil_polygon_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Pub_Civil_polygon_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Civil_polygon_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Pub_Civil_polygon_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Pub_Civil_polygon_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Pub_Civil_polygon_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Pub_Civil_polygon_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Pub_Civil_polygon_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Pub_Civil_polygon_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Pub_Civil_polygon_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Pub_Civil_polygon_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Civil_polygon_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Pub_Civil_polygon_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Pub_Civil_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c876_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Civil_polygon_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Pub_Civil_polygon_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Pub_Civil_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c876_thinPointCloud")
Tcl2 proc Edif_Pub_Civil_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c876_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Civil_polygon_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Pub_Civil_polygon_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Pub_Civil_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c876_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Pub_Civil_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c876_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Pub_Civil_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c876_VIS_FEAT_TYPE Edif_Pub_Civil_polygon_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Pub_Civil_polygon_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Pub_Civil_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c876_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Pub_Civil_polygon_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Pub_Civil_polygon_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Terreno_Exposto} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Terreno_Exposto_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Terreno_Exposto_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Terreno_Exposto_FeatureDirector    INPUT  FEATURE_TYPE Terreno_Exposto    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Terreno_Exposto___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Terreno_Exposto___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Terreno_Exposto___FeatureDirector1    INPUT FEATURE_TYPE Terreno_Exposto___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Terreno_Exposto___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Terreno_Exposto___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Terreno_Exposto_VectorSetterUpper    INPUT FEATURE_TYPE Terreno_Exposto___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Terreno_Exposto_02ece63d_469a_493c_80f3_1629478a34c877_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Terreno_Exposto___PointCloudThinner    INPUT FEATURE_TYPE Terreno_Exposto___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Terreno_Exposto_02ece63d_469a_493c_80f3_1629478a34c877_thinPointCloud")
Tcl2 proc Terreno_Exposto_02ece63d_469a_493c_80f3_1629478a34c877_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Terreno_Exposto_RasterSetterUpper    INPUT FEATURE_TYPE Terreno_Exposto___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Terreno_Exposto_02ece63d_469a_493c_80f3_1629478a34c877_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Terreno_Exposto_02ece63d_469a_493c_80f3_1629478a34c877_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Terreno_Exposto_02ece63d_469a_493c_80f3_1629478a34c877_VIS_FEAT_TYPE Terreno_Exposto$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Terreno_Exposto_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Terreno_Exposto_02ece63d_469a_493c_80f3_1629478a34c877_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,tipoTerrExp,varchar<openparen>255<closeparen>,causaExposicao,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Terreno_Exposto Output Nuker"   INPUT FEATURE_TYPE Terreno_Exposto

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Comunic_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Comunic_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comunic_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Comunic_point_FeatureDirector    INPUT  FEATURE_TYPE Edif_Comunic_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Comunic_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Comunic_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Comunic_point___FeatureDirector1    INPUT FEATURE_TYPE Edif_Comunic_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Comunic_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Comunic_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comunic_point_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Comunic_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Comunic_point_02ece63d_469a_493c_80f3_1629478a34c878_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comunic_point___PointCloudThinner    INPUT FEATURE_TYPE Edif_Comunic_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Comunic_point_02ece63d_469a_493c_80f3_1629478a34c878_thinPointCloud")
Tcl2 proc Edif_Comunic_point_02ece63d_469a_493c_80f3_1629478a34c878_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comunic_point_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Comunic_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Comunic_point_02ece63d_469a_493c_80f3_1629478a34c878_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Comunic_point_02ece63d_469a_493c_80f3_1629478a34c878_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Comunic_point_02ece63d_469a_493c_80f3_1629478a34c878_VIS_FEAT_TYPE Edif_Comunic_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Comunic_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Comunic_point_02ece63d_469a_493c_80f3_1629478a34c878_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,tipoEdifComunic,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,modalidade,varchar<openparen>255<closeparen>,fkComplComunic,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Comunic_point Output Nuker"   INPUT FEATURE_TYPE Edif_Comunic_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Comerc_Serv_polygon} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Comerc_Serv_polygon_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comerc_Serv_polygon_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Comerc_Serv_polygon_FeatureDirector    INPUT  FEATURE_TYPE Edif_Comerc_Serv_polygon    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Comerc_Serv_polygon___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Comerc_Serv_polygon___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Comerc_Serv_polygon___FeatureDirector1    INPUT FEATURE_TYPE Edif_Comerc_Serv_polygon___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Comerc_Serv_polygon___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Comerc_Serv_polygon___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comerc_Serv_polygon_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Comerc_Serv_polygon___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Comerc_Serv_polygon_02ece63d_469a_493c_80f3_1629478a34c879_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comerc_Serv_polygon___PointCloudThinner    INPUT FEATURE_TYPE Edif_Comerc_Serv_polygon___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Comerc_Serv_polygon_02ece63d_469a_493c_80f3_1629478a34c879_thinPointCloud")
Tcl2 proc Edif_Comerc_Serv_polygon_02ece63d_469a_493c_80f3_1629478a34c879_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comerc_Serv_polygon_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Comerc_Serv_polygon___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Comerc_Serv_polygon_02ece63d_469a_493c_80f3_1629478a34c879_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Comerc_Serv_polygon_02ece63d_469a_493c_80f3_1629478a34c879_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Comerc_Serv_polygon_02ece63d_469a_493c_80f3_1629478a34c879_VIS_FEAT_TYPE Edif_Comerc_Serv_polygon$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Comerc_Serv_polygon_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Comerc_Serv_polygon_02ece63d_469a_493c_80f3_1629478a34c879_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,fkComplOrgComSv,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,finalidade,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,tipoEdifComercServ,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Comerc_Serv_polygon Output Nuker"   INPUT FEATURE_TYPE Edif_Comerc_Serv_polygon

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Torre_Comunic_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Torre_Comunic_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Torre_Comunic_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Torre_Comunic_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Torre_Comunic_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Torre_Comunic_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Torre_Comunic_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Torre_Comunic_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Torre_Comunic_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Torre_Comunic_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Torre_Comunic_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Torre_Comunic_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Torre_Comunic_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Torre_Comunic_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c880_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Torre_Comunic_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Torre_Comunic_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Torre_Comunic_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c880_thinPointCloud")
Tcl2 proc Torre_Comunic_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c880_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Torre_Comunic_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Torre_Comunic_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Torre_Comunic_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c880_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Torre_Comunic_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c880_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Torre_Comunic_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c880_VIS_FEAT_TYPE Torre_Comunic_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Torre_Comunic_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Torre_Comunic_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c880_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Torre_Comunic_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Torre_Comunic_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Pub_Militar_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Pub_Militar_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Militar_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Pub_Militar_point_FeatureDirector    INPUT  FEATURE_TYPE Edif_Pub_Militar_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Pub_Militar_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Pub_Militar_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Pub_Militar_point___FeatureDirector1    INPUT FEATURE_TYPE Edif_Pub_Militar_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Pub_Militar_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Pub_Militar_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Militar_point_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Pub_Militar_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Pub_Militar_point_02ece63d_469a_493c_80f3_1629478a34c881_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Militar_point___PointCloudThinner    INPUT FEATURE_TYPE Edif_Pub_Militar_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Pub_Militar_point_02ece63d_469a_493c_80f3_1629478a34c881_thinPointCloud")
Tcl2 proc Edif_Pub_Militar_point_02ece63d_469a_493c_80f3_1629478a34c881_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Militar_point_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Pub_Militar_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Pub_Militar_point_02ece63d_469a_493c_80f3_1629478a34c881_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Pub_Militar_point_02ece63d_469a_493c_80f3_1629478a34c881_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Pub_Militar_point_02ece63d_469a_493c_80f3_1629478a34c881_VIS_FEAT_TYPE Edif_Pub_Militar_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Pub_Militar_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Pub_Militar_point_02ece63d_469a_493c_80f3_1629478a34c881_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,fkComplMilitar,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,tipoEdif,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,tipoUsoEdif,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Pub_Militar_point Output Nuker"   INPUT FEATURE_TYPE Edif_Pub_Militar_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Antena_Comunic_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Antena_Comunic_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Antena_Comunic_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Antena_Comunic_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Antena_Comunic_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Antena_Comunic_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Antena_Comunic_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Antena_Comunic_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Antena_Comunic_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Antena_Comunic_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Antena_Comunic_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Antena_Comunic_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Antena_Comunic_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Antena_Comunic_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c882_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Antena_Comunic_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Antena_Comunic_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Antena_Comunic_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c882_thinPointCloud")
Tcl2 proc Antena_Comunic_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c882_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Antena_Comunic_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Antena_Comunic_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Antena_Comunic_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c882_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Antena_Comunic_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c882_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Antena_Comunic_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c882_VIS_FEAT_TYPE Antena_Comunic_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Antena_Comunic_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Antena_Comunic_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c882_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Antena_Comunic_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Antena_Comunic_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Elemento_Fisiog_Natural_line_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Elemento_Fisiog_Natural_line_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Elemento_Fisiog_Natural_line_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Elemento_Fisiog_Natural_line_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Elemento_Fisiog_Natural_line_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Elemento_Fisiog_Natural_line_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Elemento_Fisiog_Natural_line_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Elemento_Fisiog_Natural_line_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Elemento_Fisiog_Natural_line_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Elemento_Fisiog_Natural_line_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Elemento_Fisiog_Natural_line_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Elemento_Fisiog_Natural_line_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Elemento_Fisiog_Natural_line_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Elemento_Fisiog_Natural_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c883_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Elemento_Fisiog_Natural_line_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Elemento_Fisiog_Natural_line_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Elemento_Fisiog_Natural_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c883_thinPointCloud")
Tcl2 proc Elemento_Fisiog_Natural_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c883_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Elemento_Fisiog_Natural_line_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Elemento_Fisiog_Natural_line_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Elemento_Fisiog_Natural_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c883_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Elemento_Fisiog_Natural_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c883_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Elemento_Fisiog_Natural_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c883_VIS_FEAT_TYPE Elemento_Fisiog_Natural_line_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Elemento_Fisiog_Natural_line_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Elemento_Fisiog_Natural_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c883_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Elemento_Fisiog_Natural_line_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Elemento_Fisiog_Natural_line_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Saude_polygon} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Saude_polygon_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saude_polygon_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Saude_polygon_FeatureDirector    INPUT  FEATURE_TYPE Edif_Saude_polygon    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Saude_polygon___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Saude_polygon___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Saude_polygon___FeatureDirector1    INPUT FEATURE_TYPE Edif_Saude_polygon___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Saude_polygon___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Saude_polygon___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saude_polygon_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Saude_polygon___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Saude_polygon_02ece63d_469a_493c_80f3_1629478a34c884_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saude_polygon___PointCloudThinner    INPUT FEATURE_TYPE Edif_Saude_polygon___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Saude_polygon_02ece63d_469a_493c_80f3_1629478a34c884_thinPointCloud")
Tcl2 proc Edif_Saude_polygon_02ece63d_469a_493c_80f3_1629478a34c884_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saude_polygon_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Saude_polygon___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Saude_polygon_02ece63d_469a_493c_80f3_1629478a34c884_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Saude_polygon_02ece63d_469a_493c_80f3_1629478a34c884_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Saude_polygon_02ece63d_469a_493c_80f3_1629478a34c884_VIS_FEAT_TYPE Edif_Saude_polygon$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Saude_polygon_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Saude_polygon_02ece63d_469a_493c_80f3_1629478a34c884_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,fkComplSaude,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,tipoClasseCnae,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,nivelAtencao,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Saude_polygon Output Nuker"   INPUT FEATURE_TYPE Edif_Saude_polygon

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Travessia_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Travessia_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Travessia_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Travessia_point_FeatureDirector    INPUT  FEATURE_TYPE Travessia_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Travessia_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Travessia_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Travessia_point___FeatureDirector1    INPUT FEATURE_TYPE Travessia_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Travessia_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Travessia_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Travessia_point_VectorSetterUpper    INPUT FEATURE_TYPE Travessia_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Travessia_point_02ece63d_469a_493c_80f3_1629478a34c885_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Travessia_point___PointCloudThinner    INPUT FEATURE_TYPE Travessia_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Travessia_point_02ece63d_469a_493c_80f3_1629478a34c885_thinPointCloud")
Tcl2 proc Travessia_point_02ece63d_469a_493c_80f3_1629478a34c885_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Travessia_point_RasterSetterUpper    INPUT FEATURE_TYPE Travessia_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Travessia_point_02ece63d_469a_493c_80f3_1629478a34c885_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Travessia_point_02ece63d_469a_493c_80f3_1629478a34c885_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Travessia_point_02ece63d_469a_493c_80f3_1629478a34c885_VIS_FEAT_TYPE Travessia_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Travessia_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Travessia_point_02ece63d_469a_493c_80f3_1629478a34c885_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,tipoTravessia,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Travessia_point Output Nuker"   INPUT FEATURE_TYPE Travessia_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Gruta_Caverna_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Gruta_Caverna_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Gruta_Caverna_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Gruta_Caverna_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Gruta_Caverna_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Gruta_Caverna_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Gruta_Caverna_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Gruta_Caverna_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Gruta_Caverna_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Gruta_Caverna_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Gruta_Caverna_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Gruta_Caverna_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Gruta_Caverna_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Gruta_Caverna_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c886_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Gruta_Caverna_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Gruta_Caverna_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Gruta_Caverna_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c886_thinPointCloud")
Tcl2 proc Gruta_Caverna_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c886_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Gruta_Caverna_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Gruta_Caverna_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Gruta_Caverna_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c886_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Gruta_Caverna_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c886_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Gruta_Caverna_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c886_VIS_FEAT_TYPE Gruta_Caverna_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Gruta_Caverna_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Gruta_Caverna_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c886_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Gruta_Caverna_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Gruta_Caverna_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Trilha_Picada} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Trilha_Picada_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Trilha_Picada_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Trilha_Picada_FeatureDirector    INPUT  FEATURE_TYPE Trilha_Picada    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Trilha_Picada___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Trilha_Picada___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Trilha_Picada___FeatureDirector1    INPUT FEATURE_TYPE Trilha_Picada___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Trilha_Picada___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Trilha_Picada___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Trilha_Picada_VectorSetterUpper    INPUT FEATURE_TYPE Trilha_Picada___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Trilha_Picada_02ece63d_469a_493c_80f3_1629478a34c887_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trilha_Picada___PointCloudThinner    INPUT FEATURE_TYPE Trilha_Picada___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trilha_Picada_02ece63d_469a_493c_80f3_1629478a34c887_thinPointCloud")
Tcl2 proc Trilha_Picada_02ece63d_469a_493c_80f3_1629478a34c887_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trilha_Picada_RasterSetterUpper    INPUT FEATURE_TYPE Trilha_Picada___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trilha_Picada_02ece63d_469a_493c_80f3_1629478a34c887_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Trilha_Picada_02ece63d_469a_493c_80f3_1629478a34c887_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Trilha_Picada_02ece63d_469a_493c_80f3_1629478a34c887_VIS_FEAT_TYPE Trilha_Picada$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Trilha_Picada_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Trilha_Picada_02ece63d_469a_493c_80f3_1629478a34c887_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Trilha_Picada Output Nuker"   INPUT FEATURE_TYPE Trilha_Picada

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Pto_Est_Med_Fenomenos} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Pto_Est_Med_Fenomenos_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Pto_Est_Med_Fenomenos_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Pto_Est_Med_Fenomenos_FeatureDirector    INPUT  FEATURE_TYPE Pto_Est_Med_Fenomenos    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Pto_Est_Med_Fenomenos___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Pto_Est_Med_Fenomenos___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Pto_Est_Med_Fenomenos___FeatureDirector1    INPUT FEATURE_TYPE Pto_Est_Med_Fenomenos___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Pto_Est_Med_Fenomenos___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Pto_Est_Med_Fenomenos___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Pto_Est_Med_Fenomenos_VectorSetterUpper    INPUT FEATURE_TYPE Pto_Est_Med_Fenomenos___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Pto_Est_Med_Fenomenos_02ece63d_469a_493c_80f3_1629478a34c888_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Pto_Est_Med_Fenomenos___PointCloudThinner    INPUT FEATURE_TYPE Pto_Est_Med_Fenomenos___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Pto_Est_Med_Fenomenos_02ece63d_469a_493c_80f3_1629478a34c888_thinPointCloud")
Tcl2 proc Pto_Est_Med_Fenomenos_02ece63d_469a_493c_80f3_1629478a34c888_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Pto_Est_Med_Fenomenos_RasterSetterUpper    INPUT FEATURE_TYPE Pto_Est_Med_Fenomenos___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Pto_Est_Med_Fenomenos_02ece63d_469a_493c_80f3_1629478a34c888_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Pto_Est_Med_Fenomenos_02ece63d_469a_493c_80f3_1629478a34c888_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Pto_Est_Med_Fenomenos_02ece63d_469a_493c_80f3_1629478a34c888_VIS_FEAT_TYPE Pto_Est_Med_Fenomenos$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Pto_Est_Med_Fenomenos_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Pto_Est_Med_Fenomenos_02ece63d_469a_493c_80f3_1629478a34c888_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,codEstacao,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,fkComplEstMedFen,varchar<openparen>255<closeparen>,orgaoEnteResp,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,tipoPtoEstMed,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Pto_Est_Med_Fenomenos Output Nuker"   INPUT FEATURE_TYPE Pto_Est_Med_Fenomenos

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Pista_Competicao_line} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Pista_Competicao_line_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Pista_Competicao_line_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Pista_Competicao_line_FeatureDirector    INPUT  FEATURE_TYPE Pista_Competicao_line    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Pista_Competicao_line___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Pista_Competicao_line___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Pista_Competicao_line___FeatureDirector1    INPUT FEATURE_TYPE Pista_Competicao_line___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Pista_Competicao_line___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Pista_Competicao_line___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Pista_Competicao_line_VectorSetterUpper    INPUT FEATURE_TYPE Pista_Competicao_line___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Pista_Competicao_line_02ece63d_469a_493c_80f3_1629478a34c889_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Pista_Competicao_line___PointCloudThinner    INPUT FEATURE_TYPE Pista_Competicao_line___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Pista_Competicao_line_02ece63d_469a_493c_80f3_1629478a34c889_thinPointCloud")
Tcl2 proc Pista_Competicao_line_02ece63d_469a_493c_80f3_1629478a34c889_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Pista_Competicao_line_RasterSetterUpper    INPUT FEATURE_TYPE Pista_Competicao_line___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Pista_Competicao_line_02ece63d_469a_493c_80f3_1629478a34c889_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Pista_Competicao_line_02ece63d_469a_493c_80f3_1629478a34c889_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Pista_Competicao_line_02ece63d_469a_493c_80f3_1629478a34c889_VIS_FEAT_TYPE Pista_Competicao_line$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Pista_Competicao_line_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Pista_Competicao_line_02ece63d_469a_493c_80f3_1629478a34c889_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,tipoPista,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,fkComplLazer,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Pista_Competicao_line Output Nuker"   INPUT FEATURE_TYPE Pista_Competicao_line

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Area_Edificada_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Area_Edificada_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Edificada_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Area_Edificada_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Area_Edificada_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Area_Edificada_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Edificada_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Area_Edificada_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Area_Edificada_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Area_Edificada_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Edificada_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Edificada_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Area_Edificada_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Area_Edificada_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c890_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Edificada_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Area_Edificada_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Edificada_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c890_thinPointCloud")
Tcl2 proc Area_Edificada_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c890_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Edificada_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Area_Edificada_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Edificada_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c890_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Area_Edificada_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c890_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Area_Edificada_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c890_VIS_FEAT_TYPE Area_Edificada_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Area_Edificada_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Area_Edificada_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c890_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Area_Edificada_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Area_Edificada_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Const_Turistica_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Const_Turistica_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Turistica_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Const_Turistica_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Const_Turistica_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Const_Turistica_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Const_Turistica_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Const_Turistica_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Const_Turistica_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Const_Turistica_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Const_Turistica_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Turistica_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Const_Turistica_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Const_Turistica_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c891_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Turistica_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Const_Turistica_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Const_Turistica_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c891_thinPointCloud")
Tcl2 proc Edif_Const_Turistica_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c891_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Turistica_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Const_Turistica_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Const_Turistica_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c891_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Const_Turistica_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c891_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Const_Turistica_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c891_VIS_FEAT_TYPE Edif_Const_Turistica_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Const_Turistica_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Const_Turistica_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c891_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Const_Turistica_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Const_Turistica_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Aglomerado_Rural_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Aglomerado_Rural_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Aglomerado_Rural_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Aglomerado_Rural_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Aglomerado_Rural_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Aglomerado_Rural_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Aglomerado_Rural_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Aglomerado_Rural_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Aglomerado_Rural_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Aglomerado_Rural_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Aglomerado_Rural_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Aglomerado_Rural_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Aglomerado_Rural_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Aglomerado_Rural_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c892_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Aglomerado_Rural_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Aglomerado_Rural_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Aglomerado_Rural_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c892_thinPointCloud")
Tcl2 proc Aglomerado_Rural_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c892_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Aglomerado_Rural_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Aglomerado_Rural_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Aglomerado_Rural_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c892_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Aglomerado_Rural_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c892_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Aglomerado_Rural_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c892_VIS_FEAT_TYPE Aglomerado_Rural_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Aglomerado_Rural_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Aglomerado_Rural_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c892_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Aglomerado_Rural_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Aglomerado_Rural_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Area_Energia_Eletrica_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Area_Energia_Eletrica_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Energia_Eletrica_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Area_Energia_Eletrica_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Area_Energia_Eletrica_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Area_Energia_Eletrica_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Energia_Eletrica_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Area_Energia_Eletrica_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Area_Energia_Eletrica_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Area_Energia_Eletrica_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Energia_Eletrica_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Energia_Eletrica_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Area_Energia_Eletrica_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Area_Energia_Eletrica_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c893_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Energia_Eletrica_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Area_Energia_Eletrica_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Energia_Eletrica_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c893_thinPointCloud")
Tcl2 proc Area_Energia_Eletrica_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c893_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Energia_Eletrica_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Area_Energia_Eletrica_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Energia_Eletrica_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c893_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Area_Energia_Eletrica_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c893_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Area_Energia_Eletrica_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c893_VIS_FEAT_TYPE Area_Energia_Eletrica_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Area_Energia_Eletrica_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Area_Energia_Eletrica_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c893_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Area_Energia_Eletrica_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Area_Energia_Eletrica_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Area_Industrial_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Area_Industrial_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Industrial_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Area_Industrial_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Area_Industrial_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Area_Industrial_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Industrial_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Area_Industrial_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Area_Industrial_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Area_Industrial_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Industrial_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Industrial_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Area_Industrial_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Area_Industrial_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c894_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Industrial_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Area_Industrial_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Industrial_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c894_thinPointCloud")
Tcl2 proc Area_Industrial_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c894_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Industrial_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Area_Industrial_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Industrial_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c894_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Area_Industrial_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c894_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Area_Industrial_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c894_VIS_FEAT_TYPE Area_Industrial_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Area_Industrial_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Area_Industrial_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c894_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Area_Industrial_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Area_Industrial_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Ext_Mineral_polygon} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Ext_Mineral_polygon_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ext_Mineral_polygon_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Ext_Mineral_polygon_FeatureDirector    INPUT  FEATURE_TYPE Edif_Ext_Mineral_polygon    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Ext_Mineral_polygon___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Ext_Mineral_polygon___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Ext_Mineral_polygon___FeatureDirector1    INPUT FEATURE_TYPE Edif_Ext_Mineral_polygon___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Ext_Mineral_polygon___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Ext_Mineral_polygon___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ext_Mineral_polygon_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Ext_Mineral_polygon___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Ext_Mineral_polygon_02ece63d_469a_493c_80f3_1629478a34c895_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ext_Mineral_polygon___PointCloudThinner    INPUT FEATURE_TYPE Edif_Ext_Mineral_polygon___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Ext_Mineral_polygon_02ece63d_469a_493c_80f3_1629478a34c895_thinPointCloud")
Tcl2 proc Edif_Ext_Mineral_polygon_02ece63d_469a_493c_80f3_1629478a34c895_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ext_Mineral_polygon_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Ext_Mineral_polygon___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Ext_Mineral_polygon_02ece63d_469a_493c_80f3_1629478a34c895_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Ext_Mineral_polygon_02ece63d_469a_493c_80f3_1629478a34c895_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Ext_Mineral_polygon_02ece63d_469a_493c_80f3_1629478a34c895_VIS_FEAT_TYPE Edif_Ext_Mineral_polygon$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Ext_Mineral_polygon_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Ext_Mineral_polygon_02ece63d_469a_493c_80f3_1629478a34c895_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,fkComplOrgExtMin,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,tipoDivisaoCnae,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Ext_Mineral_polygon Output Nuker"   INPUT FEATURE_TYPE Edif_Ext_Mineral_polygon

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Comerc_Serv_polygon_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Comerc_Serv_polygon_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comerc_Serv_polygon_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Comerc_Serv_polygon_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Comerc_Serv_polygon_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Comerc_Serv_polygon_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Comerc_Serv_polygon_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Comerc_Serv_polygon_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Comerc_Serv_polygon_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Comerc_Serv_polygon_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Comerc_Serv_polygon_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comerc_Serv_polygon_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Comerc_Serv_polygon_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Comerc_Serv_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c896_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comerc_Serv_polygon_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Comerc_Serv_polygon_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Comerc_Serv_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c896_thinPointCloud")
Tcl2 proc Edif_Comerc_Serv_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c896_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Comerc_Serv_polygon_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Comerc_Serv_polygon_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Comerc_Serv_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c896_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Comerc_Serv_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c896_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Comerc_Serv_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c896_VIS_FEAT_TYPE Edif_Comerc_Serv_polygon_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Comerc_Serv_polygon_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Comerc_Serv_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c896_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Comerc_Serv_polygon_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Comerc_Serv_polygon_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {T_1_PointErrors} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME T_1_PointErrors_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_PointErrors_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME T_1_PointErrors_FeatureDirector    INPUT  FEATURE_TYPE T_1_PointErrors    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE T_1_PointErrors___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE T_1_PointErrors___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME T_1_PointErrors___FeatureDirector1    INPUT FEATURE_TYPE T_1_PointErrors___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE T_1_PointErrors___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE T_1_PointErrors___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_PointErrors_VectorSetterUpper    INPUT FEATURE_TYPE T_1_PointErrors___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc T_1_PointErrors_02ece63d_469a_493c_80f3_1629478a34c897_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_PointErrors___PointCloudThinner    INPUT FEATURE_TYPE T_1_PointErrors___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("T_1_PointErrors_02ece63d_469a_493c_80f3_1629478a34c897_thinPointCloud")
Tcl2 proc T_1_PointErrors_02ece63d_469a_493c_80f3_1629478a34c897_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_PointErrors_RasterSetterUpper    INPUT FEATURE_TYPE T_1_PointErrors___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("T_1_PointErrors_02ece63d_469a_493c_80f3_1629478a34c897_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# T_1_PointErrors_02ece63d_469a_493c_80f3_1629478a34c897_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO T_1_PointErrors_02ece63d_469a_493c_80f3_1629478a34c897_VIS_FEAT_TYPE T_1_PointErrors$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME T_1_PointErrors_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(T_1_PointErrors_02ece63d_469a_493c_80f3_1629478a34c897_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA ObjectID,varchar<openparen>255<closeparen>,OriginClassID,varchar<openparen>255<closeparen>,OriginID,varchar<openparen>255<closeparen>,DestClassID,varchar<openparen>255<closeparen>,DestID,varchar<openparen>255<closeparen>,TopoRuleType,varchar<openparen>255<closeparen>,TopoRuleID,varchar<openparen>255<closeparen>,Shape,varchar<openparen>255<closeparen>,IsException,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "T_1_PointErrors Output Nuker"   INPUT FEATURE_TYPE T_1_PointErrors

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Area_Ext_Mineral_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Area_Ext_Mineral_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Ext_Mineral_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Area_Ext_Mineral_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Area_Ext_Mineral_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Area_Ext_Mineral_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Ext_Mineral_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Area_Ext_Mineral_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Area_Ext_Mineral_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Area_Ext_Mineral_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Ext_Mineral_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Ext_Mineral_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Area_Ext_Mineral_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Area_Ext_Mineral_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c898_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Ext_Mineral_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Area_Ext_Mineral_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Ext_Mineral_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c898_thinPointCloud")
Tcl2 proc Area_Ext_Mineral_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c898_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Ext_Mineral_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Area_Ext_Mineral_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Ext_Mineral_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c898_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Area_Ext_Mineral_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c898_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Area_Ext_Mineral_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c898_VIS_FEAT_TYPE Area_Ext_Mineral_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Area_Ext_Mineral_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Area_Ext_Mineral_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c898_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Area_Ext_Mineral_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Area_Ext_Mineral_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Rodoviaria_polygon} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Rodoviaria_polygon_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Rodoviaria_polygon_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Rodoviaria_polygon_FeatureDirector    INPUT  FEATURE_TYPE Edif_Rodoviaria_polygon    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Rodoviaria_polygon___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Rodoviaria_polygon___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Rodoviaria_polygon___FeatureDirector1    INPUT FEATURE_TYPE Edif_Rodoviaria_polygon___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Rodoviaria_polygon___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Rodoviaria_polygon___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Rodoviaria_polygon_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Rodoviaria_polygon___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Rodoviaria_polygon_02ece63d_469a_493c_80f3_1629478a34c899_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Rodoviaria_polygon___PointCloudThinner    INPUT FEATURE_TYPE Edif_Rodoviaria_polygon___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Rodoviaria_polygon_02ece63d_469a_493c_80f3_1629478a34c899_thinPointCloud")
Tcl2 proc Edif_Rodoviaria_polygon_02ece63d_469a_493c_80f3_1629478a34c899_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Rodoviaria_polygon_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Rodoviaria_polygon___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Rodoviaria_polygon_02ece63d_469a_493c_80f3_1629478a34c899_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Rodoviaria_polygon_02ece63d_469a_493c_80f3_1629478a34c899_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Rodoviaria_polygon_02ece63d_469a_493c_80f3_1629478a34c899_VIS_FEAT_TYPE Edif_Rodoviaria_polygon$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Rodoviaria_polygon_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Rodoviaria_polygon_02ece63d_469a_493c_80f3_1629478a34c899_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,tipoEdifRod,varchar<openparen>255<closeparen>,administracao,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,fkComplEstrApoio,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Rodoviaria_polygon Output Nuker"   INPUT FEATURE_TYPE Edif_Rodoviaria_polygon

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {GDB_ItemRelationships} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME GDB_ItemRelationships_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_ItemRelationships_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME GDB_ItemRelationships_FeatureDirector    INPUT  FEATURE_TYPE GDB_ItemRelationships    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE GDB_ItemRelationships___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE GDB_ItemRelationships___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME GDB_ItemRelationships___FeatureDirector1    INPUT FEATURE_TYPE GDB_ItemRelationships___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE GDB_ItemRelationships___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE GDB_ItemRelationships___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_ItemRelationships_VectorSetterUpper    INPUT FEATURE_TYPE GDB_ItemRelationships___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc GDB_ItemRelationships_02ece63d_469a_493c_80f3_1629478a34c8100_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_ItemRelationships___PointCloudThinner    INPUT FEATURE_TYPE GDB_ItemRelationships___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("GDB_ItemRelationships_02ece63d_469a_493c_80f3_1629478a34c8100_thinPointCloud")
Tcl2 proc GDB_ItemRelationships_02ece63d_469a_493c_80f3_1629478a34c8100_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_ItemRelationships_RasterSetterUpper    INPUT FEATURE_TYPE GDB_ItemRelationships___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("GDB_ItemRelationships_02ece63d_469a_493c_80f3_1629478a34c8100_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# GDB_ItemRelationships_02ece63d_469a_493c_80f3_1629478a34c8100_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO GDB_ItemRelationships_02ece63d_469a_493c_80f3_1629478a34c8100_VIS_FEAT_TYPE GDB_ItemRelationships$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME GDB_ItemRelationships_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(GDB_ItemRelationships_02ece63d_469a_493c_80f3_1629478a34c8100_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA ObjectID,varchar<openparen>255<closeparen>,UUID,varchar<openparen>255<closeparen>,OriginID,varchar<openparen>255<closeparen>,DestID,varchar<openparen>255<closeparen>,Type,varchar<openparen>255<closeparen>,Attributes,varchar<openparen>255<closeparen>,Properties,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "GDB_ItemRelationships Output Nuker"   INPUT FEATURE_TYPE GDB_ItemRelationships

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Pub_Militar_polygon_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Pub_Militar_polygon_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Militar_polygon_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Pub_Militar_polygon_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Pub_Militar_polygon_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Pub_Militar_polygon_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Pub_Militar_polygon_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Pub_Militar_polygon_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Pub_Militar_polygon_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Pub_Militar_polygon_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Pub_Militar_polygon_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Militar_polygon_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Pub_Militar_polygon_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Pub_Militar_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8101_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Militar_polygon_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Pub_Militar_polygon_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Pub_Militar_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8101_thinPointCloud")
Tcl2 proc Edif_Pub_Militar_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8101_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Militar_polygon_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Pub_Militar_polygon_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Pub_Militar_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8101_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Pub_Militar_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8101_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Pub_Militar_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8101_VIS_FEAT_TYPE Edif_Pub_Militar_polygon_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Pub_Militar_polygon_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Pub_Militar_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8101_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Pub_Militar_polygon_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Pub_Militar_polygon_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Area_Energia_Eletrica} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Area_Energia_Eletrica_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Energia_Eletrica_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Area_Energia_Eletrica_FeatureDirector    INPUT  FEATURE_TYPE Area_Energia_Eletrica    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Area_Energia_Eletrica___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Energia_Eletrica___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Area_Energia_Eletrica___FeatureDirector1    INPUT FEATURE_TYPE Area_Energia_Eletrica___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Area_Energia_Eletrica___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Energia_Eletrica___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Energia_Eletrica_VectorSetterUpper    INPUT FEATURE_TYPE Area_Energia_Eletrica___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Area_Energia_Eletrica_02ece63d_469a_493c_80f3_1629478a34c8102_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Energia_Eletrica___PointCloudThinner    INPUT FEATURE_TYPE Area_Energia_Eletrica___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Energia_Eletrica_02ece63d_469a_493c_80f3_1629478a34c8102_thinPointCloud")
Tcl2 proc Area_Energia_Eletrica_02ece63d_469a_493c_80f3_1629478a34c8102_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Energia_Eletrica_RasterSetterUpper    INPUT FEATURE_TYPE Area_Energia_Eletrica___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Energia_Eletrica_02ece63d_469a_493c_80f3_1629478a34c8102_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Area_Energia_Eletrica_02ece63d_469a_493c_80f3_1629478a34c8102_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Area_Energia_Eletrica_02ece63d_469a_493c_80f3_1629478a34c8102_VIS_FEAT_TYPE Area_Energia_Eletrica$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Area_Energia_Eletrica_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Area_Energia_Eletrica_02ece63d_469a_493c_80f3_1629478a34c8102_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,fkComplGerEnEletr,varchar<openparen>255<closeparen>,fkComplSubEnEletr,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Area_Energia_Eletrica Output Nuker"   INPUT FEATURE_TYPE Area_Energia_Eletrica

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Servico_Social_polygon_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Servico_Social_polygon_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Servico_Social_polygon_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Servico_Social_polygon_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Servico_Social_polygon_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Servico_Social_polygon_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Servico_Social_polygon_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Servico_Social_polygon_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Servico_Social_polygon_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Servico_Social_polygon_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Servico_Social_polygon_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Servico_Social_polygon_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Servico_Social_polygon_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Servico_Social_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8103_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Servico_Social_polygon_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Servico_Social_polygon_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Servico_Social_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8103_thinPointCloud")
Tcl2 proc Edif_Servico_Social_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8103_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Servico_Social_polygon_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Servico_Social_polygon_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Servico_Social_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8103_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Servico_Social_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8103_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Servico_Social_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8103_VIS_FEAT_TYPE Edif_Servico_Social_polygon_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Servico_Social_polygon_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Servico_Social_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8103_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Servico_Social_polygon_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Servico_Social_polygon_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Abast_Agua_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Abast_Agua_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Abast_Agua_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Abast_Agua_point_FeatureDirector    INPUT  FEATURE_TYPE Edif_Abast_Agua_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Abast_Agua_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Abast_Agua_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Abast_Agua_point___FeatureDirector1    INPUT FEATURE_TYPE Edif_Abast_Agua_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Abast_Agua_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Abast_Agua_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Abast_Agua_point_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Abast_Agua_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Abast_Agua_point_02ece63d_469a_493c_80f3_1629478a34c8104_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Abast_Agua_point___PointCloudThinner    INPUT FEATURE_TYPE Edif_Abast_Agua_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Abast_Agua_point_02ece63d_469a_493c_80f3_1629478a34c8104_thinPointCloud")
Tcl2 proc Edif_Abast_Agua_point_02ece63d_469a_493c_80f3_1629478a34c8104_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Abast_Agua_point_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Abast_Agua_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Abast_Agua_point_02ece63d_469a_493c_80f3_1629478a34c8104_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Abast_Agua_point_02ece63d_469a_493c_80f3_1629478a34c8104_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Abast_Agua_point_02ece63d_469a_493c_80f3_1629478a34c8104_VIS_FEAT_TYPE Edif_Abast_Agua_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Abast_Agua_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Abast_Agua_point_02ece63d_469a_493c_80f3_1629478a34c8104_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,tipoEdifAbast,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,fkComplAbsAgua,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Abast_Agua_point Output Nuker"   INPUT FEATURE_TYPE Edif_Abast_Agua_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Elemento_Fisiog_Natural_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Elemento_Fisiog_Natural_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Elemento_Fisiog_Natural_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Elemento_Fisiog_Natural_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Elemento_Fisiog_Natural_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Elemento_Fisiog_Natural_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Elemento_Fisiog_Natural_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Elemento_Fisiog_Natural_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Elemento_Fisiog_Natural_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Elemento_Fisiog_Natural_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Elemento_Fisiog_Natural_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Elemento_Fisiog_Natural_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Elemento_Fisiog_Natural_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Elemento_Fisiog_Natural_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8105_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Elemento_Fisiog_Natural_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Elemento_Fisiog_Natural_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Elemento_Fisiog_Natural_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8105_thinPointCloud")
Tcl2 proc Elemento_Fisiog_Natural_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8105_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Elemento_Fisiog_Natural_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Elemento_Fisiog_Natural_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Elemento_Fisiog_Natural_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8105_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Elemento_Fisiog_Natural_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8105_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Elemento_Fisiog_Natural_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8105_VIS_FEAT_TYPE Elemento_Fisiog_Natural_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Elemento_Fisiog_Natural_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Elemento_Fisiog_Natural_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8105_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Elemento_Fisiog_Natural_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Elemento_Fisiog_Natural_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Religiosa_polygon} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Religiosa_polygon_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Religiosa_polygon_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Religiosa_polygon_FeatureDirector    INPUT  FEATURE_TYPE Edif_Religiosa_polygon    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Religiosa_polygon___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Religiosa_polygon___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Religiosa_polygon___FeatureDirector1    INPUT FEATURE_TYPE Edif_Religiosa_polygon___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Religiosa_polygon___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Religiosa_polygon___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Religiosa_polygon_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Religiosa_polygon___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Religiosa_polygon_02ece63d_469a_493c_80f3_1629478a34c8106_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Religiosa_polygon___PointCloudThinner    INPUT FEATURE_TYPE Edif_Religiosa_polygon___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Religiosa_polygon_02ece63d_469a_493c_80f3_1629478a34c8106_thinPointCloud")
Tcl2 proc Edif_Religiosa_polygon_02ece63d_469a_493c_80f3_1629478a34c8106_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Religiosa_polygon_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Religiosa_polygon___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Religiosa_polygon_02ece63d_469a_493c_80f3_1629478a34c8106_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Religiosa_polygon_02ece63d_469a_493c_80f3_1629478a34c8106_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Religiosa_polygon_02ece63d_469a_493c_80f3_1629478a34c8106_VIS_FEAT_TYPE Edif_Religiosa_polygon$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Religiosa_polygon_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Religiosa_polygon_02ece63d_469a_493c_80f3_1629478a34c8106_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,religiao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,fkComplOrgRel,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,tipoEdifRelig,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,ensino,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Religiosa_polygon Output Nuker"   INPUT FEATURE_TYPE Edif_Religiosa_polygon

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Trecho_Drenagem} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Trecho_Drenagem_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Drenagem_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Trecho_Drenagem_FeatureDirector    INPUT  FEATURE_TYPE Trecho_Drenagem    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Trecho_Drenagem___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Trecho_Drenagem___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Trecho_Drenagem___FeatureDirector1    INPUT FEATURE_TYPE Trecho_Drenagem___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Trecho_Drenagem___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Trecho_Drenagem___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Drenagem_VectorSetterUpper    INPUT FEATURE_TYPE Trecho_Drenagem___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Trecho_Drenagem_02ece63d_469a_493c_80f3_1629478a34c8107_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Drenagem___PointCloudThinner    INPUT FEATURE_TYPE Trecho_Drenagem___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trecho_Drenagem_02ece63d_469a_493c_80f3_1629478a34c8107_thinPointCloud")
Tcl2 proc Trecho_Drenagem_02ece63d_469a_493c_80f3_1629478a34c8107_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Drenagem_RasterSetterUpper    INPUT FEATURE_TYPE Trecho_Drenagem___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trecho_Drenagem_02ece63d_469a_493c_80f3_1629478a34c8107_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Trecho_Drenagem_02ece63d_469a_493c_80f3_1629478a34c8107_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Trecho_Drenagem_02ece63d_469a_493c_80f3_1629478a34c8107_VIS_FEAT_TYPE Trecho_Drenagem$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Trecho_Drenagem_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Trecho_Drenagem_02ece63d_469a_493c_80f3_1629478a34c8107_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,dentroDePoligono,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,caladoMax,varchar<openparen>255<closeparen>,navegabilidade,varchar<openparen>255<closeparen>,fkComplTrCurDagua,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,compartilhado,varchar<openparen>255<closeparen>,larguraMedia,varchar<openparen>255<closeparen>,velocidadeMedCorrente,varchar<openparen>255<closeparen>,regime,varchar<openparen>255<closeparen>,profundidadeMedia,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,coincideComDentroDe,varchar<openparen>255<closeparen>,eixoPrincipal,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Trecho_Drenagem Output Nuker"   INPUT FEATURE_TYPE Trecho_Drenagem

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Ext_Mineral_polygon_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Ext_Mineral_polygon_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ext_Mineral_polygon_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Ext_Mineral_polygon_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Ext_Mineral_polygon_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Ext_Mineral_polygon_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Ext_Mineral_polygon_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Ext_Mineral_polygon_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Ext_Mineral_polygon_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Ext_Mineral_polygon_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Ext_Mineral_polygon_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ext_Mineral_polygon_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Ext_Mineral_polygon_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Ext_Mineral_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8108_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ext_Mineral_polygon_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Ext_Mineral_polygon_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Ext_Mineral_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8108_thinPointCloud")
Tcl2 proc Edif_Ext_Mineral_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8108_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ext_Mineral_polygon_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Ext_Mineral_polygon_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Ext_Mineral_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8108_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Ext_Mineral_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8108_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Ext_Mineral_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8108_VIS_FEAT_TYPE Edif_Ext_Mineral_polygon_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Ext_Mineral_polygon_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Ext_Mineral_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8108_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Ext_Mineral_polygon_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Ext_Mineral_polygon_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Posto_Combustivel_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Posto_Combustivel_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Posto_Combustivel_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Posto_Combustivel_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Posto_Combustivel_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Posto_Combustivel_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Posto_Combustivel_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Posto_Combustivel_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Posto_Combustivel_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Posto_Combustivel_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Posto_Combustivel_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Posto_Combustivel_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Posto_Combustivel_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Posto_Combustivel_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8109_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Posto_Combustivel_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Posto_Combustivel_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Posto_Combustivel_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8109_thinPointCloud")
Tcl2 proc Posto_Combustivel_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8109_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Posto_Combustivel_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Posto_Combustivel_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Posto_Combustivel_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8109_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Posto_Combustivel_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8109_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Posto_Combustivel_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8109_VIS_FEAT_TYPE Posto_Combustivel_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Posto_Combustivel_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Posto_Combustivel_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8109_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Posto_Combustivel_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Posto_Combustivel_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Selections} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Selections_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Selections_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Selections_FeatureDirector    INPUT  FEATURE_TYPE Selections    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Selections___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Selections___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Selections___FeatureDirector1    INPUT FEATURE_TYPE Selections___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Selections___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Selections___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Selections_VectorSetterUpper    INPUT FEATURE_TYPE Selections___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Selections_02ece63d_469a_493c_80f3_1629478a34c8110_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Selections___PointCloudThinner    INPUT FEATURE_TYPE Selections___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Selections_02ece63d_469a_493c_80f3_1629478a34c8110_thinPointCloud")
Tcl2 proc Selections_02ece63d_469a_493c_80f3_1629478a34c8110_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Selections_RasterSetterUpper    INPUT FEATURE_TYPE Selections___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Selections_02ece63d_469a_493c_80f3_1629478a34c8110_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Selections_02ece63d_469a_493c_80f3_1629478a34c8110_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Selections_02ece63d_469a_493c_80f3_1629478a34c8110_VIS_FEAT_TYPE Selections$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Selections_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Selections_02ece63d_469a_493c_80f3_1629478a34c8110_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA SelectionID,varchar<openparen>255<closeparen>,TargetName,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Selections Output Nuker"   INPUT FEATURE_TYPE Selections

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Ponto_Drenagem_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Ponto_Drenagem_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Drenagem_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Drenagem_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Ponto_Drenagem_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Ponto_Drenagem_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Drenagem_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Drenagem_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Ponto_Drenagem_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Ponto_Drenagem_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Drenagem_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Drenagem_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Ponto_Drenagem_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Ponto_Drenagem_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8111_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Drenagem_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Ponto_Drenagem_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Drenagem_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8111_thinPointCloud")
Tcl2 proc Ponto_Drenagem_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8111_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Drenagem_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Ponto_Drenagem_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Drenagem_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8111_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Ponto_Drenagem_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8111_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Ponto_Drenagem_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8111_VIS_FEAT_TYPE Ponto_Drenagem_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Ponto_Drenagem_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Ponto_Drenagem_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8111_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Ponto_Drenagem_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Ponto_Drenagem_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Est_Gerad_Energia_Eletr_polygon_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Est_Gerad_Energia_Eletr_polygon_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Est_Gerad_Energia_Eletr_polygon_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Est_Gerad_Energia_Eletr_polygon_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Est_Gerad_Energia_Eletr_polygon_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Est_Gerad_Energia_Eletr_polygon_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Est_Gerad_Energia_Eletr_polygon_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Est_Gerad_Energia_Eletr_polygon_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Est_Gerad_Energia_Eletr_polygon_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Est_Gerad_Energia_Eletr_polygon_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Est_Gerad_Energia_Eletr_polygon_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Est_Gerad_Energia_Eletr_polygon_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Est_Gerad_Energia_Eletr_polygon_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Est_Gerad_Energia_Eletr_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8112_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Est_Gerad_Energia_Eletr_polygon_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Est_Gerad_Energia_Eletr_polygon_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Est_Gerad_Energia_Eletr_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8112_thinPointCloud")
Tcl2 proc Est_Gerad_Energia_Eletr_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8112_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Est_Gerad_Energia_Eletr_polygon_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Est_Gerad_Energia_Eletr_polygon_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Est_Gerad_Energia_Eletr_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8112_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Est_Gerad_Energia_Eletr_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8112_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Est_Gerad_Energia_Eletr_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8112_VIS_FEAT_TYPE Est_Gerad_Energia_Eletr_polygon_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Est_Gerad_Energia_Eletr_polygon_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Est_Gerad_Energia_Eletr_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8112_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Est_Gerad_Energia_Eletr_polygon_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Est_Gerad_Energia_Eletr_polygon_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Pista_Ponto_Pouso_polygon_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Pista_Ponto_Pouso_polygon_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Pista_Ponto_Pouso_polygon_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Pista_Ponto_Pouso_polygon_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Pista_Ponto_Pouso_polygon_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Pista_Ponto_Pouso_polygon_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Pista_Ponto_Pouso_polygon_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Pista_Ponto_Pouso_polygon_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Pista_Ponto_Pouso_polygon_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Pista_Ponto_Pouso_polygon_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Pista_Ponto_Pouso_polygon_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Pista_Ponto_Pouso_polygon_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Pista_Ponto_Pouso_polygon_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Pista_Ponto_Pouso_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8113_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Pista_Ponto_Pouso_polygon_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Pista_Ponto_Pouso_polygon_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Pista_Ponto_Pouso_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8113_thinPointCloud")
Tcl2 proc Pista_Ponto_Pouso_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8113_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Pista_Ponto_Pouso_polygon_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Pista_Ponto_Pouso_polygon_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Pista_Ponto_Pouso_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8113_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Pista_Ponto_Pouso_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8113_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Pista_Ponto_Pouso_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8113_VIS_FEAT_TYPE Pista_Ponto_Pouso_polygon_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Pista_Ponto_Pouso_polygon_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Pista_Ponto_Pouso_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8113_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Pista_Ponto_Pouso_polygon_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Pista_Ponto_Pouso_polygon_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Servico_Social_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Servico_Social_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Servico_Social_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Servico_Social_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Servico_Social_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Servico_Social_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Servico_Social_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Servico_Social_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Servico_Social_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Servico_Social_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Servico_Social_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Servico_Social_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Servico_Social_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Servico_Social_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8114_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Servico_Social_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Servico_Social_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Servico_Social_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8114_thinPointCloud")
Tcl2 proc Edif_Servico_Social_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8114_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Servico_Social_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Servico_Social_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Servico_Social_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8114_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Servico_Social_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8114_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Servico_Social_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8114_VIS_FEAT_TYPE Edif_Servico_Social_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Servico_Social_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Servico_Social_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8114_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Servico_Social_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Servico_Social_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Pista_Competicao_line_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Pista_Competicao_line_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Pista_Competicao_line_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Pista_Competicao_line_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Pista_Competicao_line_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Pista_Competicao_line_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Pista_Competicao_line_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Pista_Competicao_line_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Pista_Competicao_line_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Pista_Competicao_line_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Pista_Competicao_line_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Pista_Competicao_line_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Pista_Competicao_line_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Pista_Competicao_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8115_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Pista_Competicao_line_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Pista_Competicao_line_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Pista_Competicao_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8115_thinPointCloud")
Tcl2 proc Pista_Competicao_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8115_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Pista_Competicao_line_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Pista_Competicao_line_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Pista_Competicao_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8115_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Pista_Competicao_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8115_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Pista_Competicao_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8115_VIS_FEAT_TYPE Pista_Competicao_line_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Pista_Competicao_line_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Pista_Competicao_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8115_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Pista_Competicao_line_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Pista_Competicao_line_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Rodoviaria_polygon_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Rodoviaria_polygon_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Rodoviaria_polygon_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Rodoviaria_polygon_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Rodoviaria_polygon_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Rodoviaria_polygon_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Rodoviaria_polygon_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Rodoviaria_polygon_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Rodoviaria_polygon_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Rodoviaria_polygon_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Rodoviaria_polygon_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Rodoviaria_polygon_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Rodoviaria_polygon_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Rodoviaria_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8116_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Rodoviaria_polygon_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Rodoviaria_polygon_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Rodoviaria_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8116_thinPointCloud")
Tcl2 proc Edif_Rodoviaria_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8116_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Rodoviaria_polygon_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Rodoviaria_polygon_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Rodoviaria_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8116_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Rodoviaria_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8116_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Rodoviaria_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8116_VIS_FEAT_TYPE Edif_Rodoviaria_polygon_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Rodoviaria_polygon_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Rodoviaria_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8116_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Rodoviaria_polygon_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Rodoviaria_polygon_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Pista_Ponto_Pouso_polygon} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Pista_Ponto_Pouso_polygon_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Pista_Ponto_Pouso_polygon_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Pista_Ponto_Pouso_polygon_FeatureDirector    INPUT  FEATURE_TYPE Pista_Ponto_Pouso_polygon    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Pista_Ponto_Pouso_polygon___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Pista_Ponto_Pouso_polygon___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Pista_Ponto_Pouso_polygon___FeatureDirector1    INPUT FEATURE_TYPE Pista_Ponto_Pouso_polygon___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Pista_Ponto_Pouso_polygon___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Pista_Ponto_Pouso_polygon___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Pista_Ponto_Pouso_polygon_VectorSetterUpper    INPUT FEATURE_TYPE Pista_Ponto_Pouso_polygon___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Pista_Ponto_Pouso_polygon_02ece63d_469a_493c_80f3_1629478a34c8117_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Pista_Ponto_Pouso_polygon___PointCloudThinner    INPUT FEATURE_TYPE Pista_Ponto_Pouso_polygon___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Pista_Ponto_Pouso_polygon_02ece63d_469a_493c_80f3_1629478a34c8117_thinPointCloud")
Tcl2 proc Pista_Ponto_Pouso_polygon_02ece63d_469a_493c_80f3_1629478a34c8117_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Pista_Ponto_Pouso_polygon_RasterSetterUpper    INPUT FEATURE_TYPE Pista_Ponto_Pouso_polygon___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Pista_Ponto_Pouso_polygon_02ece63d_469a_493c_80f3_1629478a34c8117_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Pista_Ponto_Pouso_polygon_02ece63d_469a_493c_80f3_1629478a34c8117_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Pista_Ponto_Pouso_polygon_02ece63d_469a_493c_80f3_1629478a34c8117_VIS_FEAT_TYPE Pista_Ponto_Pouso_polygon$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Pista_Ponto_Pouso_polygon_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Pista_Ponto_Pouso_polygon_02ece63d_469a_493c_80f3_1629478a34c8117_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,revestimento,varchar<openparen>255<closeparen>,homologacao,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,tipoPista,varchar<openparen>255<closeparen>,fkComplAeroport,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,largura,varchar<openparen>255<closeparen>,usoPista,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,extensao,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Pista_Ponto_Pouso_polygon Output Nuker"   INPUT FEATURE_TYPE Pista_Ponto_Pouso_polygon

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Area_Edificada} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Area_Edificada_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Edificada_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Area_Edificada_FeatureDirector    INPUT  FEATURE_TYPE Area_Edificada    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Area_Edificada___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Edificada___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Area_Edificada___FeatureDirector1    INPUT FEATURE_TYPE Area_Edificada___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Area_Edificada___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Edificada___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Edificada_VectorSetterUpper    INPUT FEATURE_TYPE Area_Edificada___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Area_Edificada_02ece63d_469a_493c_80f3_1629478a34c8118_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Edificada___PointCloudThinner    INPUT FEATURE_TYPE Area_Edificada___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Edificada_02ece63d_469a_493c_80f3_1629478a34c8118_thinPointCloud")
Tcl2 proc Area_Edificada_02ece63d_469a_493c_80f3_1629478a34c8118_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Edificada_RasterSetterUpper    INPUT FEATURE_TYPE Area_Edificada___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Edificada_02ece63d_469a_493c_80f3_1629478a34c8118_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Area_Edificada_02ece63d_469a_493c_80f3_1629478a34c8118_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Area_Edificada_02ece63d_469a_493c_80f3_1629478a34c8118_VIS_FEAT_TYPE Area_Edificada$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Area_Edificada_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Area_Edificada_02ece63d_469a_493c_80f3_1629478a34c8118_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,tamanhoTxt,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Area_Edificada Output Nuker"   INPUT FEATURE_TYPE Area_Edificada

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Habitacional_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Habitacional_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Habitacional_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Habitacional_point_FeatureDirector    INPUT  FEATURE_TYPE Edif_Habitacional_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Habitacional_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Habitacional_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Habitacional_point___FeatureDirector1    INPUT FEATURE_TYPE Edif_Habitacional_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Habitacional_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Habitacional_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Habitacional_point_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Habitacional_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Habitacional_point_02ece63d_469a_493c_80f3_1629478a34c8119_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Habitacional_point___PointCloudThinner    INPUT FEATURE_TYPE Edif_Habitacional_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Habitacional_point_02ece63d_469a_493c_80f3_1629478a34c8119_thinPointCloud")
Tcl2 proc Edif_Habitacional_point_02ece63d_469a_493c_80f3_1629478a34c8119_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Habitacional_point_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Habitacional_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Habitacional_point_02ece63d_469a_493c_80f3_1629478a34c8119_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Habitacional_point_02ece63d_469a_493c_80f3_1629478a34c8119_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Habitacional_point_02ece63d_469a_493c_80f3_1629478a34c8119_VIS_FEAT_TYPE Edif_Habitacional_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Habitacional_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Habitacional_point_02ece63d_469a_493c_80f3_1629478a34c8119_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,fkComplHabit,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Habitacional_point Output Nuker"   INPUT FEATURE_TYPE Edif_Habitacional_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {GDB_ColumnInfo} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME GDB_ColumnInfo_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_ColumnInfo_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME GDB_ColumnInfo_FeatureDirector    INPUT  FEATURE_TYPE GDB_ColumnInfo    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE GDB_ColumnInfo___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE GDB_ColumnInfo___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME GDB_ColumnInfo___FeatureDirector1    INPUT FEATURE_TYPE GDB_ColumnInfo___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE GDB_ColumnInfo___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE GDB_ColumnInfo___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_ColumnInfo_VectorSetterUpper    INPUT FEATURE_TYPE GDB_ColumnInfo___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc GDB_ColumnInfo_02ece63d_469a_493c_80f3_1629478a34c8120_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_ColumnInfo___PointCloudThinner    INPUT FEATURE_TYPE GDB_ColumnInfo___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("GDB_ColumnInfo_02ece63d_469a_493c_80f3_1629478a34c8120_thinPointCloud")
Tcl2 proc GDB_ColumnInfo_02ece63d_469a_493c_80f3_1629478a34c8120_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_ColumnInfo_RasterSetterUpper    INPUT FEATURE_TYPE GDB_ColumnInfo___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("GDB_ColumnInfo_02ece63d_469a_493c_80f3_1629478a34c8120_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# GDB_ColumnInfo_02ece63d_469a_493c_80f3_1629478a34c8120_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO GDB_ColumnInfo_02ece63d_469a_493c_80f3_1629478a34c8120_VIS_FEAT_TYPE GDB_ColumnInfo$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME GDB_ColumnInfo_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(GDB_ColumnInfo_02ece63d_469a_493c_80f3_1629478a34c8120_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA TableName,varchar<openparen>255<closeparen>,FieldName,varchar<openparen>255<closeparen>,columnFlags,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "GDB_ColumnInfo Output Nuker"   INPUT FEATURE_TYPE GDB_ColumnInfo

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Terreno_Suj_Inundacao} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Terreno_Suj_Inundacao_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Terreno_Suj_Inundacao_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Terreno_Suj_Inundacao_FeatureDirector    INPUT  FEATURE_TYPE Terreno_Suj_Inundacao    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Terreno_Suj_Inundacao___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Terreno_Suj_Inundacao___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Terreno_Suj_Inundacao___FeatureDirector1    INPUT FEATURE_TYPE Terreno_Suj_Inundacao___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Terreno_Suj_Inundacao___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Terreno_Suj_Inundacao___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Terreno_Suj_Inundacao_VectorSetterUpper    INPUT FEATURE_TYPE Terreno_Suj_Inundacao___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Terreno_Suj_Inundacao_02ece63d_469a_493c_80f3_1629478a34c8121_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Terreno_Suj_Inundacao___PointCloudThinner    INPUT FEATURE_TYPE Terreno_Suj_Inundacao___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Terreno_Suj_Inundacao_02ece63d_469a_493c_80f3_1629478a34c8121_thinPointCloud")
Tcl2 proc Terreno_Suj_Inundacao_02ece63d_469a_493c_80f3_1629478a34c8121_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Terreno_Suj_Inundacao_RasterSetterUpper    INPUT FEATURE_TYPE Terreno_Suj_Inundacao___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Terreno_Suj_Inundacao_02ece63d_469a_493c_80f3_1629478a34c8121_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Terreno_Suj_Inundacao_02ece63d_469a_493c_80f3_1629478a34c8121_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Terreno_Suj_Inundacao_02ece63d_469a_493c_80f3_1629478a34c8121_VIS_FEAT_TYPE Terreno_Suj_Inundacao$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Terreno_Suj_Inundacao_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Terreno_Suj_Inundacao_02ece63d_469a_493c_80f3_1629478a34c8121_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,periodicidadeInunda,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Terreno_Suj_Inundacao Output Nuker"   INPUT FEATURE_TYPE Terreno_Suj_Inundacao

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Cemiterio_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Cemiterio_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Cemiterio_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Cemiterio_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Cemiterio_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Cemiterio_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Cemiterio_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Cemiterio_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Cemiterio_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Cemiterio_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Cemiterio_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Cemiterio_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Cemiterio_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Cemiterio_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8122_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Cemiterio_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Cemiterio_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Cemiterio_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8122_thinPointCloud")
Tcl2 proc Cemiterio_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8122_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Cemiterio_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Cemiterio_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Cemiterio_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8122_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Cemiterio_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8122_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Cemiterio_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8122_VIS_FEAT_TYPE Cemiterio_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Cemiterio_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Cemiterio_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8122_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Cemiterio_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Cemiterio_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Ponto_Trecho_Energia_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Ponto_Trecho_Energia_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Trecho_Energia_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Trecho_Energia_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Ponto_Trecho_Energia_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Ponto_Trecho_Energia_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Trecho_Energia_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Trecho_Energia_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Ponto_Trecho_Energia_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Ponto_Trecho_Energia_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Trecho_Energia_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Trecho_Energia_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Ponto_Trecho_Energia_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Ponto_Trecho_Energia_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8123_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Trecho_Energia_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Ponto_Trecho_Energia_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Trecho_Energia_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8123_thinPointCloud")
Tcl2 proc Ponto_Trecho_Energia_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8123_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Trecho_Energia_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Ponto_Trecho_Energia_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Trecho_Energia_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8123_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Ponto_Trecho_Energia_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8123_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Ponto_Trecho_Energia_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8123_VIS_FEAT_TYPE Ponto_Trecho_Energia_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Ponto_Trecho_Energia_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Ponto_Trecho_Energia_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8123_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Ponto_Trecho_Energia_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Ponto_Trecho_Energia_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Rodoviaria_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Rodoviaria_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Rodoviaria_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Rodoviaria_point_FeatureDirector    INPUT  FEATURE_TYPE Edif_Rodoviaria_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Rodoviaria_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Rodoviaria_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Rodoviaria_point___FeatureDirector1    INPUT FEATURE_TYPE Edif_Rodoviaria_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Rodoviaria_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Rodoviaria_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Rodoviaria_point_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Rodoviaria_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Rodoviaria_point_02ece63d_469a_493c_80f3_1629478a34c8124_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Rodoviaria_point___PointCloudThinner    INPUT FEATURE_TYPE Edif_Rodoviaria_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Rodoviaria_point_02ece63d_469a_493c_80f3_1629478a34c8124_thinPointCloud")
Tcl2 proc Edif_Rodoviaria_point_02ece63d_469a_493c_80f3_1629478a34c8124_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Rodoviaria_point_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Rodoviaria_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Rodoviaria_point_02ece63d_469a_493c_80f3_1629478a34c8124_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Rodoviaria_point_02ece63d_469a_493c_80f3_1629478a34c8124_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Rodoviaria_point_02ece63d_469a_493c_80f3_1629478a34c8124_VIS_FEAT_TYPE Edif_Rodoviaria_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Rodoviaria_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Rodoviaria_point_02ece63d_469a_493c_80f3_1629478a34c8124_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,tipoEdifRod,varchar<openparen>255<closeparen>,administracao,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,fkComplEstrApoio,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Rodoviaria_point Output Nuker"   INPUT FEATURE_TYPE Edif_Rodoviaria_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Trecho_Rodoviario_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Trecho_Rodoviario_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Rodoviario_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Trecho_Rodoviario_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Trecho_Rodoviario_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Trecho_Rodoviario_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Trecho_Rodoviario_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Trecho_Rodoviario_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Trecho_Rodoviario_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Trecho_Rodoviario_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Trecho_Rodoviario_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Rodoviario_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Trecho_Rodoviario_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Trecho_Rodoviario_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8125_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Rodoviario_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Trecho_Rodoviario_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trecho_Rodoviario_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8125_thinPointCloud")
Tcl2 proc Trecho_Rodoviario_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8125_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Rodoviario_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Trecho_Rodoviario_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trecho_Rodoviario_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8125_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Trecho_Rodoviario_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8125_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Trecho_Rodoviario_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8125_VIS_FEAT_TYPE Trecho_Rodoviario_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Trecho_Rodoviario_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Trecho_Rodoviario_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8125_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Trecho_Rodoviario_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Trecho_Rodoviario_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Habitacional_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Habitacional_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Habitacional_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Habitacional_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Habitacional_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Habitacional_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Habitacional_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Habitacional_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Habitacional_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Habitacional_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Habitacional_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Habitacional_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Habitacional_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Habitacional_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8126_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Habitacional_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Habitacional_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Habitacional_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8126_thinPointCloud")
Tcl2 proc Edif_Habitacional_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8126_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Habitacional_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Habitacional_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Habitacional_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8126_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Habitacional_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8126_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Habitacional_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8126_VIS_FEAT_TYPE Edif_Habitacional_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Habitacional_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Habitacional_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8126_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Habitacional_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Habitacional_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Sumidouro_Vertedouro_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Sumidouro_Vertedouro_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Sumidouro_Vertedouro_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Sumidouro_Vertedouro_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Sumidouro_Vertedouro_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Sumidouro_Vertedouro_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Sumidouro_Vertedouro_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Sumidouro_Vertedouro_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Sumidouro_Vertedouro_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Sumidouro_Vertedouro_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Sumidouro_Vertedouro_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Sumidouro_Vertedouro_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Sumidouro_Vertedouro_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Sumidouro_Vertedouro_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8127_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Sumidouro_Vertedouro_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Sumidouro_Vertedouro_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Sumidouro_Vertedouro_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8127_thinPointCloud")
Tcl2 proc Sumidouro_Vertedouro_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8127_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Sumidouro_Vertedouro_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Sumidouro_Vertedouro_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Sumidouro_Vertedouro_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8127_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Sumidouro_Vertedouro_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8127_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Sumidouro_Vertedouro_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8127_VIS_FEAT_TYPE Sumidouro_Vertedouro_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Sumidouro_Vertedouro_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Sumidouro_Vertedouro_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8127_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Sumidouro_Vertedouro_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Sumidouro_Vertedouro_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Industrial_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Industrial_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Industrial_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Industrial_point_FeatureDirector    INPUT  FEATURE_TYPE Edif_Industrial_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Industrial_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Industrial_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Industrial_point___FeatureDirector1    INPUT FEATURE_TYPE Edif_Industrial_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Industrial_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Industrial_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Industrial_point_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Industrial_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Industrial_point_02ece63d_469a_493c_80f3_1629478a34c8128_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Industrial_point___PointCloudThinner    INPUT FEATURE_TYPE Edif_Industrial_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Industrial_point_02ece63d_469a_493c_80f3_1629478a34c8128_thinPointCloud")
Tcl2 proc Edif_Industrial_point_02ece63d_469a_493c_80f3_1629478a34c8128_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Industrial_point_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Industrial_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Industrial_point_02ece63d_469a_493c_80f3_1629478a34c8128_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Industrial_point_02ece63d_469a_493c_80f3_1629478a34c8128_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Industrial_point_02ece63d_469a_493c_80f3_1629478a34c8128_VIS_FEAT_TYPE Edif_Industrial_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Industrial_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Industrial_point_02ece63d_469a_493c_80f3_1629478a34c8128_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,fkComplIndustria,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,chamine,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,tipoDivisaoCnae,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Industrial_point Output Nuker"   INPUT FEATURE_TYPE Edif_Industrial_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Est_Gerad_Energia_Eletr_polygon} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Est_Gerad_Energia_Eletr_polygon_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Est_Gerad_Energia_Eletr_polygon_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Est_Gerad_Energia_Eletr_polygon_FeatureDirector    INPUT  FEATURE_TYPE Est_Gerad_Energia_Eletr_polygon    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Est_Gerad_Energia_Eletr_polygon___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Est_Gerad_Energia_Eletr_polygon___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Est_Gerad_Energia_Eletr_polygon___FeatureDirector1    INPUT FEATURE_TYPE Est_Gerad_Energia_Eletr_polygon___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Est_Gerad_Energia_Eletr_polygon___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Est_Gerad_Energia_Eletr_polygon___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Est_Gerad_Energia_Eletr_polygon_VectorSetterUpper    INPUT FEATURE_TYPE Est_Gerad_Energia_Eletr_polygon___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Est_Gerad_Energia_Eletr_polygon_02ece63d_469a_493c_80f3_1629478a34c8129_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Est_Gerad_Energia_Eletr_polygon___PointCloudThinner    INPUT FEATURE_TYPE Est_Gerad_Energia_Eletr_polygon___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Est_Gerad_Energia_Eletr_polygon_02ece63d_469a_493c_80f3_1629478a34c8129_thinPointCloud")
Tcl2 proc Est_Gerad_Energia_Eletr_polygon_02ece63d_469a_493c_80f3_1629478a34c8129_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Est_Gerad_Energia_Eletr_polygon_RasterSetterUpper    INPUT FEATURE_TYPE Est_Gerad_Energia_Eletr_polygon___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Est_Gerad_Energia_Eletr_polygon_02ece63d_469a_493c_80f3_1629478a34c8129_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Est_Gerad_Energia_Eletr_polygon_02ece63d_469a_493c_80f3_1629478a34c8129_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Est_Gerad_Energia_Eletr_polygon_02ece63d_469a_493c_80f3_1629478a34c8129_VIS_FEAT_TYPE Est_Gerad_Energia_Eletr_polygon$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Est_Gerad_Energia_Eletr_polygon_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Est_Gerad_Energia_Eletr_polygon_02ece63d_469a_493c_80f3_1629478a34c8129_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,tipoEstGerad,varchar<openparen>255<closeparen>,potenciaFiscalizadaKW,varchar<openparen>255<closeparen>,fkComplGerEnEletr,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,codigoEstacao,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,destEnergElet,varchar<openparen>255<closeparen>,potenciaOutorgadaKW,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Est_Gerad_Energia_Eletr_polygon Output Nuker"   INPUT FEATURE_TYPE Est_Gerad_Energia_Eletr_polygon

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Ponto_Rodoviario_Ferrov_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Ponto_Rodoviario_Ferrov_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Rodoviario_Ferrov_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Rodoviario_Ferrov_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Ponto_Rodoviario_Ferrov_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Ponto_Rodoviario_Ferrov_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Rodoviario_Ferrov_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Rodoviario_Ferrov_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Ponto_Rodoviario_Ferrov_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Ponto_Rodoviario_Ferrov_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Rodoviario_Ferrov_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Rodoviario_Ferrov_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Ponto_Rodoviario_Ferrov_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Ponto_Rodoviario_Ferrov_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8130_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Rodoviario_Ferrov_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Ponto_Rodoviario_Ferrov_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Rodoviario_Ferrov_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8130_thinPointCloud")
Tcl2 proc Ponto_Rodoviario_Ferrov_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8130_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Rodoviario_Ferrov_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Ponto_Rodoviario_Ferrov_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Rodoviario_Ferrov_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8130_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Ponto_Rodoviario_Ferrov_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8130_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Ponto_Rodoviario_Ferrov_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8130_VIS_FEAT_TYPE Ponto_Rodoviario_Ferrov_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Ponto_Rodoviario_Ferrov_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Ponto_Rodoviario_Ferrov_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8130_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Ponto_Rodoviario_Ferrov_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Ponto_Rodoviario_Ferrov_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Banco_Areia_polygon_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Banco_Areia_polygon_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Banco_Areia_polygon_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Banco_Areia_polygon_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Banco_Areia_polygon_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Banco_Areia_polygon_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Banco_Areia_polygon_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Banco_Areia_polygon_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Banco_Areia_polygon_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Banco_Areia_polygon_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Banco_Areia_polygon_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Banco_Areia_polygon_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Banco_Areia_polygon_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Banco_Areia_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8131_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Banco_Areia_polygon_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Banco_Areia_polygon_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Banco_Areia_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8131_thinPointCloud")
Tcl2 proc Banco_Areia_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8131_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Banco_Areia_polygon_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Banco_Areia_polygon_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Banco_Areia_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8131_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Banco_Areia_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8131_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Banco_Areia_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8131_VIS_FEAT_TYPE Banco_Areia_polygon_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Banco_Areia_polygon_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Banco_Areia_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8131_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Banco_Areia_polygon_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Banco_Areia_polygon_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Servico_Social_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Servico_Social_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Servico_Social_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Servico_Social_point_FeatureDirector    INPUT  FEATURE_TYPE Edif_Servico_Social_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Servico_Social_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Servico_Social_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Servico_Social_point___FeatureDirector1    INPUT FEATURE_TYPE Edif_Servico_Social_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Servico_Social_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Servico_Social_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Servico_Social_point_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Servico_Social_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Servico_Social_point_02ece63d_469a_493c_80f3_1629478a34c8132_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Servico_Social_point___PointCloudThinner    INPUT FEATURE_TYPE Edif_Servico_Social_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Servico_Social_point_02ece63d_469a_493c_80f3_1629478a34c8132_thinPointCloud")
Tcl2 proc Edif_Servico_Social_point_02ece63d_469a_493c_80f3_1629478a34c8132_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Servico_Social_point_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Servico_Social_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Servico_Social_point_02ece63d_469a_493c_80f3_1629478a34c8132_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Servico_Social_point_02ece63d_469a_493c_80f3_1629478a34c8132_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Servico_Social_point_02ece63d_469a_493c_80f3_1629478a34c8132_VIS_FEAT_TYPE Edif_Servico_Social_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Servico_Social_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Servico_Social_point_02ece63d_469a_493c_80f3_1629478a34c8132_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,tipoClasseCnae,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,fkComplSvSoc,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Servico_Social_point Output Nuker"   INPUT FEATURE_TYPE Edif_Servico_Social_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Atracadouro_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Atracadouro_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Atracadouro_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Atracadouro_point_FeatureDirector    INPUT  FEATURE_TYPE Atracadouro_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Atracadouro_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Atracadouro_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Atracadouro_point___FeatureDirector1    INPUT FEATURE_TYPE Atracadouro_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Atracadouro_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Atracadouro_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Atracadouro_point_VectorSetterUpper    INPUT FEATURE_TYPE Atracadouro_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Atracadouro_point_02ece63d_469a_493c_80f3_1629478a34c8133_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Atracadouro_point___PointCloudThinner    INPUT FEATURE_TYPE Atracadouro_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Atracadouro_point_02ece63d_469a_493c_80f3_1629478a34c8133_thinPointCloud")
Tcl2 proc Atracadouro_point_02ece63d_469a_493c_80f3_1629478a34c8133_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Atracadouro_point_RasterSetterUpper    INPUT FEATURE_TYPE Atracadouro_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Atracadouro_point_02ece63d_469a_493c_80f3_1629478a34c8133_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Atracadouro_point_02ece63d_469a_493c_80f3_1629478a34c8133_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Atracadouro_point_02ece63d_469a_493c_80f3_1629478a34c8133_VIS_FEAT_TYPE Atracadouro_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Atracadouro_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Atracadouro_point_02ece63d_469a_493c_80f3_1629478a34c8133_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,fkComplPortuario,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,administracao,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,tipoAtracad,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Atracadouro_point Output Nuker"   INPUT FEATURE_TYPE Atracadouro_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Deposito_Geral_polygon_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Deposito_Geral_polygon_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Deposito_Geral_polygon_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Deposito_Geral_polygon_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Deposito_Geral_polygon_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Deposito_Geral_polygon_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Deposito_Geral_polygon_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Deposito_Geral_polygon_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Deposito_Geral_polygon_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Deposito_Geral_polygon_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Deposito_Geral_polygon_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Deposito_Geral_polygon_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Deposito_Geral_polygon_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Deposito_Geral_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8134_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Deposito_Geral_polygon_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Deposito_Geral_polygon_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Deposito_Geral_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8134_thinPointCloud")
Tcl2 proc Deposito_Geral_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8134_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Deposito_Geral_polygon_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Deposito_Geral_polygon_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Deposito_Geral_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8134_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Deposito_Geral_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8134_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Deposito_Geral_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8134_VIS_FEAT_TYPE Deposito_Geral_polygon_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Deposito_Geral_polygon_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Deposito_Geral_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8134_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Deposito_Geral_polygon_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Deposito_Geral_polygon_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Industrial_polygon_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Industrial_polygon_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Industrial_polygon_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Industrial_polygon_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Industrial_polygon_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Industrial_polygon_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Industrial_polygon_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Industrial_polygon_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Industrial_polygon_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Industrial_polygon_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Industrial_polygon_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Industrial_polygon_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Industrial_polygon_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Industrial_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8135_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Industrial_polygon_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Industrial_polygon_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Industrial_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8135_thinPointCloud")
Tcl2 proc Edif_Industrial_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8135_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Industrial_polygon_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Industrial_polygon_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Industrial_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8135_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Industrial_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8135_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Industrial_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8135_VIS_FEAT_TYPE Edif_Industrial_polygon_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Industrial_polygon_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Industrial_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8135_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Industrial_polygon_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Industrial_polygon_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Massa_Dagua} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Massa_Dagua_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Massa_Dagua_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Massa_Dagua_FeatureDirector    INPUT  FEATURE_TYPE Massa_Dagua    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Massa_Dagua___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Massa_Dagua___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Massa_Dagua___FeatureDirector1    INPUT FEATURE_TYPE Massa_Dagua___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Massa_Dagua___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Massa_Dagua___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Massa_Dagua_VectorSetterUpper    INPUT FEATURE_TYPE Massa_Dagua___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Massa_Dagua_02ece63d_469a_493c_80f3_1629478a34c8136_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Massa_Dagua___PointCloudThinner    INPUT FEATURE_TYPE Massa_Dagua___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Massa_Dagua_02ece63d_469a_493c_80f3_1629478a34c8136_thinPointCloud")
Tcl2 proc Massa_Dagua_02ece63d_469a_493c_80f3_1629478a34c8136_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Massa_Dagua_RasterSetterUpper    INPUT FEATURE_TYPE Massa_Dagua___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Massa_Dagua_02ece63d_469a_493c_80f3_1629478a34c8136_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Massa_Dagua_02ece63d_469a_493c_80f3_1629478a34c8136_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Massa_Dagua_02ece63d_469a_493c_80f3_1629478a34c8136_VIS_FEAT_TYPE Massa_Dagua$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Massa_Dagua_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Massa_Dagua_02ece63d_469a_493c_80f3_1629478a34c8136_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,salinidade,varchar<openparen>255<closeparen>,regime,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,tipoMassaDagua,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Massa_Dagua Output Nuker"   INPUT FEATURE_TYPE Massa_Dagua

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Const_Lazer_polygon_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Const_Lazer_polygon_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Lazer_polygon_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Const_Lazer_polygon_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Const_Lazer_polygon_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Const_Lazer_polygon_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Const_Lazer_polygon_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Const_Lazer_polygon_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Const_Lazer_polygon_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Const_Lazer_polygon_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Const_Lazer_polygon_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Lazer_polygon_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Const_Lazer_polygon_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Const_Lazer_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8137_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Lazer_polygon_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Const_Lazer_polygon_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Const_Lazer_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8137_thinPointCloud")
Tcl2 proc Edif_Const_Lazer_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8137_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Lazer_polygon_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Const_Lazer_polygon_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Const_Lazer_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8137_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Const_Lazer_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8137_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Const_Lazer_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8137_VIS_FEAT_TYPE Edif_Const_Lazer_polygon_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Const_Lazer_polygon_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Const_Lazer_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8137_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Const_Lazer_polygon_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Const_Lazer_polygon_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Identific_Trecho_Rod} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Identific_Trecho_Rod_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Identific_Trecho_Rod_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Identific_Trecho_Rod_FeatureDirector    INPUT  FEATURE_TYPE Identific_Trecho_Rod    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Identific_Trecho_Rod___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Identific_Trecho_Rod___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Identific_Trecho_Rod___FeatureDirector1    INPUT FEATURE_TYPE Identific_Trecho_Rod___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Identific_Trecho_Rod___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Identific_Trecho_Rod___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Identific_Trecho_Rod_VectorSetterUpper    INPUT FEATURE_TYPE Identific_Trecho_Rod___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Identific_Trecho_Rod_02ece63d_469a_493c_80f3_1629478a34c8138_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Identific_Trecho_Rod___PointCloudThinner    INPUT FEATURE_TYPE Identific_Trecho_Rod___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Identific_Trecho_Rod_02ece63d_469a_493c_80f3_1629478a34c8138_thinPointCloud")
Tcl2 proc Identific_Trecho_Rod_02ece63d_469a_493c_80f3_1629478a34c8138_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Identific_Trecho_Rod_RasterSetterUpper    INPUT FEATURE_TYPE Identific_Trecho_Rod___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Identific_Trecho_Rod_02ece63d_469a_493c_80f3_1629478a34c8138_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Identific_Trecho_Rod_02ece63d_469a_493c_80f3_1629478a34c8138_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Identific_Trecho_Rod_02ece63d_469a_493c_80f3_1629478a34c8138_VIS_FEAT_TYPE Identific_Trecho_Rod$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Identific_Trecho_Rod_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Identific_Trecho_Rod_02ece63d_469a_493c_80f3_1629478a34c8138_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,fkComplRodovia,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,simbolizar,varchar<openparen>255<closeparen>,offSet,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,sigla,varchar<openparen>255<closeparen>,repTipoTxt,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,codTrechoRodov,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Identific_Trecho_Rod Output Nuker"   INPUT FEATURE_TYPE Identific_Trecho_Rod

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Cerrado_Cerradao_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Cerrado_Cerradao_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Cerrado_Cerradao_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Cerrado_Cerradao_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Cerrado_Cerradao_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Cerrado_Cerradao_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Cerrado_Cerradao_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Cerrado_Cerradao_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Cerrado_Cerradao_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Cerrado_Cerradao_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Cerrado_Cerradao_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Cerrado_Cerradao_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Cerrado_Cerradao_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Cerrado_Cerradao_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8139_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Cerrado_Cerradao_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Cerrado_Cerradao_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Cerrado_Cerradao_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8139_thinPointCloud")
Tcl2 proc Cerrado_Cerradao_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8139_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Cerrado_Cerradao_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Cerrado_Cerradao_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Cerrado_Cerradao_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8139_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Cerrado_Cerradao_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8139_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Cerrado_Cerradao_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8139_VIS_FEAT_TYPE Cerrado_Cerradao_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Cerrado_Cerradao_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Cerrado_Cerradao_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8139_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Cerrado_Cerradao_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Cerrado_Cerradao_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Nome_Local} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Nome_Local_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Nome_Local_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Nome_Local_FeatureDirector    INPUT  FEATURE_TYPE Nome_Local    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Nome_Local___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Nome_Local___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Nome_Local___FeatureDirector1    INPUT FEATURE_TYPE Nome_Local___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Nome_Local___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Nome_Local___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Nome_Local_VectorSetterUpper    INPUT FEATURE_TYPE Nome_Local___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Nome_Local_02ece63d_469a_493c_80f3_1629478a34c8140_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Nome_Local___PointCloudThinner    INPUT FEATURE_TYPE Nome_Local___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Nome_Local_02ece63d_469a_493c_80f3_1629478a34c8140_thinPointCloud")
Tcl2 proc Nome_Local_02ece63d_469a_493c_80f3_1629478a34c8140_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Nome_Local_RasterSetterUpper    INPUT FEATURE_TYPE Nome_Local___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Nome_Local_02ece63d_469a_493c_80f3_1629478a34c8140_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Nome_Local_02ece63d_469a_493c_80f3_1629478a34c8140_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Nome_Local_02ece63d_469a_493c_80f3_1629478a34c8140_VIS_FEAT_TYPE Nome_Local$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Nome_Local_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Nome_Local_02ece63d_469a_493c_80f3_1629478a34c8140_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,tamanhoTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Nome_Local Output Nuker"   INPUT FEATURE_TYPE Nome_Local

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Campo} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Campo_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Campo_FeatureDirector    INPUT  FEATURE_TYPE Campo    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Campo___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Campo___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Campo___FeatureDirector1    INPUT FEATURE_TYPE Campo___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Campo___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Campo___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_VectorSetterUpper    INPUT FEATURE_TYPE Campo___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Campo_02ece63d_469a_493c_80f3_1629478a34c8141_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Campo___PointCloudThinner    INPUT FEATURE_TYPE Campo___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Campo_02ece63d_469a_493c_80f3_1629478a34c8141_thinPointCloud")
Tcl2 proc Campo_02ece63d_469a_493c_80f3_1629478a34c8141_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_RasterSetterUpper    INPUT FEATURE_TYPE Campo___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Campo_02ece63d_469a_493c_80f3_1629478a34c8141_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Campo_02ece63d_469a_493c_80f3_1629478a34c8141_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Campo_02ece63d_469a_493c_80f3_1629478a34c8141_VIS_FEAT_TYPE Campo$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Campo_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Campo_02ece63d_469a_493c_80f3_1629478a34c8141_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,ocorrenciaEm,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,tipoCampo,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Campo Output Nuker"   INPUT FEATURE_TYPE Campo

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Rodoviaria_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Rodoviaria_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Rodoviaria_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Rodoviaria_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Rodoviaria_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Rodoviaria_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Rodoviaria_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Rodoviaria_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Rodoviaria_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Rodoviaria_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Rodoviaria_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Rodoviaria_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Rodoviaria_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Rodoviaria_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8142_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Rodoviaria_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Rodoviaria_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Rodoviaria_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8142_thinPointCloud")
Tcl2 proc Edif_Rodoviaria_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8142_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Rodoviaria_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Rodoviaria_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Rodoviaria_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8142_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Rodoviaria_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8142_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Rodoviaria_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8142_VIS_FEAT_TYPE Edif_Rodoviaria_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Rodoviaria_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Rodoviaria_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8142_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Rodoviaria_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Rodoviaria_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Cemiterio_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Cemiterio_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Cemiterio_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Cemiterio_point_FeatureDirector    INPUT  FEATURE_TYPE Cemiterio_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Cemiterio_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Cemiterio_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Cemiterio_point___FeatureDirector1    INPUT FEATURE_TYPE Cemiterio_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Cemiterio_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Cemiterio_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Cemiterio_point_VectorSetterUpper    INPUT FEATURE_TYPE Cemiterio_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Cemiterio_point_02ece63d_469a_493c_80f3_1629478a34c8143_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Cemiterio_point___PointCloudThinner    INPUT FEATURE_TYPE Cemiterio_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Cemiterio_point_02ece63d_469a_493c_80f3_1629478a34c8143_thinPointCloud")
Tcl2 proc Cemiterio_point_02ece63d_469a_493c_80f3_1629478a34c8143_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Cemiterio_point_RasterSetterUpper    INPUT FEATURE_TYPE Cemiterio_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Cemiterio_point_02ece63d_469a_493c_80f3_1629478a34c8143_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Cemiterio_point_02ece63d_469a_493c_80f3_1629478a34c8143_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Cemiterio_point_02ece63d_469a_493c_80f3_1629478a34c8143_VIS_FEAT_TYPE Cemiterio_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Cemiterio_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Cemiterio_point_02ece63d_469a_493c_80f3_1629478a34c8143_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,denominacaoAssociada,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,tipoCemiterio,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Cemiterio_point Output Nuker"   INPUT FEATURE_TYPE Cemiterio_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Identific_Trecho_Rod_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Identific_Trecho_Rod_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Identific_Trecho_Rod_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Identific_Trecho_Rod_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Identific_Trecho_Rod_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Identific_Trecho_Rod_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Identific_Trecho_Rod_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Identific_Trecho_Rod_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Identific_Trecho_Rod_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Identific_Trecho_Rod_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Identific_Trecho_Rod_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Identific_Trecho_Rod_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Identific_Trecho_Rod_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Identific_Trecho_Rod_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8144_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Identific_Trecho_Rod_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Identific_Trecho_Rod_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Identific_Trecho_Rod_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8144_thinPointCloud")
Tcl2 proc Identific_Trecho_Rod_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8144_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Identific_Trecho_Rod_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Identific_Trecho_Rod_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Identific_Trecho_Rod_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8144_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Identific_Trecho_Rod_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8144_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Identific_Trecho_Rod_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8144_VIS_FEAT_TYPE Identific_Trecho_Rod_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Identific_Trecho_Rod_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Identific_Trecho_Rod_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8144_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Identific_Trecho_Rod_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Identific_Trecho_Rod_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Const_Lazer_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Const_Lazer_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Lazer_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Const_Lazer_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Const_Lazer_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Const_Lazer_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Const_Lazer_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Const_Lazer_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Const_Lazer_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Const_Lazer_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Const_Lazer_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Lazer_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Const_Lazer_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Const_Lazer_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8145_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Lazer_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Const_Lazer_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Const_Lazer_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8145_thinPointCloud")
Tcl2 proc Edif_Const_Lazer_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8145_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Lazer_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Const_Lazer_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Const_Lazer_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8145_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Const_Lazer_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8145_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Const_Lazer_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8145_VIS_FEAT_TYPE Edif_Const_Lazer_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Const_Lazer_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Const_Lazer_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8145_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Const_Lazer_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Const_Lazer_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Ponto_Drenagem} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Ponto_Drenagem_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Drenagem_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Drenagem_FeatureDirector    INPUT  FEATURE_TYPE Ponto_Drenagem    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Ponto_Drenagem___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Drenagem___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Drenagem___FeatureDirector1    INPUT FEATURE_TYPE Ponto_Drenagem___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Ponto_Drenagem___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Drenagem___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Drenagem_VectorSetterUpper    INPUT FEATURE_TYPE Ponto_Drenagem___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Ponto_Drenagem_02ece63d_469a_493c_80f3_1629478a34c8146_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Drenagem___PointCloudThinner    INPUT FEATURE_TYPE Ponto_Drenagem___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Drenagem_02ece63d_469a_493c_80f3_1629478a34c8146_thinPointCloud")
Tcl2 proc Ponto_Drenagem_02ece63d_469a_493c_80f3_1629478a34c8146_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Drenagem_RasterSetterUpper    INPUT FEATURE_TYPE Ponto_Drenagem___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Drenagem_02ece63d_469a_493c_80f3_1629478a34c8146_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Ponto_Drenagem_02ece63d_469a_493c_80f3_1629478a34c8146_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Ponto_Drenagem_02ece63d_469a_493c_80f3_1629478a34c8146_VIS_FEAT_TYPE Ponto_Drenagem$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Ponto_Drenagem_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Ponto_Drenagem_02ece63d_469a_493c_80f3_1629478a34c8146_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,relacionado,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Ponto_Drenagem Output Nuker"   INPUT FEATURE_TYPE Ponto_Drenagem

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Curva_Nivel} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Curva_Nivel_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Curva_Nivel_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Curva_Nivel_FeatureDirector    INPUT  FEATURE_TYPE Curva_Nivel    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Curva_Nivel___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Curva_Nivel___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Curva_Nivel___FeatureDirector1    INPUT FEATURE_TYPE Curva_Nivel___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Curva_Nivel___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Curva_Nivel___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Curva_Nivel_VectorSetterUpper    INPUT FEATURE_TYPE Curva_Nivel___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Curva_Nivel_02ece63d_469a_493c_80f3_1629478a34c8147_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Curva_Nivel___PointCloudThinner    INPUT FEATURE_TYPE Curva_Nivel___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Curva_Nivel_02ece63d_469a_493c_80f3_1629478a34c8147_thinPointCloud")
Tcl2 proc Curva_Nivel_02ece63d_469a_493c_80f3_1629478a34c8147_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Curva_Nivel_RasterSetterUpper    INPUT FEATURE_TYPE Curva_Nivel___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Curva_Nivel_02ece63d_469a_493c_80f3_1629478a34c8147_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Curva_Nivel_02ece63d_469a_493c_80f3_1629478a34c8147_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Curva_Nivel_02ece63d_469a_493c_80f3_1629478a34c8147_VIS_FEAT_TYPE Curva_Nivel$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Curva_Nivel_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Curva_Nivel_02ece63d_469a_493c_80f3_1629478a34c8147_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,indice,varchar<openparen>255<closeparen>,depressao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,cota,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,ordemTickDepressao,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,emMassaDagua,varchar<openparen>255<closeparen>,cotadaPorProcesso,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Curva_Nivel Output Nuker"   INPUT FEATURE_TYPE Curva_Nivel

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Comporta_line_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Comporta_line_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Comporta_line_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Comporta_line_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Comporta_line_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Comporta_line_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Comporta_line_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Comporta_line_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Comporta_line_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Comporta_line_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Comporta_line_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Comporta_line_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Comporta_line_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Comporta_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8148_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Comporta_line_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Comporta_line_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Comporta_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8148_thinPointCloud")
Tcl2 proc Comporta_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8148_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Comporta_line_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Comporta_line_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Comporta_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8148_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Comporta_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8148_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Comporta_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8148_VIS_FEAT_TYPE Comporta_line_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Comporta_line_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Comporta_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8148_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Comporta_line_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Comporta_line_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Terreno_Exposto_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Terreno_Exposto_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Terreno_Exposto_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Terreno_Exposto_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Terreno_Exposto_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Terreno_Exposto_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Terreno_Exposto_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Terreno_Exposto_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Terreno_Exposto_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Terreno_Exposto_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Terreno_Exposto_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Terreno_Exposto_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Terreno_Exposto_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Terreno_Exposto_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8149_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Terreno_Exposto_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Terreno_Exposto_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Terreno_Exposto_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8149_thinPointCloud")
Tcl2 proc Terreno_Exposto_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8149_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Terreno_Exposto_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Terreno_Exposto_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Terreno_Exposto_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8149_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Terreno_Exposto_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8149_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Terreno_Exposto_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8149_VIS_FEAT_TYPE Terreno_Exposto_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Terreno_Exposto_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Terreno_Exposto_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8149_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Terreno_Exposto_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Terreno_Exposto_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Trecho_Duto_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Trecho_Duto_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Duto_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Trecho_Duto_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Trecho_Duto_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Trecho_Duto_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Trecho_Duto_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Trecho_Duto_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Trecho_Duto_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Trecho_Duto_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Trecho_Duto_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Duto_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Trecho_Duto_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Trecho_Duto_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8150_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Duto_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Trecho_Duto_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trecho_Duto_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8150_thinPointCloud")
Tcl2 proc Trecho_Duto_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8150_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Duto_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Trecho_Duto_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trecho_Duto_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8150_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Trecho_Duto_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8150_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Trecho_Duto_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8150_VIS_FEAT_TYPE Trecho_Duto_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Trecho_Duto_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Trecho_Duto_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8150_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Trecho_Duto_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Trecho_Duto_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Campo_Quadra_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Campo_Quadra_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_Quadra_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Campo_Quadra_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Campo_Quadra_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Campo_Quadra_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Campo_Quadra_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Campo_Quadra_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Campo_Quadra_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Campo_Quadra_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Campo_Quadra_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_Quadra_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Campo_Quadra_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Campo_Quadra_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8151_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_Quadra_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Campo_Quadra_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Campo_Quadra_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8151_thinPointCloud")
Tcl2 proc Campo_Quadra_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8151_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_Quadra_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Campo_Quadra_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Campo_Quadra_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8151_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Campo_Quadra_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8151_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Campo_Quadra_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8151_VIS_FEAT_TYPE Campo_Quadra_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Campo_Quadra_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Campo_Quadra_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8151_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Campo_Quadra_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Campo_Quadra_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Area_Lazer} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Area_Lazer_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Lazer_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Area_Lazer_FeatureDirector    INPUT  FEATURE_TYPE Area_Lazer    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Area_Lazer___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Lazer___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Area_Lazer___FeatureDirector1    INPUT FEATURE_TYPE Area_Lazer___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Area_Lazer___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Lazer___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Lazer_VectorSetterUpper    INPUT FEATURE_TYPE Area_Lazer___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Area_Lazer_02ece63d_469a_493c_80f3_1629478a34c8152_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Lazer___PointCloudThinner    INPUT FEATURE_TYPE Area_Lazer___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Lazer_02ece63d_469a_493c_80f3_1629478a34c8152_thinPointCloud")
Tcl2 proc Area_Lazer_02ece63d_469a_493c_80f3_1629478a34c8152_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Lazer_RasterSetterUpper    INPUT FEATURE_TYPE Area_Lazer___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Lazer_02ece63d_469a_493c_80f3_1629478a34c8152_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Area_Lazer_02ece63d_469a_493c_80f3_1629478a34c8152_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Area_Lazer_02ece63d_469a_493c_80f3_1629478a34c8152_VIS_FEAT_TYPE Area_Lazer$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Area_Lazer_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Area_Lazer_02ece63d_469a_493c_80f3_1629478a34c8152_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,fkComplLazer,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Area_Lazer Output Nuker"   INPUT FEATURE_TYPE Area_Lazer

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Dep_Abast_Agua_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Dep_Abast_Agua_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Abast_Agua_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Dep_Abast_Agua_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Dep_Abast_Agua_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Dep_Abast_Agua_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Dep_Abast_Agua_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Dep_Abast_Agua_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Dep_Abast_Agua_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Dep_Abast_Agua_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Dep_Abast_Agua_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Abast_Agua_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Dep_Abast_Agua_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Dep_Abast_Agua_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8153_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Abast_Agua_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Dep_Abast_Agua_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Dep_Abast_Agua_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8153_thinPointCloud")
Tcl2 proc Dep_Abast_Agua_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8153_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Abast_Agua_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Dep_Abast_Agua_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Dep_Abast_Agua_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8153_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Dep_Abast_Agua_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8153_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Dep_Abast_Agua_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8153_VIS_FEAT_TYPE Dep_Abast_Agua_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Dep_Abast_Agua_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Dep_Abast_Agua_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8153_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Dep_Abast_Agua_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Dep_Abast_Agua_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Trecho_Drenagem_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Trecho_Drenagem_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Drenagem_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Trecho_Drenagem_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Trecho_Drenagem_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Trecho_Drenagem_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Trecho_Drenagem_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Trecho_Drenagem_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Trecho_Drenagem_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Trecho_Drenagem_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Trecho_Drenagem_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Drenagem_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Trecho_Drenagem_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Trecho_Drenagem_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8154_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Drenagem_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Trecho_Drenagem_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trecho_Drenagem_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8154_thinPointCloud")
Tcl2 proc Trecho_Drenagem_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8154_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Drenagem_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Trecho_Drenagem_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trecho_Drenagem_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8154_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Trecho_Drenagem_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8154_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Trecho_Drenagem_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8154_VIS_FEAT_TYPE Trecho_Drenagem_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Trecho_Drenagem_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Trecho_Drenagem_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8154_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Trecho_Drenagem_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Trecho_Drenagem_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Saude_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Saude_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saude_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Saude_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Saude_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Saude_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Saude_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Saude_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Saude_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Saude_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Saude_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saude_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Saude_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Saude_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8155_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saude_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Saude_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Saude_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8155_thinPointCloud")
Tcl2 proc Edif_Saude_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8155_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saude_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Saude_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Saude_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8155_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Saude_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8155_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Saude_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8155_VIS_FEAT_TYPE Edif_Saude_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Saude_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Saude_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8155_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Saude_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Saude_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Trecho_Massa_Dagua_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Trecho_Massa_Dagua_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Massa_Dagua_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Trecho_Massa_Dagua_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Trecho_Massa_Dagua_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Trecho_Massa_Dagua_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Trecho_Massa_Dagua_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Trecho_Massa_Dagua_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Trecho_Massa_Dagua_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Trecho_Massa_Dagua_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Trecho_Massa_Dagua_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Massa_Dagua_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Trecho_Massa_Dagua_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Trecho_Massa_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8156_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Massa_Dagua_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Trecho_Massa_Dagua_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trecho_Massa_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8156_thinPointCloud")
Tcl2 proc Trecho_Massa_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8156_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Massa_Dagua_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Trecho_Massa_Dagua_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trecho_Massa_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8156_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Trecho_Massa_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8156_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Trecho_Massa_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8156_VIS_FEAT_TYPE Trecho_Massa_Dagua_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Trecho_Massa_Dagua_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Trecho_Massa_Dagua_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8156_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Trecho_Massa_Dagua_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Trecho_Massa_Dagua_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Caatinga_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Caatinga_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Caatinga_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Caatinga_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Caatinga_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Caatinga_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Caatinga_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Caatinga_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Caatinga_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Caatinga_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Caatinga_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Caatinga_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Caatinga_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Caatinga_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8157_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Caatinga_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Caatinga_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Caatinga_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8157_thinPointCloud")
Tcl2 proc Caatinga_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8157_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Caatinga_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Caatinga_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Caatinga_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8157_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Caatinga_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8157_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Caatinga_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8157_VIS_FEAT_TYPE Caatinga_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Caatinga_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Caatinga_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8157_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Caatinga_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Caatinga_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {GDB_GeomColumns} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME GDB_GeomColumns_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_GeomColumns_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME GDB_GeomColumns_FeatureDirector    INPUT  FEATURE_TYPE GDB_GeomColumns    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE GDB_GeomColumns___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE GDB_GeomColumns___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME GDB_GeomColumns___FeatureDirector1    INPUT FEATURE_TYPE GDB_GeomColumns___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE GDB_GeomColumns___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE GDB_GeomColumns___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_GeomColumns_VectorSetterUpper    INPUT FEATURE_TYPE GDB_GeomColumns___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc GDB_GeomColumns_02ece63d_469a_493c_80f3_1629478a34c8158_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_GeomColumns___PointCloudThinner    INPUT FEATURE_TYPE GDB_GeomColumns___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("GDB_GeomColumns_02ece63d_469a_493c_80f3_1629478a34c8158_thinPointCloud")
Tcl2 proc GDB_GeomColumns_02ece63d_469a_493c_80f3_1629478a34c8158_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_GeomColumns_RasterSetterUpper    INPUT FEATURE_TYPE GDB_GeomColumns___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("GDB_GeomColumns_02ece63d_469a_493c_80f3_1629478a34c8158_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# GDB_GeomColumns_02ece63d_469a_493c_80f3_1629478a34c8158_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO GDB_GeomColumns_02ece63d_469a_493c_80f3_1629478a34c8158_VIS_FEAT_TYPE GDB_GeomColumns$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME GDB_GeomColumns_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(GDB_GeomColumns_02ece63d_469a_493c_80f3_1629478a34c8158_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA TableName,varchar<openparen>255<closeparen>,FieldName,varchar<openparen>255<closeparen>,ShapeType,varchar<openparen>255<closeparen>,ExtentLeft,varchar<openparen>255<closeparen>,ExtentBottom,varchar<openparen>255<closeparen>,ExtentRight,varchar<openparen>255<closeparen>,ExtentTop,varchar<openparen>255<closeparen>,IdxOriginX,varchar<openparen>255<closeparen>,IdxOriginY,varchar<openparen>255<closeparen>,IdxGridSize,varchar<openparen>255<closeparen>,SRID,varchar<openparen>255<closeparen>,HasZ,varchar<openparen>255<closeparen>,HasM,varchar<openparen>255<closeparen>,ZLow,varchar<openparen>255<closeparen>,ZHigh,varchar<openparen>255<closeparen>,MLow,varchar<openparen>255<closeparen>,MHigh,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "GDB_GeomColumns Output Nuker"   INPUT FEATURE_TYPE GDB_GeomColumns

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Arruamento_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Arruamento_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Arruamento_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Arruamento_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Arruamento_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Arruamento_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Arruamento_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Arruamento_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Arruamento_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Arruamento_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Arruamento_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Arruamento_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Arruamento_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Arruamento_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8159_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Arruamento_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Arruamento_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Arruamento_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8159_thinPointCloud")
Tcl2 proc Arruamento_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8159_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Arruamento_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Arruamento_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Arruamento_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8159_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Arruamento_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8159_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Arruamento_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8159_VIS_FEAT_TYPE Arruamento_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Arruamento_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Arruamento_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8159_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Arruamento_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Arruamento_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Ponte_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Ponte_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponte_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Ponte_point_FeatureDirector    INPUT  FEATURE_TYPE Ponte_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Ponte_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Ponte_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Ponte_point___FeatureDirector1    INPUT FEATURE_TYPE Ponte_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Ponte_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Ponte_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Ponte_point_VectorSetterUpper    INPUT FEATURE_TYPE Ponte_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Ponte_point_02ece63d_469a_493c_80f3_1629478a34c8160_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponte_point___PointCloudThinner    INPUT FEATURE_TYPE Ponte_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponte_point_02ece63d_469a_493c_80f3_1629478a34c8160_thinPointCloud")
Tcl2 proc Ponte_point_02ece63d_469a_493c_80f3_1629478a34c8160_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponte_point_RasterSetterUpper    INPUT FEATURE_TYPE Ponte_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponte_point_02ece63d_469a_493c_80f3_1629478a34c8160_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Ponte_point_02ece63d_469a_493c_80f3_1629478a34c8160_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Ponte_point_02ece63d_469a_493c_80f3_1629478a34c8160_VIS_FEAT_TYPE Ponte_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Ponte_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Ponte_point_02ece63d_469a_493c_80f3_1629478a34c8160_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,largura,varchar<openparen>255<closeparen>,extensao,varchar<openparen>255<closeparen>,vaoVertical,varchar<openparen>255<closeparen>,vaoLivreHoriz,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,nrFaixas,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,tipoPonte,varchar<openparen>255<closeparen>,nrPistas,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,necessidadeManutencao,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,modalUso,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,pesoMaxSuportTon,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,posicaoPista,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Ponte_point Output Nuker"   INPUT FEATURE_TYPE Ponte_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {T_1_LineErrors_Shape_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME T_1_LineErrors_Shape_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_LineErrors_Shape_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME T_1_LineErrors_Shape_Index_FeatureDirector    INPUT  FEATURE_TYPE T_1_LineErrors_Shape_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE T_1_LineErrors_Shape_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE T_1_LineErrors_Shape_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME T_1_LineErrors_Shape_Index___FeatureDirector1    INPUT FEATURE_TYPE T_1_LineErrors_Shape_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE T_1_LineErrors_Shape_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE T_1_LineErrors_Shape_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_LineErrors_Shape_Index_VectorSetterUpper    INPUT FEATURE_TYPE T_1_LineErrors_Shape_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc T_1_LineErrors_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c8161_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_LineErrors_Shape_Index___PointCloudThinner    INPUT FEATURE_TYPE T_1_LineErrors_Shape_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("T_1_LineErrors_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c8161_thinPointCloud")
Tcl2 proc T_1_LineErrors_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c8161_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_LineErrors_Shape_Index_RasterSetterUpper    INPUT FEATURE_TYPE T_1_LineErrors_Shape_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("T_1_LineErrors_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c8161_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# T_1_LineErrors_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c8161_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO T_1_LineErrors_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c8161_VIS_FEAT_TYPE T_1_LineErrors_Shape_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME T_1_LineErrors_Shape_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(T_1_LineErrors_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c8161_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "T_1_LineErrors_Shape_Index Output Nuker"   INPUT FEATURE_TYPE T_1_LineErrors_Shape_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Arquibancada_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Arquibancada_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Arquibancada_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Arquibancada_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Arquibancada_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Arquibancada_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Arquibancada_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Arquibancada_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Arquibancada_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Arquibancada_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Arquibancada_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Arquibancada_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Arquibancada_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Arquibancada_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8162_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Arquibancada_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Arquibancada_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Arquibancada_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8162_thinPointCloud")
Tcl2 proc Arquibancada_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8162_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Arquibancada_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Arquibancada_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Arquibancada_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8162_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Arquibancada_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8162_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Arquibancada_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8162_VIS_FEAT_TYPE Arquibancada_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Arquibancada_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Arquibancada_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8162_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Arquibancada_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Arquibancada_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Trecho_Energia_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Trecho_Energia_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Energia_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Trecho_Energia_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Trecho_Energia_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Trecho_Energia_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Trecho_Energia_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Trecho_Energia_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Trecho_Energia_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Trecho_Energia_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Trecho_Energia_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Energia_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Trecho_Energia_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Trecho_Energia_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8163_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Energia_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Trecho_Energia_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trecho_Energia_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8163_thinPointCloud")
Tcl2 proc Trecho_Energia_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8163_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Energia_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Trecho_Energia_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trecho_Energia_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8163_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Trecho_Energia_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8163_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Trecho_Energia_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8163_VIS_FEAT_TYPE Trecho_Energia_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Trecho_Energia_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Trecho_Energia_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8163_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Trecho_Energia_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Trecho_Energia_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Abast_Agua_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Abast_Agua_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Abast_Agua_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Abast_Agua_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Abast_Agua_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Abast_Agua_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Abast_Agua_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Abast_Agua_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Abast_Agua_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Abast_Agua_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Abast_Agua_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Abast_Agua_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Abast_Agua_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Abast_Agua_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8164_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Abast_Agua_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Abast_Agua_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Abast_Agua_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8164_thinPointCloud")
Tcl2 proc Edif_Abast_Agua_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8164_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Abast_Agua_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Abast_Agua_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Abast_Agua_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8164_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Abast_Agua_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8164_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Abast_Agua_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8164_VIS_FEAT_TYPE Edif_Abast_Agua_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Abast_Agua_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Abast_Agua_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8164_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Abast_Agua_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Abast_Agua_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Ilha_polygon_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Ilha_polygon_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Ilha_polygon_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Ilha_polygon_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Ilha_polygon_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Ilha_polygon_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Ilha_polygon_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Ilha_polygon_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Ilha_polygon_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Ilha_polygon_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Ilha_polygon_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Ilha_polygon_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Ilha_polygon_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Ilha_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8165_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ilha_polygon_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Ilha_polygon_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ilha_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8165_thinPointCloud")
Tcl2 proc Ilha_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8165_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ilha_polygon_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Ilha_polygon_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ilha_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8165_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Ilha_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8165_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Ilha_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8165_VIS_FEAT_TYPE Ilha_polygon_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Ilha_polygon_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Ilha_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8165_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Ilha_polygon_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Ilha_polygon_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Arquibancada_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Arquibancada_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Arquibancada_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Arquibancada_point_FeatureDirector    INPUT  FEATURE_TYPE Arquibancada_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Arquibancada_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Arquibancada_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Arquibancada_point___FeatureDirector1    INPUT FEATURE_TYPE Arquibancada_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Arquibancada_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Arquibancada_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Arquibancada_point_VectorSetterUpper    INPUT FEATURE_TYPE Arquibancada_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Arquibancada_point_02ece63d_469a_493c_80f3_1629478a34c8166_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Arquibancada_point___PointCloudThinner    INPUT FEATURE_TYPE Arquibancada_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Arquibancada_point_02ece63d_469a_493c_80f3_1629478a34c8166_thinPointCloud")
Tcl2 proc Arquibancada_point_02ece63d_469a_493c_80f3_1629478a34c8166_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Arquibancada_point_RasterSetterUpper    INPUT FEATURE_TYPE Arquibancada_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Arquibancada_point_02ece63d_469a_493c_80f3_1629478a34c8166_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Arquibancada_point_02ece63d_469a_493c_80f3_1629478a34c8166_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Arquibancada_point_02ece63d_469a_493c_80f3_1629478a34c8166_VIS_FEAT_TYPE Arquibancada_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Arquibancada_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Arquibancada_point_02ece63d_469a_493c_80f3_1629478a34c8166_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,fkComplLazer,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Arquibancada_point Output Nuker"   INPUT FEATURE_TYPE Arquibancada_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Area_Uso_Comunitario_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Area_Uso_Comunitario_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Uso_Comunitario_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Area_Uso_Comunitario_point_FeatureDirector    INPUT  FEATURE_TYPE Area_Uso_Comunitario_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Area_Uso_Comunitario_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Uso_Comunitario_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Area_Uso_Comunitario_point___FeatureDirector1    INPUT FEATURE_TYPE Area_Uso_Comunitario_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Area_Uso_Comunitario_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Uso_Comunitario_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Uso_Comunitario_point_VectorSetterUpper    INPUT FEATURE_TYPE Area_Uso_Comunitario_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Area_Uso_Comunitario_point_02ece63d_469a_493c_80f3_1629478a34c8167_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Uso_Comunitario_point___PointCloudThinner    INPUT FEATURE_TYPE Area_Uso_Comunitario_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Uso_Comunitario_point_02ece63d_469a_493c_80f3_1629478a34c8167_thinPointCloud")
Tcl2 proc Area_Uso_Comunitario_point_02ece63d_469a_493c_80f3_1629478a34c8167_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Uso_Comunitario_point_RasterSetterUpper    INPUT FEATURE_TYPE Area_Uso_Comunitario_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Uso_Comunitario_point_02ece63d_469a_493c_80f3_1629478a34c8167_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Area_Uso_Comunitario_point_02ece63d_469a_493c_80f3_1629478a34c8167_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Area_Uso_Comunitario_point_02ece63d_469a_493c_80f3_1629478a34c8167_VIS_FEAT_TYPE Area_Uso_Comunitario_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Area_Uso_Comunitario_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Area_Uso_Comunitario_point_02ece63d_469a_493c_80f3_1629478a34c8167_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,tamanhoTxt,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,tipoAreaUsoComun,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Area_Uso_Comunitario_point Output Nuker"   INPUT FEATURE_TYPE Area_Uso_Comunitario_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Cerrado_Cerradao} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Cerrado_Cerradao_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Cerrado_Cerradao_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Cerrado_Cerradao_FeatureDirector    INPUT  FEATURE_TYPE Cerrado_Cerradao    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Cerrado_Cerradao___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Cerrado_Cerradao___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Cerrado_Cerradao___FeatureDirector1    INPUT FEATURE_TYPE Cerrado_Cerradao___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Cerrado_Cerradao___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Cerrado_Cerradao___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Cerrado_Cerradao_VectorSetterUpper    INPUT FEATURE_TYPE Cerrado_Cerradao___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Cerrado_Cerradao_02ece63d_469a_493c_80f3_1629478a34c8168_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Cerrado_Cerradao___PointCloudThinner    INPUT FEATURE_TYPE Cerrado_Cerradao___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Cerrado_Cerradao_02ece63d_469a_493c_80f3_1629478a34c8168_thinPointCloud")
Tcl2 proc Cerrado_Cerradao_02ece63d_469a_493c_80f3_1629478a34c8168_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Cerrado_Cerradao_RasterSetterUpper    INPUT FEATURE_TYPE Cerrado_Cerradao___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Cerrado_Cerradao_02ece63d_469a_493c_80f3_1629478a34c8168_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Cerrado_Cerradao_02ece63d_469a_493c_80f3_1629478a34c8168_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Cerrado_Cerradao_02ece63d_469a_493c_80f3_1629478a34c8168_VIS_FEAT_TYPE Cerrado_Cerradao$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Cerrado_Cerradao_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Cerrado_Cerradao_02ece63d_469a_493c_80f3_1629478a34c8168_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,alturaMediaIndividuos,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,denso,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,classificacaoPorte,varchar<openparen>255<closeparen>,antropizada,varchar<openparen>255<closeparen>,tipoCerr,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Cerrado_Cerradao Output Nuker"   INPUT FEATURE_TYPE Cerrado_Cerradao

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Torre_Comunic} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Torre_Comunic_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Torre_Comunic_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Torre_Comunic_FeatureDirector    INPUT  FEATURE_TYPE Torre_Comunic    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Torre_Comunic___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Torre_Comunic___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Torre_Comunic___FeatureDirector1    INPUT FEATURE_TYPE Torre_Comunic___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Torre_Comunic___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Torre_Comunic___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Torre_Comunic_VectorSetterUpper    INPUT FEATURE_TYPE Torre_Comunic___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Torre_Comunic_02ece63d_469a_493c_80f3_1629478a34c8169_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Torre_Comunic___PointCloudThinner    INPUT FEATURE_TYPE Torre_Comunic___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Torre_Comunic_02ece63d_469a_493c_80f3_1629478a34c8169_thinPointCloud")
Tcl2 proc Torre_Comunic_02ece63d_469a_493c_80f3_1629478a34c8169_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Torre_Comunic_RasterSetterUpper    INPUT FEATURE_TYPE Torre_Comunic___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Torre_Comunic_02ece63d_469a_493c_80f3_1629478a34c8169_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Torre_Comunic_02ece63d_469a_493c_80f3_1629478a34c8169_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Torre_Comunic_02ece63d_469a_493c_80f3_1629478a34c8169_VIS_FEAT_TYPE Torre_Comunic$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Torre_Comunic_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Torre_Comunic_02ece63d_469a_493c_80f3_1629478a34c8169_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,alturaEstimada,varchar<openparen>255<closeparen>,ovgd,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,fkComplComunic,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,posicaoRelEdific,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Torre_Comunic Output Nuker"   INPUT FEATURE_TYPE Torre_Comunic

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {T_1_PointErrors_Shape_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME T_1_PointErrors_Shape_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_PointErrors_Shape_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME T_1_PointErrors_Shape_Index_FeatureDirector    INPUT  FEATURE_TYPE T_1_PointErrors_Shape_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE T_1_PointErrors_Shape_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE T_1_PointErrors_Shape_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME T_1_PointErrors_Shape_Index___FeatureDirector1    INPUT FEATURE_TYPE T_1_PointErrors_Shape_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE T_1_PointErrors_Shape_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE T_1_PointErrors_Shape_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_PointErrors_Shape_Index_VectorSetterUpper    INPUT FEATURE_TYPE T_1_PointErrors_Shape_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc T_1_PointErrors_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c8170_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_PointErrors_Shape_Index___PointCloudThinner    INPUT FEATURE_TYPE T_1_PointErrors_Shape_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("T_1_PointErrors_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c8170_thinPointCloud")
Tcl2 proc T_1_PointErrors_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c8170_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_PointErrors_Shape_Index_RasterSetterUpper    INPUT FEATURE_TYPE T_1_PointErrors_Shape_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("T_1_PointErrors_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c8170_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# T_1_PointErrors_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c8170_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO T_1_PointErrors_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c8170_VIS_FEAT_TYPE T_1_PointErrors_Shape_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME T_1_PointErrors_Shape_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(T_1_PointErrors_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c8170_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "T_1_PointErrors_Shape_Index Output Nuker"   INPUT FEATURE_TYPE T_1_PointErrors_Shape_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Grupo_Transform_Energ_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Grupo_Transform_Energ_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Grupo_Transform_Energ_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Grupo_Transform_Energ_point_FeatureDirector    INPUT  FEATURE_TYPE Grupo_Transform_Energ_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Grupo_Transform_Energ_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Grupo_Transform_Energ_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Grupo_Transform_Energ_point___FeatureDirector1    INPUT FEATURE_TYPE Grupo_Transform_Energ_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Grupo_Transform_Energ_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Grupo_Transform_Energ_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Grupo_Transform_Energ_point_VectorSetterUpper    INPUT FEATURE_TYPE Grupo_Transform_Energ_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Grupo_Transform_Energ_point_02ece63d_469a_493c_80f3_1629478a34c8171_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Grupo_Transform_Energ_point___PointCloudThinner    INPUT FEATURE_TYPE Grupo_Transform_Energ_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Grupo_Transform_Energ_point_02ece63d_469a_493c_80f3_1629478a34c8171_thinPointCloud")
Tcl2 proc Grupo_Transform_Energ_point_02ece63d_469a_493c_80f3_1629478a34c8171_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Grupo_Transform_Energ_point_RasterSetterUpper    INPUT FEATURE_TYPE Grupo_Transform_Energ_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Grupo_Transform_Energ_point_02ece63d_469a_493c_80f3_1629478a34c8171_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Grupo_Transform_Energ_point_02ece63d_469a_493c_80f3_1629478a34c8171_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Grupo_Transform_Energ_point_02ece63d_469a_493c_80f3_1629478a34c8171_VIS_FEAT_TYPE Grupo_Transform_Energ_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Grupo_Transform_Energ_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Grupo_Transform_Energ_point_02ece63d_469a_493c_80f3_1629478a34c8171_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,fkComplSubEnEletr,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Grupo_Transform_Energ_point Output Nuker"   INPUT FEATURE_TYPE Grupo_Transform_Energ_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Gruta_Caverna_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Gruta_Caverna_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Gruta_Caverna_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Gruta_Caverna_point_FeatureDirector    INPUT  FEATURE_TYPE Gruta_Caverna_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Gruta_Caverna_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Gruta_Caverna_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Gruta_Caverna_point___FeatureDirector1    INPUT FEATURE_TYPE Gruta_Caverna_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Gruta_Caverna_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Gruta_Caverna_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Gruta_Caverna_point_VectorSetterUpper    INPUT FEATURE_TYPE Gruta_Caverna_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Gruta_Caverna_point_02ece63d_469a_493c_80f3_1629478a34c8172_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Gruta_Caverna_point___PointCloudThinner    INPUT FEATURE_TYPE Gruta_Caverna_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Gruta_Caverna_point_02ece63d_469a_493c_80f3_1629478a34c8172_thinPointCloud")
Tcl2 proc Gruta_Caverna_point_02ece63d_469a_493c_80f3_1629478a34c8172_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Gruta_Caverna_point_RasterSetterUpper    INPUT FEATURE_TYPE Gruta_Caverna_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Gruta_Caverna_point_02ece63d_469a_493c_80f3_1629478a34c8172_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Gruta_Caverna_point_02ece63d_469a_493c_80f3_1629478a34c8172_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Gruta_Caverna_point_02ece63d_469a_493c_80f3_1629478a34c8172_VIS_FEAT_TYPE Gruta_Caverna_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Gruta_Caverna_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Gruta_Caverna_point_02ece63d_469a_493c_80f3_1629478a34c8172_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,tipoElemNat,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,tamanhoTxt,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Gruta_Caverna_point Output Nuker"   INPUT FEATURE_TYPE Gruta_Caverna_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Deposito_Geral_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Deposito_Geral_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Deposito_Geral_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Deposito_Geral_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Deposito_Geral_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Deposito_Geral_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Deposito_Geral_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Deposito_Geral_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Deposito_Geral_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Deposito_Geral_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Deposito_Geral_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Deposito_Geral_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Deposito_Geral_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Deposito_Geral_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8173_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Deposito_Geral_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Deposito_Geral_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Deposito_Geral_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8173_thinPointCloud")
Tcl2 proc Deposito_Geral_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8173_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Deposito_Geral_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Deposito_Geral_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Deposito_Geral_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8173_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Deposito_Geral_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8173_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Deposito_Geral_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8173_VIS_FEAT_TYPE Deposito_Geral_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Deposito_Geral_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Deposito_Geral_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8173_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Deposito_Geral_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Deposito_Geral_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Alter_Fisiog_Antropica_line_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Alter_Fisiog_Antropica_line_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Alter_Fisiog_Antropica_line_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Alter_Fisiog_Antropica_line_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Alter_Fisiog_Antropica_line_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Alter_Fisiog_Antropica_line_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Alter_Fisiog_Antropica_line_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Alter_Fisiog_Antropica_line_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Alter_Fisiog_Antropica_line_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Alter_Fisiog_Antropica_line_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Alter_Fisiog_Antropica_line_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Alter_Fisiog_Antropica_line_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Alter_Fisiog_Antropica_line_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Alter_Fisiog_Antropica_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8174_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Alter_Fisiog_Antropica_line_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Alter_Fisiog_Antropica_line_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Alter_Fisiog_Antropica_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8174_thinPointCloud")
Tcl2 proc Alter_Fisiog_Antropica_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8174_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Alter_Fisiog_Antropica_line_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Alter_Fisiog_Antropica_line_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Alter_Fisiog_Antropica_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8174_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Alter_Fisiog_Antropica_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8174_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Alter_Fisiog_Antropica_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8174_VIS_FEAT_TYPE Alter_Fisiog_Antropica_line_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Alter_Fisiog_Antropica_line_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Alter_Fisiog_Antropica_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8174_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Alter_Fisiog_Antropica_line_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Alter_Fisiog_Antropica_line_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Ponto_Duto_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Ponto_Duto_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Duto_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Duto_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Ponto_Duto_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Ponto_Duto_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Duto_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Duto_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Ponto_Duto_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Ponto_Duto_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Duto_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Duto_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Ponto_Duto_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Ponto_Duto_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8175_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Duto_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Ponto_Duto_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Duto_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8175_thinPointCloud")
Tcl2 proc Ponto_Duto_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8175_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Duto_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Ponto_Duto_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Duto_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8175_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Ponto_Duto_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8175_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Ponto_Duto_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8175_VIS_FEAT_TYPE Ponto_Duto_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Ponto_Duto_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Ponto_Duto_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8175_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Ponto_Duto_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Ponto_Duto_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Const_Lazer_polygon} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Const_Lazer_polygon_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Lazer_polygon_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Const_Lazer_polygon_FeatureDirector    INPUT  FEATURE_TYPE Edif_Const_Lazer_polygon    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Const_Lazer_polygon___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Const_Lazer_polygon___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Const_Lazer_polygon___FeatureDirector1    INPUT FEATURE_TYPE Edif_Const_Lazer_polygon___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Const_Lazer_polygon___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Const_Lazer_polygon___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Lazer_polygon_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Const_Lazer_polygon___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Const_Lazer_polygon_02ece63d_469a_493c_80f3_1629478a34c8176_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Lazer_polygon___PointCloudThinner    INPUT FEATURE_TYPE Edif_Const_Lazer_polygon___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Const_Lazer_polygon_02ece63d_469a_493c_80f3_1629478a34c8176_thinPointCloud")
Tcl2 proc Edif_Const_Lazer_polygon_02ece63d_469a_493c_80f3_1629478a34c8176_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Lazer_polygon_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Const_Lazer_polygon___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Const_Lazer_polygon_02ece63d_469a_493c_80f3_1629478a34c8176_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Const_Lazer_polygon_02ece63d_469a_493c_80f3_1629478a34c8176_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Const_Lazer_polygon_02ece63d_469a_493c_80f3_1629478a34c8176_VIS_FEAT_TYPE Edif_Const_Lazer_polygon$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Const_Lazer_polygon_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Const_Lazer_polygon_02ece63d_469a_493c_80f3_1629478a34c8176_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,tipoEdifLazer,varchar<openparen>255<closeparen>,fkComplLazer,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Const_Lazer_polygon Output Nuker"   INPUT FEATURE_TYPE Edif_Const_Lazer_polygon

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Area_Uso_Comunitario_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Area_Uso_Comunitario_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Uso_Comunitario_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Area_Uso_Comunitario_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Area_Uso_Comunitario_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Area_Uso_Comunitario_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Uso_Comunitario_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Area_Uso_Comunitario_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Area_Uso_Comunitario_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Area_Uso_Comunitario_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Uso_Comunitario_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Uso_Comunitario_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Area_Uso_Comunitario_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Area_Uso_Comunitario_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8177_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Uso_Comunitario_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Area_Uso_Comunitario_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Uso_Comunitario_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8177_thinPointCloud")
Tcl2 proc Area_Uso_Comunitario_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8177_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Uso_Comunitario_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Area_Uso_Comunitario_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Uso_Comunitario_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8177_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Area_Uso_Comunitario_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8177_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Area_Uso_Comunitario_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8177_VIS_FEAT_TYPE Area_Uso_Comunitario_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Area_Uso_Comunitario_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Area_Uso_Comunitario_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8177_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Area_Uso_Comunitario_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Area_Uso_Comunitario_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Pub_Militar_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Pub_Militar_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Militar_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Pub_Militar_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Pub_Militar_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Pub_Militar_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Pub_Militar_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Pub_Militar_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Pub_Militar_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Pub_Militar_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Pub_Militar_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Militar_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Pub_Militar_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Pub_Militar_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8178_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Militar_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Pub_Militar_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Pub_Militar_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8178_thinPointCloud")
Tcl2 proc Edif_Pub_Militar_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8178_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Militar_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Pub_Militar_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Pub_Militar_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8178_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Pub_Militar_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8178_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Pub_Militar_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8178_VIS_FEAT_TYPE Edif_Pub_Militar_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Pub_Militar_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Pub_Militar_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8178_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Pub_Militar_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Pub_Militar_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Const_Turistica_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Const_Turistica_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Turistica_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Const_Turistica_point_FeatureDirector    INPUT  FEATURE_TYPE Edif_Const_Turistica_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Const_Turistica_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Const_Turistica_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Const_Turistica_point___FeatureDirector1    INPUT FEATURE_TYPE Edif_Const_Turistica_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Const_Turistica_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Const_Turistica_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Turistica_point_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Const_Turistica_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Const_Turistica_point_02ece63d_469a_493c_80f3_1629478a34c8179_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Turistica_point___PointCloudThinner    INPUT FEATURE_TYPE Edif_Const_Turistica_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Const_Turistica_point_02ece63d_469a_493c_80f3_1629478a34c8179_thinPointCloud")
Tcl2 proc Edif_Const_Turistica_point_02ece63d_469a_493c_80f3_1629478a34c8179_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Const_Turistica_point_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Const_Turistica_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Const_Turistica_point_02ece63d_469a_493c_80f3_1629478a34c8179_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Const_Turistica_point_02ece63d_469a_493c_80f3_1629478a34c8179_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Const_Turistica_point_02ece63d_469a_493c_80f3_1629478a34c8179_VIS_FEAT_TYPE Edif_Const_Turistica_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Const_Turistica_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Const_Turistica_point_02ece63d_469a_493c_80f3_1629478a34c8179_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,ovgd,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,fkComplLazer,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,tipoEdifTurist,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Const_Turistica_point Output Nuker"   INPUT FEATURE_TYPE Edif_Const_Turistica_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Delimitacao_Fisica} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Delimitacao_Fisica_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Delimitacao_Fisica_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Delimitacao_Fisica_FeatureDirector    INPUT  FEATURE_TYPE Delimitacao_Fisica    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Delimitacao_Fisica___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Delimitacao_Fisica___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Delimitacao_Fisica___FeatureDirector1    INPUT FEATURE_TYPE Delimitacao_Fisica___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Delimitacao_Fisica___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Delimitacao_Fisica___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Delimitacao_Fisica_VectorSetterUpper    INPUT FEATURE_TYPE Delimitacao_Fisica___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Delimitacao_Fisica_02ece63d_469a_493c_80f3_1629478a34c8180_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Delimitacao_Fisica___PointCloudThinner    INPUT FEATURE_TYPE Delimitacao_Fisica___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Delimitacao_Fisica_02ece63d_469a_493c_80f3_1629478a34c8180_thinPointCloud")
Tcl2 proc Delimitacao_Fisica_02ece63d_469a_493c_80f3_1629478a34c8180_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Delimitacao_Fisica_RasterSetterUpper    INPUT FEATURE_TYPE Delimitacao_Fisica___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Delimitacao_Fisica_02ece63d_469a_493c_80f3_1629478a34c8180_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Delimitacao_Fisica_02ece63d_469a_493c_80f3_1629478a34c8180_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Delimitacao_Fisica_02ece63d_469a_493c_80f3_1629478a34c8180_VIS_FEAT_TYPE Delimitacao_Fisica$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Delimitacao_Fisica_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Delimitacao_Fisica_02ece63d_469a_493c_80f3_1629478a34c8180_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,tipoDelimFis,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,eletrificada,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Delimitacao_Fisica Output Nuker"   INPUT FEATURE_TYPE Delimitacao_Fisica

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {GDB_Items_Shape_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME GDB_Items_Shape_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_Items_Shape_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME GDB_Items_Shape_Index_FeatureDirector    INPUT  FEATURE_TYPE GDB_Items_Shape_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE GDB_Items_Shape_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE GDB_Items_Shape_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME GDB_Items_Shape_Index___FeatureDirector1    INPUT FEATURE_TYPE GDB_Items_Shape_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE GDB_Items_Shape_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE GDB_Items_Shape_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_Items_Shape_Index_VectorSetterUpper    INPUT FEATURE_TYPE GDB_Items_Shape_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc GDB_Items_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c8181_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_Items_Shape_Index___PointCloudThinner    INPUT FEATURE_TYPE GDB_Items_Shape_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("GDB_Items_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c8181_thinPointCloud")
Tcl2 proc GDB_Items_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c8181_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME GDB_Items_Shape_Index_RasterSetterUpper    INPUT FEATURE_TYPE GDB_Items_Shape_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("GDB_Items_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c8181_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# GDB_Items_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c8181_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO GDB_Items_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c8181_VIS_FEAT_TYPE GDB_Items_Shape_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME GDB_Items_Shape_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(GDB_Items_Shape_Index_02ece63d_469a_493c_80f3_1629478a34c8181_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "GDB_Items_Shape_Index Output Nuker"   INPUT FEATURE_TYPE GDB_Items_Shape_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Area_Lazer_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Area_Lazer_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Lazer_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Area_Lazer_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Area_Lazer_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Area_Lazer_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Lazer_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Area_Lazer_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Area_Lazer_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Area_Lazer_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Lazer_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Lazer_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Area_Lazer_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Area_Lazer_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8182_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Lazer_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Area_Lazer_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Lazer_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8182_thinPointCloud")
Tcl2 proc Area_Lazer_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8182_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Lazer_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Area_Lazer_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Lazer_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8182_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Area_Lazer_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8182_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Area_Lazer_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8182_VIS_FEAT_TYPE Area_Lazer_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Area_Lazer_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Area_Lazer_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8182_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Area_Lazer_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Area_Lazer_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Ponto_Trecho_Energia} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Ponto_Trecho_Energia_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Trecho_Energia_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Trecho_Energia_FeatureDirector    INPUT  FEATURE_TYPE Ponto_Trecho_Energia    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Ponto_Trecho_Energia___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Trecho_Energia___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Trecho_Energia___FeatureDirector1    INPUT FEATURE_TYPE Ponto_Trecho_Energia___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Ponto_Trecho_Energia___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Trecho_Energia___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Trecho_Energia_VectorSetterUpper    INPUT FEATURE_TYPE Ponto_Trecho_Energia___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Ponto_Trecho_Energia_02ece63d_469a_493c_80f3_1629478a34c8183_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Trecho_Energia___PointCloudThinner    INPUT FEATURE_TYPE Ponto_Trecho_Energia___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Trecho_Energia_02ece63d_469a_493c_80f3_1629478a34c8183_thinPointCloud")
Tcl2 proc Ponto_Trecho_Energia_02ece63d_469a_493c_80f3_1629478a34c8183_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Trecho_Energia_RasterSetterUpper    INPUT FEATURE_TYPE Ponto_Trecho_Energia___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Trecho_Energia_02ece63d_469a_493c_80f3_1629478a34c8183_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Ponto_Trecho_Energia_02ece63d_469a_493c_80f3_1629478a34c8183_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Ponto_Trecho_Energia_02ece63d_469a_493c_80f3_1629478a34c8183_VIS_FEAT_TYPE Ponto_Trecho_Energia$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Ponto_Trecho_Energia_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Ponto_Trecho_Energia_02ece63d_469a_493c_80f3_1629478a34c8183_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,tipoPtoEnergia,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Ponto_Trecho_Energia Output Nuker"   INPUT FEATURE_TYPE Ponto_Trecho_Energia

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Travessia_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Travessia_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Travessia_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Travessia_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Travessia_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Travessia_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Travessia_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Travessia_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Travessia_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Travessia_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Travessia_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Travessia_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Travessia_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Travessia_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8184_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Travessia_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Travessia_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Travessia_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8184_thinPointCloud")
Tcl2 proc Travessia_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8184_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Travessia_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Travessia_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Travessia_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8184_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Travessia_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8184_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Travessia_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8184_VIS_FEAT_TYPE Travessia_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Travessia_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Travessia_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8184_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Travessia_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Travessia_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Confluencia} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Confluencia_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Confluencia_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Confluencia_FeatureDirector    INPUT  FEATURE_TYPE Confluencia    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Confluencia___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Confluencia___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Confluencia___FeatureDirector1    INPUT FEATURE_TYPE Confluencia___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Confluencia___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Confluencia___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Confluencia_VectorSetterUpper    INPUT FEATURE_TYPE Confluencia___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Confluencia_02ece63d_469a_493c_80f3_1629478a34c8185_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Confluencia___PointCloudThinner    INPUT FEATURE_TYPE Confluencia___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Confluencia_02ece63d_469a_493c_80f3_1629478a34c8185_thinPointCloud")
Tcl2 proc Confluencia_02ece63d_469a_493c_80f3_1629478a34c8185_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Confluencia_RasterSetterUpper    INPUT FEATURE_TYPE Confluencia___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Confluencia_02ece63d_469a_493c_80f3_1629478a34c8185_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Confluencia_02ece63d_469a_493c_80f3_1629478a34c8185_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Confluencia_02ece63d_469a_493c_80f3_1629478a34c8185_VIS_FEAT_TYPE Confluencia$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Confluencia_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Confluencia_02ece63d_469a_493c_80f3_1629478a34c8185_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,relacionado,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Confluencia Output Nuker"   INPUT FEATURE_TYPE Confluencia

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Area_Industrial} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Area_Industrial_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Industrial_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Area_Industrial_FeatureDirector    INPUT  FEATURE_TYPE Area_Industrial    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Area_Industrial___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Industrial___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Area_Industrial___FeatureDirector1    INPUT FEATURE_TYPE Area_Industrial___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Area_Industrial___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Area_Industrial___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Industrial_VectorSetterUpper    INPUT FEATURE_TYPE Area_Industrial___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Area_Industrial_02ece63d_469a_493c_80f3_1629478a34c8186_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Industrial___PointCloudThinner    INPUT FEATURE_TYPE Area_Industrial___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Industrial_02ece63d_469a_493c_80f3_1629478a34c8186_thinPointCloud")
Tcl2 proc Area_Industrial_02ece63d_469a_493c_80f3_1629478a34c8186_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Area_Industrial_RasterSetterUpper    INPUT FEATURE_TYPE Area_Industrial___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Area_Industrial_02ece63d_469a_493c_80f3_1629478a34c8186_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Area_Industrial_02ece63d_469a_493c_80f3_1629478a34c8186_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Area_Industrial_02ece63d_469a_493c_80f3_1629478a34c8186_VIS_FEAT_TYPE Area_Industrial$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Area_Industrial_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Area_Industrial_02ece63d_469a_493c_80f3_1629478a34c8186_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,fkComplIndustria,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Area_Industrial Output Nuker"   INPUT FEATURE_TYPE Area_Industrial

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Alter_Fisiog_Antropica_line} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Alter_Fisiog_Antropica_line_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Alter_Fisiog_Antropica_line_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Alter_Fisiog_Antropica_line_FeatureDirector    INPUT  FEATURE_TYPE Alter_Fisiog_Antropica_line    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Alter_Fisiog_Antropica_line___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Alter_Fisiog_Antropica_line___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Alter_Fisiog_Antropica_line___FeatureDirector1    INPUT FEATURE_TYPE Alter_Fisiog_Antropica_line___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Alter_Fisiog_Antropica_line___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Alter_Fisiog_Antropica_line___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Alter_Fisiog_Antropica_line_VectorSetterUpper    INPUT FEATURE_TYPE Alter_Fisiog_Antropica_line___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Alter_Fisiog_Antropica_line_02ece63d_469a_493c_80f3_1629478a34c8187_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Alter_Fisiog_Antropica_line___PointCloudThinner    INPUT FEATURE_TYPE Alter_Fisiog_Antropica_line___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Alter_Fisiog_Antropica_line_02ece63d_469a_493c_80f3_1629478a34c8187_thinPointCloud")
Tcl2 proc Alter_Fisiog_Antropica_line_02ece63d_469a_493c_80f3_1629478a34c8187_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Alter_Fisiog_Antropica_line_RasterSetterUpper    INPUT FEATURE_TYPE Alter_Fisiog_Antropica_line___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Alter_Fisiog_Antropica_line_02ece63d_469a_493c_80f3_1629478a34c8187_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Alter_Fisiog_Antropica_line_02ece63d_469a_493c_80f3_1629478a34c8187_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Alter_Fisiog_Antropica_line_02ece63d_469a_493c_80f3_1629478a34c8187_VIS_FEAT_TYPE Alter_Fisiog_Antropica_line$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Alter_Fisiog_Antropica_line_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Alter_Fisiog_Antropica_line_02ece63d_469a_493c_80f3_1629478a34c8187_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSet,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,tipoAlterAntrop,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Alter_Fisiog_Antropica_line Output Nuker"   INPUT FEATURE_TYPE Alter_Fisiog_Antropica_line

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Dep_Saneamento_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Dep_Saneamento_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Saneamento_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Dep_Saneamento_point_FeatureDirector    INPUT  FEATURE_TYPE Dep_Saneamento_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Dep_Saneamento_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Dep_Saneamento_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Dep_Saneamento_point___FeatureDirector1    INPUT FEATURE_TYPE Dep_Saneamento_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Dep_Saneamento_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Dep_Saneamento_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Saneamento_point_VectorSetterUpper    INPUT FEATURE_TYPE Dep_Saneamento_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Dep_Saneamento_point_02ece63d_469a_493c_80f3_1629478a34c8188_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Saneamento_point___PointCloudThinner    INPUT FEATURE_TYPE Dep_Saneamento_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Dep_Saneamento_point_02ece63d_469a_493c_80f3_1629478a34c8188_thinPointCloud")
Tcl2 proc Dep_Saneamento_point_02ece63d_469a_493c_80f3_1629478a34c8188_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Saneamento_point_RasterSetterUpper    INPUT FEATURE_TYPE Dep_Saneamento_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Dep_Saneamento_point_02ece63d_469a_493c_80f3_1629478a34c8188_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Dep_Saneamento_point_02ece63d_469a_493c_80f3_1629478a34c8188_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Dep_Saneamento_point_02ece63d_469a_493c_80f3_1629478a34c8188_VIS_FEAT_TYPE Dep_Saneamento_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Dep_Saneamento_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Dep_Saneamento_point_02ece63d_469a_493c_80f3_1629478a34c8188_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,fkComplSaneam,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,residuo,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,finalidade,varchar<openparen>255<closeparen>,construcao,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,tipoDepSaneam,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,tipoResiduo,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Dep_Saneamento_point Output Nuker"   INPUT FEATURE_TYPE Dep_Saneamento_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Pub_Militar_polygon} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Pub_Militar_polygon_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Militar_polygon_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Pub_Militar_polygon_FeatureDirector    INPUT  FEATURE_TYPE Edif_Pub_Militar_polygon    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Pub_Militar_polygon___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Pub_Militar_polygon___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Pub_Militar_polygon___FeatureDirector1    INPUT FEATURE_TYPE Edif_Pub_Militar_polygon___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Pub_Militar_polygon___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Pub_Militar_polygon___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Militar_polygon_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Pub_Militar_polygon___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Pub_Militar_polygon_02ece63d_469a_493c_80f3_1629478a34c8189_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Militar_polygon___PointCloudThinner    INPUT FEATURE_TYPE Edif_Pub_Militar_polygon___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Pub_Militar_polygon_02ece63d_469a_493c_80f3_1629478a34c8189_thinPointCloud")
Tcl2 proc Edif_Pub_Militar_polygon_02ece63d_469a_493c_80f3_1629478a34c8189_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Militar_polygon_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Pub_Militar_polygon___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Pub_Militar_polygon_02ece63d_469a_493c_80f3_1629478a34c8189_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Pub_Militar_polygon_02ece63d_469a_493c_80f3_1629478a34c8189_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Pub_Militar_polygon_02ece63d_469a_493c_80f3_1629478a34c8189_VIS_FEAT_TYPE Edif_Pub_Militar_polygon$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Pub_Militar_polygon_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Pub_Militar_polygon_02ece63d_469a_493c_80f3_1629478a34c8189_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,fkComplMilitar,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,tipoEdif,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,tipoUsoEdif,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Pub_Militar_polygon Output Nuker"   INPUT FEATURE_TYPE Edif_Pub_Militar_polygon

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Saude_polygon_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Saude_polygon_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saude_polygon_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Saude_polygon_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Saude_polygon_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Saude_polygon_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Saude_polygon_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Saude_polygon_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Saude_polygon_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Saude_polygon_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Saude_polygon_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saude_polygon_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Saude_polygon_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Saude_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8190_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saude_polygon_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Saude_polygon_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Saude_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8190_thinPointCloud")
Tcl2 proc Edif_Saude_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8190_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Saude_polygon_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Saude_polygon_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Saude_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8190_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Saude_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8190_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Saude_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8190_VIS_FEAT_TYPE Edif_Saude_polygon_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Saude_polygon_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Saude_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8190_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Saude_polygon_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Saude_polygon_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Antena_Comunic} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Antena_Comunic_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Antena_Comunic_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Antena_Comunic_FeatureDirector    INPUT  FEATURE_TYPE Antena_Comunic    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Antena_Comunic___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Antena_Comunic___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Antena_Comunic___FeatureDirector1    INPUT FEATURE_TYPE Antena_Comunic___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Antena_Comunic___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Antena_Comunic___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Antena_Comunic_VectorSetterUpper    INPUT FEATURE_TYPE Antena_Comunic___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Antena_Comunic_02ece63d_469a_493c_80f3_1629478a34c8191_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Antena_Comunic___PointCloudThinner    INPUT FEATURE_TYPE Antena_Comunic___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Antena_Comunic_02ece63d_469a_493c_80f3_1629478a34c8191_thinPointCloud")
Tcl2 proc Antena_Comunic_02ece63d_469a_493c_80f3_1629478a34c8191_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Antena_Comunic_RasterSetterUpper    INPUT FEATURE_TYPE Antena_Comunic___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Antena_Comunic_02ece63d_469a_493c_80f3_1629478a34c8191_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Antena_Comunic_02ece63d_469a_493c_80f3_1629478a34c8191_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Antena_Comunic_02ece63d_469a_493c_80f3_1629478a34c8191_VIS_FEAT_TYPE Antena_Comunic$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Antena_Comunic_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Antena_Comunic_02ece63d_469a_493c_80f3_1629478a34c8191_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,fkComplComunic,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,posicaoRelEdific,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Antena_Comunic Output Nuker"   INPUT FEATURE_TYPE Antena_Comunic

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Cemiterio_polygon_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Cemiterio_polygon_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Cemiterio_polygon_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Cemiterio_polygon_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Cemiterio_polygon_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Cemiterio_polygon_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Cemiterio_polygon_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Cemiterio_polygon_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Cemiterio_polygon_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Cemiterio_polygon_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Cemiterio_polygon_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Cemiterio_polygon_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Cemiterio_polygon_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Cemiterio_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8192_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Cemiterio_polygon_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Cemiterio_polygon_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Cemiterio_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8192_thinPointCloud")
Tcl2 proc Cemiterio_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8192_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Cemiterio_polygon_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Cemiterio_polygon_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Cemiterio_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8192_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Cemiterio_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8192_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Cemiterio_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8192_VIS_FEAT_TYPE Cemiterio_polygon_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Cemiterio_polygon_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Cemiterio_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8192_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Cemiterio_polygon_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Cemiterio_polygon_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {T_1_PolyErrors} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME T_1_PolyErrors_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_PolyErrors_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME T_1_PolyErrors_FeatureDirector    INPUT  FEATURE_TYPE T_1_PolyErrors    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE T_1_PolyErrors___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE T_1_PolyErrors___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME T_1_PolyErrors___FeatureDirector1    INPUT FEATURE_TYPE T_1_PolyErrors___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE T_1_PolyErrors___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE T_1_PolyErrors___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_PolyErrors_VectorSetterUpper    INPUT FEATURE_TYPE T_1_PolyErrors___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc T_1_PolyErrors_02ece63d_469a_493c_80f3_1629478a34c8193_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_PolyErrors___PointCloudThinner    INPUT FEATURE_TYPE T_1_PolyErrors___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("T_1_PolyErrors_02ece63d_469a_493c_80f3_1629478a34c8193_thinPointCloud")
Tcl2 proc T_1_PolyErrors_02ece63d_469a_493c_80f3_1629478a34c8193_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_PolyErrors_RasterSetterUpper    INPUT FEATURE_TYPE T_1_PolyErrors___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("T_1_PolyErrors_02ece63d_469a_493c_80f3_1629478a34c8193_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# T_1_PolyErrors_02ece63d_469a_493c_80f3_1629478a34c8193_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO T_1_PolyErrors_02ece63d_469a_493c_80f3_1629478a34c8193_VIS_FEAT_TYPE T_1_PolyErrors$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME T_1_PolyErrors_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(T_1_PolyErrors_02ece63d_469a_493c_80f3_1629478a34c8193_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA ObjectID,varchar<openparen>255<closeparen>,OriginClassID,varchar<openparen>255<closeparen>,OriginID,varchar<openparen>255<closeparen>,DestClassID,varchar<openparen>255<closeparen>,DestID,varchar<openparen>255<closeparen>,TopoRuleType,varchar<openparen>255<closeparen>,TopoRuleID,varchar<openparen>255<closeparen>,Shape,varchar<openparen>255<closeparen>,IsException,varchar<openparen>255<closeparen>,Shape_Length,varchar<openparen>255<closeparen>,Shape_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "T_1_PolyErrors Output Nuker"   INPUT FEATURE_TYPE T_1_PolyErrors

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Ponto_Inicio_Drenagem} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Ponto_Inicio_Drenagem_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Inicio_Drenagem_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Inicio_Drenagem_FeatureDirector    INPUT  FEATURE_TYPE Ponto_Inicio_Drenagem    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Ponto_Inicio_Drenagem___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Inicio_Drenagem___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Inicio_Drenagem___FeatureDirector1    INPUT FEATURE_TYPE Ponto_Inicio_Drenagem___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Ponto_Inicio_Drenagem___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Inicio_Drenagem___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Inicio_Drenagem_VectorSetterUpper    INPUT FEATURE_TYPE Ponto_Inicio_Drenagem___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Ponto_Inicio_Drenagem_02ece63d_469a_493c_80f3_1629478a34c8194_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Inicio_Drenagem___PointCloudThinner    INPUT FEATURE_TYPE Ponto_Inicio_Drenagem___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Inicio_Drenagem_02ece63d_469a_493c_80f3_1629478a34c8194_thinPointCloud")
Tcl2 proc Ponto_Inicio_Drenagem_02ece63d_469a_493c_80f3_1629478a34c8194_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Inicio_Drenagem_RasterSetterUpper    INPUT FEATURE_TYPE Ponto_Inicio_Drenagem___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Inicio_Drenagem_02ece63d_469a_493c_80f3_1629478a34c8194_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Ponto_Inicio_Drenagem_02ece63d_469a_493c_80f3_1629478a34c8194_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Ponto_Inicio_Drenagem_02ece63d_469a_493c_80f3_1629478a34c8194_VIS_FEAT_TYPE Ponto_Inicio_Drenagem$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Ponto_Inicio_Drenagem_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Ponto_Inicio_Drenagem_02ece63d_469a_493c_80f3_1629478a34c8194_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,nascente,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Ponto_Inicio_Drenagem Output Nuker"   INPUT FEATURE_TYPE Ponto_Inicio_Drenagem

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Entroncamento_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Entroncamento_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Entroncamento_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Entroncamento_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Entroncamento_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Entroncamento_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Entroncamento_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Entroncamento_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Entroncamento_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Entroncamento_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Entroncamento_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Entroncamento_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Entroncamento_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Entroncamento_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8195_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Entroncamento_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Entroncamento_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Entroncamento_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8195_thinPointCloud")
Tcl2 proc Entroncamento_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8195_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Entroncamento_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Entroncamento_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Entroncamento_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8195_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Entroncamento_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8195_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Entroncamento_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8195_VIS_FEAT_TYPE Entroncamento_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Entroncamento_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Entroncamento_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8195_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Entroncamento_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Entroncamento_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Industrial_polygon} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Industrial_polygon_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Industrial_polygon_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Industrial_polygon_FeatureDirector    INPUT  FEATURE_TYPE Edif_Industrial_polygon    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Industrial_polygon___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Industrial_polygon___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Industrial_polygon___FeatureDirector1    INPUT FEATURE_TYPE Edif_Industrial_polygon___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Industrial_polygon___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Industrial_polygon___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Industrial_polygon_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Industrial_polygon___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Industrial_polygon_02ece63d_469a_493c_80f3_1629478a34c8196_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Industrial_polygon___PointCloudThinner    INPUT FEATURE_TYPE Edif_Industrial_polygon___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Industrial_polygon_02ece63d_469a_493c_80f3_1629478a34c8196_thinPointCloud")
Tcl2 proc Edif_Industrial_polygon_02ece63d_469a_493c_80f3_1629478a34c8196_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Industrial_polygon_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Industrial_polygon___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Industrial_polygon_02ece63d_469a_493c_80f3_1629478a34c8196_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Industrial_polygon_02ece63d_469a_493c_80f3_1629478a34c8196_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Industrial_polygon_02ece63d_469a_493c_80f3_1629478a34c8196_VIS_FEAT_TYPE Edif_Industrial_polygon$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Industrial_polygon_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Industrial_polygon_02ece63d_469a_493c_80f3_1629478a34c8196_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,fkComplIndustria,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,chamine,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,tipoDivisaoCnae,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Industrial_polygon Output Nuker"   INPUT FEATURE_TYPE Edif_Industrial_polygon

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Constr_Est_Med_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Constr_Est_Med_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Constr_Est_Med_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Constr_Est_Med_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Constr_Est_Med_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Constr_Est_Med_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Constr_Est_Med_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Constr_Est_Med_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Constr_Est_Med_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Constr_Est_Med_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Constr_Est_Med_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Constr_Est_Med_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Constr_Est_Med_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Constr_Est_Med_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8197_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Constr_Est_Med_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Constr_Est_Med_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Constr_Est_Med_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8197_thinPointCloud")
Tcl2 proc Edif_Constr_Est_Med_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8197_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Constr_Est_Med_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Constr_Est_Med_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Constr_Est_Med_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8197_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Constr_Est_Med_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8197_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Constr_Est_Med_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8197_VIS_FEAT_TYPE Edif_Constr_Est_Med_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Constr_Est_Med_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Constr_Est_Med_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8197_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Constr_Est_Med_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Constr_Est_Med_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Trecho_Energia} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Trecho_Energia_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Energia_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Trecho_Energia_FeatureDirector    INPUT  FEATURE_TYPE Trecho_Energia    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Trecho_Energia___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Trecho_Energia___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Trecho_Energia___FeatureDirector1    INPUT FEATURE_TYPE Trecho_Energia___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Trecho_Energia___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Trecho_Energia___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Energia_VectorSetterUpper    INPUT FEATURE_TYPE Trecho_Energia___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Trecho_Energia_02ece63d_469a_493c_80f3_1629478a34c8198_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Energia___PointCloudThinner    INPUT FEATURE_TYPE Trecho_Energia___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trecho_Energia_02ece63d_469a_493c_80f3_1629478a34c8198_thinPointCloud")
Tcl2 proc Trecho_Energia_02ece63d_469a_493c_80f3_1629478a34c8198_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Energia_RasterSetterUpper    INPUT FEATURE_TYPE Trecho_Energia___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trecho_Energia_02ece63d_469a_493c_80f3_1629478a34c8198_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Trecho_Energia_02ece63d_469a_493c_80f3_1629478a34c8198_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Trecho_Energia_02ece63d_469a_493c_80f3_1629478a34c8198_VIS_FEAT_TYPE Trecho_Energia$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Trecho_Energia_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Trecho_Energia_02ece63d_469a_493c_80f3_1629478a34c8198_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,especie,varchar<openparen>255<closeparen>,posicaoRelativa,varchar<openparen>255<closeparen>,tensaoEletrica,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,numCircuitos,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,emDuto,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Trecho_Energia Output Nuker"   INPUT FEATURE_TYPE Trecho_Energia

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Rocha_polygon_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Rocha_polygon_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Rocha_polygon_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Rocha_polygon_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Rocha_polygon_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Rocha_polygon_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Rocha_polygon_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Rocha_polygon_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Rocha_polygon_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Rocha_polygon_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Rocha_polygon_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Rocha_polygon_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Rocha_polygon_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Rocha_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8199_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Rocha_polygon_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Rocha_polygon_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Rocha_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8199_thinPointCloud")
Tcl2 proc Rocha_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8199_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Rocha_polygon_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Rocha_polygon_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Rocha_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8199_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Rocha_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8199_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Rocha_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8199_VIS_FEAT_TYPE Rocha_polygon_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Rocha_polygon_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Rocha_polygon_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8199_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Rocha_polygon_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Rocha_polygon_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Trecho_Duto} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Trecho_Duto_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Duto_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Trecho_Duto_FeatureDirector    INPUT  FEATURE_TYPE Trecho_Duto    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Trecho_Duto___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Trecho_Duto___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Trecho_Duto___FeatureDirector1    INPUT FEATURE_TYPE Trecho_Duto___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Trecho_Duto___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Trecho_Duto___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Duto_VectorSetterUpper    INPUT FEATURE_TYPE Trecho_Duto___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Trecho_Duto_02ece63d_469a_493c_80f3_1629478a34c8200_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Duto___PointCloudThinner    INPUT FEATURE_TYPE Trecho_Duto___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trecho_Duto_02ece63d_469a_493c_80f3_1629478a34c8200_thinPointCloud")
Tcl2 proc Trecho_Duto_02ece63d_469a_493c_80f3_1629478a34c8200_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trecho_Duto_RasterSetterUpper    INPUT FEATURE_TYPE Trecho_Duto___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trecho_Duto_02ece63d_469a_493c_80f3_1629478a34c8200_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Trecho_Duto_02ece63d_469a_493c_80f3_1629478a34c8200_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Trecho_Duto_02ece63d_469a_493c_80f3_1629478a34c8200_VIS_FEAT_TYPE Trecho_Duto$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Trecho_Duto_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Trecho_Duto_02ece63d_469a_493c_80f3_1629478a34c8200_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,tipoTrechoDuto,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,setor,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,posicaoRelativa,varchar<openparen>255<closeparen>,situacaoEspacial,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,fkComplDuto,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,nrDutos,varchar<openparen>255<closeparen>,matTransp,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Trecho_Duto Output Nuker"   INPUT FEATURE_TYPE Trecho_Duto

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Pub_Civil_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Pub_Civil_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Civil_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Pub_Civil_point_FeatureDirector    INPUT  FEATURE_TYPE Edif_Pub_Civil_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Pub_Civil_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Pub_Civil_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Pub_Civil_point___FeatureDirector1    INPUT FEATURE_TYPE Edif_Pub_Civil_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Pub_Civil_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Pub_Civil_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Civil_point_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Pub_Civil_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Pub_Civil_point_02ece63d_469a_493c_80f3_1629478a34c8201_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Civil_point___PointCloudThinner    INPUT FEATURE_TYPE Edif_Pub_Civil_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Pub_Civil_point_02ece63d_469a_493c_80f3_1629478a34c8201_thinPointCloud")
Tcl2 proc Edif_Pub_Civil_point_02ece63d_469a_493c_80f3_1629478a34c8201_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Pub_Civil_point_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Pub_Civil_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Pub_Civil_point_02ece63d_469a_493c_80f3_1629478a34c8201_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Pub_Civil_point_02ece63d_469a_493c_80f3_1629478a34c8201_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Pub_Civil_point_02ece63d_469a_493c_80f3_1629478a34c8201_VIS_FEAT_TYPE Edif_Pub_Civil_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Pub_Civil_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Pub_Civil_point_02ece63d_469a_493c_80f3_1629478a34c8201_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,fkComplPubCivil,varchar<openparen>255<closeparen>,tipoEdif,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,tipoUsoEdif,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Pub_Civil_point Output Nuker"   INPUT FEATURE_TYPE Edif_Pub_Civil_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Campo_Quadra_polygon} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Campo_Quadra_polygon_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_Quadra_polygon_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Campo_Quadra_polygon_FeatureDirector    INPUT  FEATURE_TYPE Campo_Quadra_polygon    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Campo_Quadra_polygon___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Campo_Quadra_polygon___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Campo_Quadra_polygon___FeatureDirector1    INPUT FEATURE_TYPE Campo_Quadra_polygon___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Campo_Quadra_polygon___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Campo_Quadra_polygon___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_Quadra_polygon_VectorSetterUpper    INPUT FEATURE_TYPE Campo_Quadra_polygon___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Campo_Quadra_polygon_02ece63d_469a_493c_80f3_1629478a34c8202_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_Quadra_polygon___PointCloudThinner    INPUT FEATURE_TYPE Campo_Quadra_polygon___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Campo_Quadra_polygon_02ece63d_469a_493c_80f3_1629478a34c8202_thinPointCloud")
Tcl2 proc Campo_Quadra_polygon_02ece63d_469a_493c_80f3_1629478a34c8202_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Campo_Quadra_polygon_RasterSetterUpper    INPUT FEATURE_TYPE Campo_Quadra_polygon___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Campo_Quadra_polygon_02ece63d_469a_493c_80f3_1629478a34c8202_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Campo_Quadra_polygon_02ece63d_469a_493c_80f3_1629478a34c8202_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Campo_Quadra_polygon_02ece63d_469a_493c_80f3_1629478a34c8202_VIS_FEAT_TYPE Campo_Quadra_polygon$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Campo_Quadra_polygon_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Campo_Quadra_polygon_02ece63d_469a_493c_80f3_1629478a34c8202_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,fkComplLazer,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,tipoCampoQuadra,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Campo_Quadra_polygon Output Nuker"   INPUT FEATURE_TYPE Campo_Quadra_polygon

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Ensino_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Ensino_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ensino_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Ensino_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Ensino_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Ensino_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Ensino_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Ensino_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Ensino_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Ensino_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Ensino_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ensino_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Ensino_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Ensino_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8203_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ensino_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Ensino_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Ensino_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8203_thinPointCloud")
Tcl2 proc Edif_Ensino_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8203_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Ensino_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Ensino_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Ensino_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8203_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Ensino_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8203_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Ensino_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8203_VIS_FEAT_TYPE Edif_Ensino_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Ensino_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Ensino_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8203_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Ensino_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Ensino_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Ponto_Inicio_Drenagem_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Ponto_Inicio_Drenagem_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Inicio_Drenagem_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Inicio_Drenagem_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Ponto_Inicio_Drenagem_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Ponto_Inicio_Drenagem_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Inicio_Drenagem_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Ponto_Inicio_Drenagem_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Ponto_Inicio_Drenagem_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Ponto_Inicio_Drenagem_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Ponto_Inicio_Drenagem_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Inicio_Drenagem_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Ponto_Inicio_Drenagem_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Ponto_Inicio_Drenagem_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8204_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Inicio_Drenagem_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Ponto_Inicio_Drenagem_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Inicio_Drenagem_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8204_thinPointCloud")
Tcl2 proc Ponto_Inicio_Drenagem_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8204_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponto_Inicio_Drenagem_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Ponto_Inicio_Drenagem_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponto_Inicio_Drenagem_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8204_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Ponto_Inicio_Drenagem_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8204_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Ponto_Inicio_Drenagem_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8204_VIS_FEAT_TYPE Ponto_Inicio_Drenagem_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Ponto_Inicio_Drenagem_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Ponto_Inicio_Drenagem_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8204_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Ponto_Inicio_Drenagem_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Ponto_Inicio_Drenagem_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Posto_Combustivel_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Posto_Combustivel_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Posto_Combustivel_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Posto_Combustivel_point_FeatureDirector    INPUT  FEATURE_TYPE Posto_Combustivel_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Posto_Combustivel_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Posto_Combustivel_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Posto_Combustivel_point___FeatureDirector1    INPUT FEATURE_TYPE Posto_Combustivel_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Posto_Combustivel_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Posto_Combustivel_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Posto_Combustivel_point_VectorSetterUpper    INPUT FEATURE_TYPE Posto_Combustivel_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Posto_Combustivel_point_02ece63d_469a_493c_80f3_1629478a34c8205_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Posto_Combustivel_point___PointCloudThinner    INPUT FEATURE_TYPE Posto_Combustivel_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Posto_Combustivel_point_02ece63d_469a_493c_80f3_1629478a34c8205_thinPointCloud")
Tcl2 proc Posto_Combustivel_point_02ece63d_469a_493c_80f3_1629478a34c8205_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Posto_Combustivel_point_RasterSetterUpper    INPUT FEATURE_TYPE Posto_Combustivel_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Posto_Combustivel_point_02ece63d_469a_493c_80f3_1629478a34c8205_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Posto_Combustivel_point_02ece63d_469a_493c_80f3_1629478a34c8205_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Posto_Combustivel_point_02ece63d_469a_493c_80f3_1629478a34c8205_VIS_FEAT_TYPE Posto_Combustivel_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Posto_Combustivel_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Posto_Combustivel_point_02ece63d_469a_493c_80f3_1629478a34c8205_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,administracao,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,fkComplEstrApoio,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Posto_Combustivel_point Output Nuker"   INPUT FEATURE_TYPE Posto_Combustivel_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Fonte_Dagua} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Fonte_Dagua_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Fonte_Dagua_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Fonte_Dagua_FeatureDirector    INPUT  FEATURE_TYPE Fonte_Dagua    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Fonte_Dagua___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Fonte_Dagua___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Fonte_Dagua___FeatureDirector1    INPUT FEATURE_TYPE Fonte_Dagua___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Fonte_Dagua___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Fonte_Dagua___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Fonte_Dagua_VectorSetterUpper    INPUT FEATURE_TYPE Fonte_Dagua___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Fonte_Dagua_02ece63d_469a_493c_80f3_1629478a34c8206_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Fonte_Dagua___PointCloudThinner    INPUT FEATURE_TYPE Fonte_Dagua___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Fonte_Dagua_02ece63d_469a_493c_80f3_1629478a34c8206_thinPointCloud")
Tcl2 proc Fonte_Dagua_02ece63d_469a_493c_80f3_1629478a34c8206_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Fonte_Dagua_RasterSetterUpper    INPUT FEATURE_TYPE Fonte_Dagua___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Fonte_Dagua_02ece63d_469a_493c_80f3_1629478a34c8206_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Fonte_Dagua_02ece63d_469a_493c_80f3_1629478a34c8206_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Fonte_Dagua_02ece63d_469a_493c_80f3_1629478a34c8206_VIS_FEAT_TYPE Fonte_Dagua$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Fonte_Dagua_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Fonte_Dagua_02ece63d_469a_493c_80f3_1629478a34c8206_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,tipoFonteDagua,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,regime,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,qualidAgua,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Fonte_Dagua Output Nuker"   INPUT FEATURE_TYPE Fonte_Dagua

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Ilha_polygon} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Ilha_polygon_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Ilha_polygon_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Ilha_polygon_FeatureDirector    INPUT  FEATURE_TYPE Ilha_polygon    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Ilha_polygon___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Ilha_polygon___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Ilha_polygon___FeatureDirector1    INPUT FEATURE_TYPE Ilha_polygon___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Ilha_polygon___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Ilha_polygon___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Ilha_polygon_VectorSetterUpper    INPUT FEATURE_TYPE Ilha_polygon___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Ilha_polygon_02ece63d_469a_493c_80f3_1629478a34c8207_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ilha_polygon___PointCloudThinner    INPUT FEATURE_TYPE Ilha_polygon___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ilha_polygon_02ece63d_469a_493c_80f3_1629478a34c8207_thinPointCloud")
Tcl2 proc Ilha_polygon_02ece63d_469a_493c_80f3_1629478a34c8207_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ilha_polygon_RasterSetterUpper    INPUT FEATURE_TYPE Ilha_polygon___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ilha_polygon_02ece63d_469a_493c_80f3_1629478a34c8207_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Ilha_polygon_02ece63d_469a_493c_80f3_1629478a34c8207_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Ilha_polygon_02ece63d_469a_493c_80f3_1629478a34c8207_VIS_FEAT_TYPE Ilha_polygon$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Ilha_polygon_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Ilha_polygon_02ece63d_469a_493c_80f3_1629478a34c8207_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,tamanhoTxt,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,tipoElemNat,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Ilha_polygon Output Nuker"   INPUT FEATURE_TYPE Ilha_polygon

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {T_1_DirtyAreas_DirtyArea_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME T_1_DirtyAreas_DirtyArea_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_DirtyAreas_DirtyArea_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME T_1_DirtyAreas_DirtyArea_Index_FeatureDirector    INPUT  FEATURE_TYPE T_1_DirtyAreas_DirtyArea_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE T_1_DirtyAreas_DirtyArea_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE T_1_DirtyAreas_DirtyArea_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME T_1_DirtyAreas_DirtyArea_Index___FeatureDirector1    INPUT FEATURE_TYPE T_1_DirtyAreas_DirtyArea_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE T_1_DirtyAreas_DirtyArea_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE T_1_DirtyAreas_DirtyArea_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_DirtyAreas_DirtyArea_Index_VectorSetterUpper    INPUT FEATURE_TYPE T_1_DirtyAreas_DirtyArea_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc T_1_DirtyAreas_DirtyArea_Index_02ece63d_469a_493c_80f3_1629478a34c8208_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_DirtyAreas_DirtyArea_Index___PointCloudThinner    INPUT FEATURE_TYPE T_1_DirtyAreas_DirtyArea_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("T_1_DirtyAreas_DirtyArea_Index_02ece63d_469a_493c_80f3_1629478a34c8208_thinPointCloud")
Tcl2 proc T_1_DirtyAreas_DirtyArea_Index_02ece63d_469a_493c_80f3_1629478a34c8208_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_DirtyAreas_DirtyArea_Index_RasterSetterUpper    INPUT FEATURE_TYPE T_1_DirtyAreas_DirtyArea_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("T_1_DirtyAreas_DirtyArea_Index_02ece63d_469a_493c_80f3_1629478a34c8208_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# T_1_DirtyAreas_DirtyArea_Index_02ece63d_469a_493c_80f3_1629478a34c8208_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO T_1_DirtyAreas_DirtyArea_Index_02ece63d_469a_493c_80f3_1629478a34c8208_VIS_FEAT_TYPE T_1_DirtyAreas_DirtyArea_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME T_1_DirtyAreas_DirtyArea_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(T_1_DirtyAreas_DirtyArea_Index_02ece63d_469a_493c_80f3_1629478a34c8208_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "T_1_DirtyAreas_DirtyArea_Index Output Nuker"   INPUT FEATURE_TYPE T_1_DirtyAreas_DirtyArea_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Barragem_line_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Barragem_line_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Barragem_line_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Barragem_line_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Barragem_line_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Barragem_line_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Barragem_line_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Barragem_line_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Barragem_line_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Barragem_line_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Barragem_line_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Barragem_line_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Barragem_line_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Barragem_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8209_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Barragem_line_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Barragem_line_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Barragem_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8209_thinPointCloud")
Tcl2 proc Barragem_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8209_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Barragem_line_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Barragem_line_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Barragem_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8209_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Barragem_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8209_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Barragem_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8209_VIS_FEAT_TYPE Barragem_line_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Barragem_line_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Barragem_line_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8209_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Barragem_line_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Barragem_line_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Sumidouro_Vertedouro} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Sumidouro_Vertedouro_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Sumidouro_Vertedouro_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Sumidouro_Vertedouro_FeatureDirector    INPUT  FEATURE_TYPE Sumidouro_Vertedouro    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Sumidouro_Vertedouro___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Sumidouro_Vertedouro___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Sumidouro_Vertedouro___FeatureDirector1    INPUT FEATURE_TYPE Sumidouro_Vertedouro___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Sumidouro_Vertedouro___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Sumidouro_Vertedouro___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Sumidouro_Vertedouro_VectorSetterUpper    INPUT FEATURE_TYPE Sumidouro_Vertedouro___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Sumidouro_Vertedouro_02ece63d_469a_493c_80f3_1629478a34c8210_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Sumidouro_Vertedouro___PointCloudThinner    INPUT FEATURE_TYPE Sumidouro_Vertedouro___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Sumidouro_Vertedouro_02ece63d_469a_493c_80f3_1629478a34c8210_thinPointCloud")
Tcl2 proc Sumidouro_Vertedouro_02ece63d_469a_493c_80f3_1629478a34c8210_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Sumidouro_Vertedouro_RasterSetterUpper    INPUT FEATURE_TYPE Sumidouro_Vertedouro___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Sumidouro_Vertedouro_02ece63d_469a_493c_80f3_1629478a34c8210_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Sumidouro_Vertedouro_02ece63d_469a_493c_80f3_1629478a34c8210_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Sumidouro_Vertedouro_02ece63d_469a_493c_80f3_1629478a34c8210_VIS_FEAT_TYPE Sumidouro_Vertedouro$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Sumidouro_Vertedouro_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Sumidouro_Vertedouro_02ece63d_469a_493c_80f3_1629478a34c8210_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,tipoSumVert,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,causa,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Sumidouro_Vertedouro Output Nuker"   INPUT FEATURE_TYPE Sumidouro_Vertedouro

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Dep_Saneamento_polygon} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Dep_Saneamento_polygon_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Saneamento_polygon_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Dep_Saneamento_polygon_FeatureDirector    INPUT  FEATURE_TYPE Dep_Saneamento_polygon    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Dep_Saneamento_polygon___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Dep_Saneamento_polygon___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Dep_Saneamento_polygon___FeatureDirector1    INPUT FEATURE_TYPE Dep_Saneamento_polygon___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Dep_Saneamento_polygon___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Dep_Saneamento_polygon___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Saneamento_polygon_VectorSetterUpper    INPUT FEATURE_TYPE Dep_Saneamento_polygon___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Dep_Saneamento_polygon_02ece63d_469a_493c_80f3_1629478a34c8211_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Saneamento_polygon___PointCloudThinner    INPUT FEATURE_TYPE Dep_Saneamento_polygon___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Dep_Saneamento_polygon_02ece63d_469a_493c_80f3_1629478a34c8211_thinPointCloud")
Tcl2 proc Dep_Saneamento_polygon_02ece63d_469a_493c_80f3_1629478a34c8211_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Saneamento_polygon_RasterSetterUpper    INPUT FEATURE_TYPE Dep_Saneamento_polygon___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Dep_Saneamento_polygon_02ece63d_469a_493c_80f3_1629478a34c8211_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Dep_Saneamento_polygon_02ece63d_469a_493c_80f3_1629478a34c8211_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Dep_Saneamento_polygon_02ece63d_469a_493c_80f3_1629478a34c8211_VIS_FEAT_TYPE Dep_Saneamento_polygon$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Dep_Saneamento_polygon_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Dep_Saneamento_polygon_02ece63d_469a_493c_80f3_1629478a34c8211_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,fkComplSaneam,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,residuo,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,finalidade,varchar<openparen>255<closeparen>,construcao,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,tipoDepSaneam,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,tipoResiduo,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Dep_Saneamento_polygon Output Nuker"   INPUT FEATURE_TYPE Dep_Saneamento_polygon

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Galeria_Bueiro_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Galeria_Bueiro_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Galeria_Bueiro_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Galeria_Bueiro_point_FeatureDirector    INPUT  FEATURE_TYPE Galeria_Bueiro_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Galeria_Bueiro_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Galeria_Bueiro_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Galeria_Bueiro_point___FeatureDirector1    INPUT FEATURE_TYPE Galeria_Bueiro_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Galeria_Bueiro_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Galeria_Bueiro_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Galeria_Bueiro_point_VectorSetterUpper    INPUT FEATURE_TYPE Galeria_Bueiro_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Galeria_Bueiro_point_02ece63d_469a_493c_80f3_1629478a34c8212_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Galeria_Bueiro_point___PointCloudThinner    INPUT FEATURE_TYPE Galeria_Bueiro_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Galeria_Bueiro_point_02ece63d_469a_493c_80f3_1629478a34c8212_thinPointCloud")
Tcl2 proc Galeria_Bueiro_point_02ece63d_469a_493c_80f3_1629478a34c8212_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Galeria_Bueiro_point_RasterSetterUpper    INPUT FEATURE_TYPE Galeria_Bueiro_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Galeria_Bueiro_point_02ece63d_469a_493c_80f3_1629478a34c8212_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Galeria_Bueiro_point_02ece63d_469a_493c_80f3_1629478a34c8212_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Galeria_Bueiro_point_02ece63d_469a_493c_80f3_1629478a34c8212_VIS_FEAT_TYPE Galeria_Bueiro_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Galeria_Bueiro_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Galeria_Bueiro_point_02ece63d_469a_493c_80f3_1629478a34c8212_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,pesoMaxSuportTon,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Galeria_Bueiro_point Output Nuker"   INPUT FEATURE_TYPE Galeria_Bueiro_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Rocha_polygon} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Rocha_polygon_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Rocha_polygon_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Rocha_polygon_FeatureDirector    INPUT  FEATURE_TYPE Rocha_polygon    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Rocha_polygon___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Rocha_polygon___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Rocha_polygon___FeatureDirector1    INPUT FEATURE_TYPE Rocha_polygon___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Rocha_polygon___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Rocha_polygon___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Rocha_polygon_VectorSetterUpper    INPUT FEATURE_TYPE Rocha_polygon___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Rocha_polygon_02ece63d_469a_493c_80f3_1629478a34c8213_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Rocha_polygon___PointCloudThinner    INPUT FEATURE_TYPE Rocha_polygon___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Rocha_polygon_02ece63d_469a_493c_80f3_1629478a34c8213_thinPointCloud")
Tcl2 proc Rocha_polygon_02ece63d_469a_493c_80f3_1629478a34c8213_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Rocha_polygon_RasterSetterUpper    INPUT FEATURE_TYPE Rocha_polygon___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Rocha_polygon_02ece63d_469a_493c_80f3_1629478a34c8213_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Rocha_polygon_02ece63d_469a_493c_80f3_1629478a34c8213_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Rocha_polygon_02ece63d_469a_493c_80f3_1629478a34c8213_VIS_FEAT_TYPE Rocha_polygon$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Rocha_polygon_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Rocha_polygon_02ece63d_469a_493c_80f3_1629478a34c8213_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,tamanhoTxt,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,tipoElemNat,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>,SHAPE_Length,varchar<openparen>255<closeparen>,SHAPE_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Rocha_polygon Output Nuker"   INPUT FEATURE_TYPE Rocha_polygon

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Deposito_Geral_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Deposito_Geral_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Deposito_Geral_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Deposito_Geral_point_FeatureDirector    INPUT  FEATURE_TYPE Deposito_Geral_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Deposito_Geral_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Deposito_Geral_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Deposito_Geral_point___FeatureDirector1    INPUT FEATURE_TYPE Deposito_Geral_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Deposito_Geral_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Deposito_Geral_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Deposito_Geral_point_VectorSetterUpper    INPUT FEATURE_TYPE Deposito_Geral_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Deposito_Geral_point_02ece63d_469a_493c_80f3_1629478a34c8214_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Deposito_Geral_point___PointCloudThinner    INPUT FEATURE_TYPE Deposito_Geral_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Deposito_Geral_point_02ece63d_469a_493c_80f3_1629478a34c8214_thinPointCloud")
Tcl2 proc Deposito_Geral_point_02ece63d_469a_493c_80f3_1629478a34c8214_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Deposito_Geral_point_RasterSetterUpper    INPUT FEATURE_TYPE Deposito_Geral_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Deposito_Geral_point_02ece63d_469a_493c_80f3_1629478a34c8214_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Deposito_Geral_point_02ece63d_469a_493c_80f3_1629478a34c8214_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Deposito_Geral_point_02ece63d_469a_493c_80f3_1629478a34c8214_VIS_FEAT_TYPE Deposito_Geral_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Deposito_Geral_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Deposito_Geral_point_02ece63d_469a_493c_80f3_1629478a34c8214_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,tipoExposicao,varchar<openparen>255<closeparen>,fkComplOrgExtMin,varchar<openparen>255<closeparen>,fkComplAeroport,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,tipoProdutoResiduo,varchar<openparen>255<closeparen>,tipoConteudo,varchar<openparen>255<closeparen>,valorVolume,varchar<openparen>255<closeparen>,fkComplOrgComSv,varchar<openparen>255<closeparen>,tratamento,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,fkComplIndustria,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,operacional,varchar<openparen>255<closeparen>,offSetSimbX,varchar<openparen>255<closeparen>,situacaoFisica,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,fkComplPortuario,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,offSetSimbY,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,fkComplGerEnEletr,varchar<openparen>255<closeparen>,fkComplOrgAgrop,varchar<openparen>255<closeparen>,orientacao,varchar<openparen>255<closeparen>,matConstr,varchar<openparen>255<closeparen>,tipoDepGeral,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,fkComplEstrApoio,varchar<openparen>255<closeparen>,unidadeVolume,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,escalaMaxSimbolizar,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Deposito_Geral_point Output Nuker"   INPUT FEATURE_TYPE Deposito_Geral_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {T_1_DirtyAreas} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME T_1_DirtyAreas_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_DirtyAreas_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME T_1_DirtyAreas_FeatureDirector    INPUT  FEATURE_TYPE T_1_DirtyAreas    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE T_1_DirtyAreas___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE T_1_DirtyAreas___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME T_1_DirtyAreas___FeatureDirector1    INPUT FEATURE_TYPE T_1_DirtyAreas___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE T_1_DirtyAreas___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE T_1_DirtyAreas___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_DirtyAreas_VectorSetterUpper    INPUT FEATURE_TYPE T_1_DirtyAreas___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc T_1_DirtyAreas_02ece63d_469a_493c_80f3_1629478a34c8215_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_DirtyAreas___PointCloudThinner    INPUT FEATURE_TYPE T_1_DirtyAreas___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("T_1_DirtyAreas_02ece63d_469a_493c_80f3_1629478a34c8215_thinPointCloud")
Tcl2 proc T_1_DirtyAreas_02ece63d_469a_493c_80f3_1629478a34c8215_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME T_1_DirtyAreas_RasterSetterUpper    INPUT FEATURE_TYPE T_1_DirtyAreas___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("T_1_DirtyAreas_02ece63d_469a_493c_80f3_1629478a34c8215_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# T_1_DirtyAreas_02ece63d_469a_493c_80f3_1629478a34c8215_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO T_1_DirtyAreas_02ece63d_469a_493c_80f3_1629478a34c8215_VIS_FEAT_TYPE T_1_DirtyAreas$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME T_1_DirtyAreas_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(T_1_DirtyAreas_02ece63d_469a_493c_80f3_1629478a34c8215_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA ObjectID,varchar<openparen>255<closeparen>,IsRetired,varchar<openparen>255<closeparen>,DirtyArea,varchar<openparen>255<closeparen>,DirtyArea_Length,varchar<openparen>255<closeparen>,DirtyArea_Area,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "T_1_DirtyAreas Output Nuker"   INPUT FEATURE_TYPE T_1_DirtyAreas

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Elemento_Fisiog_Natural_point} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Elemento_Fisiog_Natural_point_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Elemento_Fisiog_Natural_point_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Elemento_Fisiog_Natural_point_FeatureDirector    INPUT  FEATURE_TYPE Elemento_Fisiog_Natural_point    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Elemento_Fisiog_Natural_point___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Elemento_Fisiog_Natural_point___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Elemento_Fisiog_Natural_point___FeatureDirector1    INPUT FEATURE_TYPE Elemento_Fisiog_Natural_point___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Elemento_Fisiog_Natural_point___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Elemento_Fisiog_Natural_point___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Elemento_Fisiog_Natural_point_VectorSetterUpper    INPUT FEATURE_TYPE Elemento_Fisiog_Natural_point___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Elemento_Fisiog_Natural_point_02ece63d_469a_493c_80f3_1629478a34c8216_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Elemento_Fisiog_Natural_point___PointCloudThinner    INPUT FEATURE_TYPE Elemento_Fisiog_Natural_point___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Elemento_Fisiog_Natural_point_02ece63d_469a_493c_80f3_1629478a34c8216_thinPointCloud")
Tcl2 proc Elemento_Fisiog_Natural_point_02ece63d_469a_493c_80f3_1629478a34c8216_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Elemento_Fisiog_Natural_point_RasterSetterUpper    INPUT FEATURE_TYPE Elemento_Fisiog_Natural_point___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Elemento_Fisiog_Natural_point_02ece63d_469a_493c_80f3_1629478a34c8216_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Elemento_Fisiog_Natural_point_02ece63d_469a_493c_80f3_1629478a34c8216_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Elemento_Fisiog_Natural_point_02ece63d_469a_493c_80f3_1629478a34c8216_VIS_FEAT_TYPE Elemento_Fisiog_Natural_point$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Elemento_Fisiog_Natural_point_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Elemento_Fisiog_Natural_point_02ece63d_469a_493c_80f3_1629478a34c8216_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA OBJECTID,varchar<openparen>255<closeparen>,SHAPE,varchar<openparen>255<closeparen>,controleId,varchar<openparen>255<closeparen>,tamanhoTxt,varchar<openparen>255<closeparen>,justTxt,varchar<openparen>255<closeparen>,tipoElemNat,varchar<openparen>255<closeparen>,offSetY,varchar<openparen>255<closeparen>,nomeAbrev,varchar<openparen>255<closeparen>,geometriaAproximada,varchar<openparen>255<closeparen>,simbolizarCartaMini,varchar<openparen>255<closeparen>,nome,varchar<openparen>255<closeparen>,offSetX,varchar<openparen>255<closeparen>,obsAquisicao,varchar<openparen>255<closeparen>,fkClassificador,varchar<openparen>255<closeparen>,controle_id,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Elemento_Fisiog_Natural_point Output Nuker"   INPUT FEATURE_TYPE Elemento_Fisiog_Natural_point

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Ponte_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Ponte_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponte_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Ponte_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Ponte_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Ponte_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Ponte_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Ponte_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Ponte_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Ponte_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Ponte_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Ponte_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Ponte_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Ponte_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8217_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponte_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Ponte_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponte_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8217_thinPointCloud")
Tcl2 proc Ponte_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8217_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Ponte_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Ponte_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Ponte_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8217_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Ponte_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8217_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Ponte_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8217_VIS_FEAT_TYPE Ponte_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Ponte_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Ponte_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8217_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Ponte_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Ponte_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8218_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8218_thinPointCloud")
Tcl2 proc Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8218_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8218_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8218_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8218_VIS_FEAT_TYPE Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8218_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Dep_Saneamento_point_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Dep_Saneamento_point_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Saneamento_point_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Dep_Saneamento_point_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Dep_Saneamento_point_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Dep_Saneamento_point_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Dep_Saneamento_point_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Dep_Saneamento_point_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Dep_Saneamento_point_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Dep_Saneamento_point_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Dep_Saneamento_point_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Saneamento_point_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Dep_Saneamento_point_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Dep_Saneamento_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8219_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Saneamento_point_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Dep_Saneamento_point_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Dep_Saneamento_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8219_thinPointCloud")
Tcl2 proc Dep_Saneamento_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8219_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Dep_Saneamento_point_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Dep_Saneamento_point_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Dep_Saneamento_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8219_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Dep_Saneamento_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8219_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Dep_Saneamento_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8219_VIS_FEAT_TYPE Dep_Saneamento_point_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Dep_Saneamento_point_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Dep_Saneamento_point_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8219_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Dep_Saneamento_point_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Dep_Saneamento_point_SHAPE_Index

# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.

READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Trilha_Picada_SHAPE_Index} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Trilha_Picada_SHAPE_Index_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Trilha_Picada_SHAPE_Index_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing

FACTORY_DEF * TestFactory    FACTORY_NAME Trilha_Picada_SHAPE_Index_FeatureDirector    INPUT  FEATURE_TYPE Trilha_Picada_SHAPE_Index    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Trilha_Picada_SHAPE_Index___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Trilha_Picada_SHAPE_Index___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Trilha_Picada_SHAPE_Index___FeatureDirector1    INPUT FEATURE_TYPE Trilha_Picada_SHAPE_Index___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Trilha_Picada_SHAPE_Index___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Trilha_Picada_SHAPE_Index___PointCloudFeatures___
# Vector features simply may get their colors overridden

FACTORY_DEF * TeeFactory    FACTORY_NAME Trilha_Picada_SHAPE_Index_VectorSetterUpper    INPUT FEATURE_TYPE Trilha_Picada_SHAPE_Index___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned

# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.

Tcl2 proc Trilha_Picada_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8220_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trilha_Picada_SHAPE_Index___PointCloudThinner    INPUT FEATURE_TYPE Trilha_Picada_SHAPE_Index___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trilha_Picada_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8220_thinPointCloud")
Tcl2 proc Trilha_Picada_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8220_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Trilha_Picada_SHAPE_Index_RasterSetterUpper    INPUT FEATURE_TYPE Trilha_Picada_SHAPE_Index___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Trilha_Picada_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8220_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Trilha_Picada_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8220_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.

DEFAULT_MACRO Trilha_Picada_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8220_VIS_FEAT_TYPE Trilha_Picada_SHAPE_Index$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.

FACTORY_DEF * RecorderFactory    FACTORY_NAME Trilha_Picada_SHAPE_Index_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Trilha_Picada_SHAPE_Index_02ece63d_469a_493c_80f3_1629478a34c8220_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA IndexedObjectId,varchar<openparen>255<closeparen>,MinGX,varchar<openparen>255<closeparen>,MinGY,varchar<openparen>255<closeparen>,MaxGX,varchar<openparen>255<closeparen>,MaxGY,varchar<openparen>255<closeparen>    MODE RECORD    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000

FACTORY_DEF * TeeFactory   FACTORY_NAME "Trilha_Picada_SHAPE_Index Output Nuker"   INPUT FEATURE_TYPE Trilha_Picada_SHAPE_Index
# -------------------------------------------------------------------------

FACTORY_DEF * CreationFactory   CREATE_AT_END   OUTPUT FEATURE_TYPE __NUKEME__   @TCL("if [file exists {$(WORKSPACE_TEMP_DIR)}] {set files [glob -nocomplain -directory  {$(WORKSPACE_TEMP_DIR)} -tails *.ffs];   if {[llength $files] == 1} {    set theFile {$(WORKSPACE_TEMP_DIR)/};   append theFile [lindex $files 0];   eval FME_Execute System \173\042$(FME_HOME_UNIX)/fmedatainspector\042 --visualizer --single-application --delete-on-close --no-source-prompt -f FFS $theFile & \175;  } elseif { [llength $files] == 0 } {  catch { file delete -force {$(WORKSPACE_TEMP_DIR)} };  } else {  set filesNoExt {}; set lastfile {}; foreach {fileName} [lsort $files] { set fileNoExt [string trimright $fileName {.ffs}]; if [regexp {(.*)_[0-9]*$} $fileNoExt wholething fileNoExtBase] {  if { $fileNoExtBase == $lastfile } { continue } }; set lastfile $fileNoExt; lappend filesNoExt $fileNoExt };  eval FME_Execute System \173\042$(FME_HOME_UNIX)/fmedatainspector\042 --visualizer --single-application --delete-on-close --no-source-prompt -d {$(WORKSPACE_TEMP_DIR)} -a ffs -f FFS $filesNoExt & \175; }; }; ")
FACTORY_DEF * TeeFactory   INPUT FEATURE_TYPE __NUKEME__
# -------------------------------------------------------------------------
MDB_ADO_4_DEF Dep_Abast_Agua_point   mdb_update_key_columns       ""   mdb_drop_table               NO   mdb_truncate_table           NO   mdb_table_writer_mode        UPDATE   OBJECTID                     autonumber   SHAPE                        oleobject   simbolizarCartaMini          integer   justTxt                      long   offSetY                      single   fkComplOrgExtMin             text(255)   fkComplOrgComSv              text(255)   offSetX                      single   fkComplIndustria             text(255)   controleId                   text(255)   construcao                   long   fkComplAbsAgua               text(255)   orientacao                   single   nomeAbrev                    text(255)   finalidade                   long   offSetSimbY                  single   fkComplOrgAgrop              text(255)   escalaMaxSimbolizar          long   fkClassificador              text(255)   operacional                  long   geometriaAproximada          long   obsAquisicao                 text(255)   situacaoFisica               long   situacaoAgua                 long   tipoDepAbast                 long   nome                         text(255)   offSetSimbX                  single   matConstr                    long   controle_id                  text(200)
WBROUTER_OUT_DEF Massa_Dagua_SHAPE_Index
WBROUTER_OUT_DEF T_1_PolyErrors_Shape_Index
WBROUTER_OUT_DEF Campo_SHAPE_Index
WBROUTER_OUT_DEF Edif_Religiosa_polygon_SHAPE_Index
WBROUTER_OUT_DEF Curva_Nivel_SHAPE_Index
WBROUTER_OUT_DEF Atracadouro_polygon_SHAPE_Index
WBROUTER_OUT_DEF Trecho_Rodoviario
WBROUTER_OUT_DEF Edif_Saude_point
WBROUTER_OUT_DEF Edif_Industrial_point_SHAPE_Index
WBROUTER_OUT_DEF Cidade_SHAPE_Index
WBROUTER_OUT_DEF Edif_Servico_Social_polygon
WBROUTER_OUT_DEF Pto_Est_Med_Fenomenos_SHAPE_Index
WBROUTER_OUT_DEF Terreno_Suj_Inundacao_SHAPE_Index
WBROUTER_OUT_DEF Edif_Const_Aeroportuaria_point
WBROUTER_OUT_DEF Edif_Comerc_Serv_point_SHAPE_Index
WBROUTER_OUT_DEF Area_Ext_Mineral
WBROUTER_OUT_DEF Aglomerado_Rural
WBROUTER_OUT_DEF Edif_Saneamento_point_SHAPE_Index
WBROUTER_OUT_DEF Ponto_Cotado_Altimetrico_SHAPE_Index
WBROUTER_OUT_DEF Cemiterio_polygon
WBROUTER_OUT_DEF Trecho_Massa_Dagua
WBROUTER_OUT_DEF SelectedObjects
WBROUTER_OUT_DEF Barragem_line
WBROUTER_OUT_DEF Edif_Ensino_polygon
WBROUTER_OUT_DEF Deposito_Geral_polygon
WBROUTER_OUT_DEF Atracadouro_point_SHAPE_Index
WBROUTER_OUT_DEF Dep_Abast_Agua_point
WBROUTER_OUT_DEF Edif_Const_Aeroportuaria_point_SHAPE_Index
WBROUTER_OUT_DEF Caatinga
WBROUTER_OUT_DEF Veg_Cultivada_SHAPE_Index00
WBROUTER_OUT_DEF Ponto_Duto
WBROUTER_OUT_DEF Edif_Pub_Civil_polygon
WBROUTER_OUT_DEF Edif_Ext_Mineral_point_SHAPE_Index
WBROUTER_OUT_DEF Campo_Quadra_polygon_SHAPE_Index
WBROUTER_OUT_DEF Arruamento
WBROUTER_OUT_DEF Ponto_Rodoviario_Ferrov
WBROUTER_OUT_DEF Dep_Saneamento_polygon_SHAPE_Index
WBROUTER_OUT_DEF Edif_Const_Lazer_point
WBROUTER_OUT_DEF Veg_Cultivada_SHAPE_Index
WBROUTER_OUT_DEF Ponto_Cotado_Altimetrico
WBROUTER_OUT_DEF Patio_polygon_SHAPE_Index
WBROUTER_OUT_DEF GDB_Items
WBROUTER_OUT_DEF Edif_Religiosa_point_SHAPE_Index
WBROUTER_OUT_DEF Edif_Ext_Mineral_point
WBROUTER_OUT_DEF Delimitacao_Fisica_SHAPE_Index
WBROUTER_OUT_DEF GDB_ItemTypes
WBROUTER_OUT_DEF Limite_Massa_Dagua_SHAPE_Index
WBROUTER_OUT_DEF Edif_Comunic_point_SHAPE_Index
WBROUTER_OUT_DEF GDB_ItemRelationshipTypes
WBROUTER_OUT_DEF Edif_Pub_Civil_point_SHAPE_Index
WBROUTER_OUT_DEF Edif_Saneamento_point
WBROUTER_OUT_DEF Cidade
WBROUTER_OUT_DEF Banco_Areia_polygon
WBROUTER_OUT_DEF Veg_Cultivada
WBROUTER_OUT_DEF Edif_Religiosa_point
WBROUTER_OUT_DEF Limite_Massa_Dagua
WBROUTER_OUT_DEF GDB_DatabaseLocks
WBROUTER_OUT_DEF Edif_Ensino_point
WBROUTER_OUT_DEF Comporta_line
WBROUTER_OUT_DEF Edif_Comerc_Serv_point
WBROUTER_OUT_DEF Edif_Agrop_Ext_Veg_Pesca_point
WBROUTER_OUT_DEF Fonte_Dagua_SHAPE_Index
WBROUTER_OUT_DEF Nome_Local_SHAPE_Index
WBROUTER_OUT_DEF Grupo_Transform_Energ_point_SHAPE_Index
WBROUTER_OUT_DEF Atracadouro_polygon
WBROUTER_OUT_DEF Confluencia_SHAPE_Index
WBROUTER_OUT_DEF Campo_Quadra_point
WBROUTER_OUT_DEF GDB_ReplicaLog
WBROUTER_OUT_DEF Elemento_Fisiog_Natural_line
WBROUTER_OUT_DEF Galeria_Bueiro_point_SHAPE_Index
WBROUTER_OUT_DEF Edif_Constr_Est_Med_point
WBROUTER_OUT_DEF Patio_polygon
WBROUTER_OUT_DEF Entroncamento
WBROUTER_OUT_DEF T_1_LineErrors
WBROUTER_OUT_DEF GDB_SpatialRefs
WBROUTER_OUT_DEF Edif_Ensino_polygon_SHAPE_Index
WBROUTER_OUT_DEF Edif_Pub_Civil_polygon_SHAPE_Index
WBROUTER_OUT_DEF Terreno_Exposto
WBROUTER_OUT_DEF Edif_Comunic_point
WBROUTER_OUT_DEF Edif_Comerc_Serv_polygon
WBROUTER_OUT_DEF Torre_Comunic_SHAPE_Index
WBROUTER_OUT_DEF Edif_Pub_Militar_point
WBROUTER_OUT_DEF Antena_Comunic_SHAPE_Index
WBROUTER_OUT_DEF Elemento_Fisiog_Natural_line_SHAPE_Index
WBROUTER_OUT_DEF Edif_Saude_polygon
WBROUTER_OUT_DEF Travessia_point
WBROUTER_OUT_DEF Gruta_Caverna_point_SHAPE_Index
WBROUTER_OUT_DEF Trilha_Picada
WBROUTER_OUT_DEF Pto_Est_Med_Fenomenos
WBROUTER_OUT_DEF Pista_Competicao_line
WBROUTER_OUT_DEF Area_Edificada_SHAPE_Index
WBROUTER_OUT_DEF Edif_Const_Turistica_point_SHAPE_Index
WBROUTER_OUT_DEF Aglomerado_Rural_SHAPE_Index
WBROUTER_OUT_DEF Area_Energia_Eletrica_SHAPE_Index
WBROUTER_OUT_DEF Area_Industrial_SHAPE_Index
WBROUTER_OUT_DEF Edif_Ext_Mineral_polygon
WBROUTER_OUT_DEF Edif_Comerc_Serv_polygon_SHAPE_Index
WBROUTER_OUT_DEF T_1_PointErrors
WBROUTER_OUT_DEF Area_Ext_Mineral_SHAPE_Index
WBROUTER_OUT_DEF Edif_Rodoviaria_polygon
WBROUTER_OUT_DEF GDB_ItemRelationships
WBROUTER_OUT_DEF Edif_Pub_Militar_polygon_SHAPE_Index
WBROUTER_OUT_DEF Area_Energia_Eletrica
WBROUTER_OUT_DEF Edif_Servico_Social_polygon_SHAPE_Index
WBROUTER_OUT_DEF Edif_Abast_Agua_point
WBROUTER_OUT_DEF Elemento_Fisiog_Natural_point_SHAPE_Index
WBROUTER_OUT_DEF Edif_Religiosa_polygon
WBROUTER_OUT_DEF Trecho_Drenagem
WBROUTER_OUT_DEF Edif_Ext_Mineral_polygon_SHAPE_Index
WBROUTER_OUT_DEF Posto_Combustivel_point_SHAPE_Index
WBROUTER_OUT_DEF Selections
WBROUTER_OUT_DEF Ponto_Drenagem_SHAPE_Index
WBROUTER_OUT_DEF Est_Gerad_Energia_Eletr_polygon_SHAPE_Index
WBROUTER_OUT_DEF Pista_Ponto_Pouso_polygon_SHAPE_Index
WBROUTER_OUT_DEF Edif_Servico_Social_point_SHAPE_Index
WBROUTER_OUT_DEF Pista_Competicao_line_SHAPE_Index
WBROUTER_OUT_DEF Edif_Rodoviaria_polygon_SHAPE_Index
WBROUTER_OUT_DEF Pista_Ponto_Pouso_polygon
WBROUTER_OUT_DEF Area_Edificada
WBROUTER_OUT_DEF Edif_Habitacional_point
WBROUTER_OUT_DEF GDB_ColumnInfo
WBROUTER_OUT_DEF Terreno_Suj_Inundacao
WBROUTER_OUT_DEF Cemiterio_point_SHAPE_Index
WBROUTER_OUT_DEF Ponto_Trecho_Energia_SHAPE_Index
WBROUTER_OUT_DEF Edif_Rodoviaria_point
WBROUTER_OUT_DEF Trecho_Rodoviario_SHAPE_Index
WBROUTER_OUT_DEF Edif_Habitacional_point_SHAPE_Index
WBROUTER_OUT_DEF Sumidouro_Vertedouro_SHAPE_Index
WBROUTER_OUT_DEF Edif_Industrial_point
WBROUTER_OUT_DEF Est_Gerad_Energia_Eletr_polygon
WBROUTER_OUT_DEF Ponto_Rodoviario_Ferrov_SHAPE_Index
WBROUTER_OUT_DEF Banco_Areia_polygon_SHAPE_Index
WBROUTER_OUT_DEF Edif_Servico_Social_point
WBROUTER_OUT_DEF Atracadouro_point
WBROUTER_OUT_DEF Deposito_Geral_polygon_SHAPE_Index
WBROUTER_OUT_DEF Edif_Industrial_polygon_SHAPE_Index
WBROUTER_OUT_DEF Massa_Dagua
WBROUTER_OUT_DEF Edif_Const_Lazer_polygon_SHAPE_Index
WBROUTER_OUT_DEF Identific_Trecho_Rod
WBROUTER_OUT_DEF Cerrado_Cerradao_SHAPE_Index
WBROUTER_OUT_DEF Nome_Local
WBROUTER_OUT_DEF Campo
WBROUTER_OUT_DEF Edif_Rodoviaria_point_SHAPE_Index
WBROUTER_OUT_DEF Cemiterio_point
WBROUTER_OUT_DEF Identific_Trecho_Rod_SHAPE_Index
WBROUTER_OUT_DEF Edif_Const_Lazer_point_SHAPE_Index
WBROUTER_OUT_DEF Ponto_Drenagem
WBROUTER_OUT_DEF Curva_Nivel
WBROUTER_OUT_DEF Comporta_line_SHAPE_Index
WBROUTER_OUT_DEF Terreno_Exposto_SHAPE_Index
WBROUTER_OUT_DEF Trecho_Duto_SHAPE_Index
WBROUTER_OUT_DEF Campo_Quadra_point_SHAPE_Index
WBROUTER_OUT_DEF Area_Lazer
WBROUTER_OUT_DEF Dep_Abast_Agua_point_SHAPE_Index
WBROUTER_OUT_DEF Trecho_Drenagem_SHAPE_Index
WBROUTER_OUT_DEF Edif_Saude_point_SHAPE_Index
WBROUTER_OUT_DEF Trecho_Massa_Dagua_SHAPE_Index
WBROUTER_OUT_DEF Caatinga_SHAPE_Index
WBROUTER_OUT_DEF GDB_GeomColumns
WBROUTER_OUT_DEF Arruamento_SHAPE_Index
WBROUTER_OUT_DEF Ponte_point
WBROUTER_OUT_DEF T_1_LineErrors_Shape_Index
WBROUTER_OUT_DEF Arquibancada_point_SHAPE_Index
WBROUTER_OUT_DEF Trecho_Energia_SHAPE_Index
WBROUTER_OUT_DEF Edif_Abast_Agua_point_SHAPE_Index
WBROUTER_OUT_DEF Ilha_polygon_SHAPE_Index
WBROUTER_OUT_DEF Arquibancada_point
WBROUTER_OUT_DEF Area_Uso_Comunitario_point
WBROUTER_OUT_DEF Cerrado_Cerradao
WBROUTER_OUT_DEF Torre_Comunic
WBROUTER_OUT_DEF T_1_PointErrors_Shape_Index
WBROUTER_OUT_DEF Grupo_Transform_Energ_point
WBROUTER_OUT_DEF Gruta_Caverna_point
WBROUTER_OUT_DEF Deposito_Geral_point_SHAPE_Index
WBROUTER_OUT_DEF Alter_Fisiog_Antropica_line_SHAPE_Index
WBROUTER_OUT_DEF Ponto_Duto_SHAPE_Index
WBROUTER_OUT_DEF Edif_Const_Lazer_polygon
WBROUTER_OUT_DEF Area_Uso_Comunitario_point_SHAPE_Index
WBROUTER_OUT_DEF Edif_Pub_Militar_point_SHAPE_Index
WBROUTER_OUT_DEF Edif_Const_Turistica_point
WBROUTER_OUT_DEF Delimitacao_Fisica
WBROUTER_OUT_DEF GDB_Items_Shape_Index
WBROUTER_OUT_DEF Area_Lazer_SHAPE_Index
WBROUTER_OUT_DEF Ponto_Trecho_Energia
WBROUTER_OUT_DEF Travessia_point_SHAPE_Index
WBROUTER_OUT_DEF Confluencia
WBROUTER_OUT_DEF Area_Industrial
WBROUTER_OUT_DEF Alter_Fisiog_Antropica_line
WBROUTER_OUT_DEF Dep_Saneamento_point
WBROUTER_OUT_DEF Edif_Pub_Militar_polygon
WBROUTER_OUT_DEF Edif_Saude_polygon_SHAPE_Index
WBROUTER_OUT_DEF Antena_Comunic
WBROUTER_OUT_DEF Cemiterio_polygon_SHAPE_Index
WBROUTER_OUT_DEF T_1_PolyErrors
WBROUTER_OUT_DEF Ponto_Inicio_Drenagem
WBROUTER_OUT_DEF Entroncamento_SHAPE_Index
WBROUTER_OUT_DEF Edif_Industrial_polygon
WBROUTER_OUT_DEF Edif_Constr_Est_Med_point_SHAPE_Index
WBROUTER_OUT_DEF Trecho_Energia
WBROUTER_OUT_DEF Rocha_polygon_SHAPE_Index
WBROUTER_OUT_DEF Trecho_Duto
WBROUTER_OUT_DEF Edif_Pub_Civil_point
WBROUTER_OUT_DEF Campo_Quadra_polygon
WBROUTER_OUT_DEF Edif_Ensino_point_SHAPE_Index
WBROUTER_OUT_DEF Ponto_Inicio_Drenagem_SHAPE_Index
WBROUTER_OUT_DEF Posto_Combustivel_point
WBROUTER_OUT_DEF Fonte_Dagua
WBROUTER_OUT_DEF Ilha_polygon
WBROUTER_OUT_DEF T_1_DirtyAreas_DirtyArea_Index
WBROUTER_OUT_DEF Barragem_line_SHAPE_Index
WBROUTER_OUT_DEF Sumidouro_Vertedouro
WBROUTER_OUT_DEF Dep_Saneamento_polygon
WBROUTER_OUT_DEF Galeria_Bueiro_point
WBROUTER_OUT_DEF Rocha_polygon
WBROUTER_OUT_DEF Deposito_Geral_point
WBROUTER_OUT_DEF T_1_DirtyAreas
WBROUTER_OUT_DEF Elemento_Fisiog_Natural_point
WBROUTER_OUT_DEF Ponte_point_SHAPE_Index
WBROUTER_OUT_DEF Edif_Agrop_Ext_Veg_Pesca_point_SHAPE_Index
WBROUTER_OUT_DEF Dep_Saneamento_point_SHAPE_Index
WBROUTER_OUT_DEF Trilha_Picada_SHAPE_Index
